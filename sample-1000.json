[
  {
    "code":"  Ins_FLIPRGOFF( TT_ExecContext  exc,\n                 FT_Long*        args )\n  {\n    FT_UShort  I, K, L;\n#ifdef TT_SUPPORT_SUBPIXEL_HINTING_MINIMAL\n    if ( SUBPIXEL_HINTING_MINIMAL    &&\n         exc->backward_compatibility &&\n         exc->iupx_called            &&\n         exc->iupy_called            )\n      return;\n#endif\n    K = (FT_UShort)args[1];\n    L = (FT_UShort)args[0];\n    if ( BOUNDS( K, exc->pts.n_points ) ||\n         BOUNDS( L, exc->pts.n_points ) )\n    {\n      if ( exc->pedantic_hinting )\n        exc->error = FT_THROW( Invalid_Reference );\n      return;\n    }\n    for ( I = L; I <= K; I++ )\n      exc->pts.tags[I] &= ~FT_CURVE_TAG_ON;\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":10600
  },
  {
    "code":"  void TestLessDrawingInSubsequence() {\n    FakeDisplayItemClient first(\"first\");\n    GraphicsContext context(GetPaintController());\n    InitRootChunk();\n    {\n      SubsequenceRecorder r(context, first);\n      DrawRect(context, first, kBackgroundType, FloatRect(100, 100, 300, 300));\n      DrawRect(context, first, kForegroundType, FloatRect(100, 100, 300, 300));\n    }\n    GetPaintController().CommitNewDisplayItems();\n    InitRootChunk();\n    {\n      EXPECT_FALSE(\n          SubsequenceRecorder::UseCachedSubsequenceIfPossible(context, first));\n      SubsequenceRecorder r(context, first);\n      DrawRect(context, first, kBackgroundType, FloatRect(100, 100, 300, 300));\n    }\n    GetPaintController().CommitNewDisplayItems();\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":136557
  },
  {
    "code":"asmlinkage void __kprobes do_sparc64_fault(struct pt_regs *regs)\n{\n  struct mm_struct *mm = current->mm;\n  struct vm_area_struct *vma;\n  unsigned int insn = 0;\n  int si_code, fault_code, fault;\n  unsigned long address, mm_rss;\n  fault_code = get_thread_fault_code();\n  if (notify_page_fault(regs))\n    return;\n  si_code = SEGV_MAPERR;\n  address = current_thread_info()->fault_address;\n  if ((fault_code & FAULT_CODE_ITLB) &&\n      (fault_code & FAULT_CODE_DTLB))\n    BUG();\n  if (test_thread_flag(TIF_32BIT)) {\n    if (!(regs->tstate & TSTATE_PRIV)) {\n      if (unlikely((regs->tpc >> 32) != 0)) {\n        bogus_32bit_fault_tpc(regs);\n        goto intr_or_no_mm;\n      }\n    }\n    if (unlikely((address >> 32) != 0)) {\n      bogus_32bit_fault_address(regs, address);\n      goto intr_or_no_mm;\n    }\n  }\n  if (regs->tstate & TSTATE_PRIV) {\n    unsigned long tpc = regs->tpc;\n    if ((tpc >= KERNBASE && tpc < (unsigned long) __init_end) ||\n        (tpc >= MODULES_VADDR && tpc < MODULES_END)) {\n    } else {\n      bad_kernel_pc(regs, address);\n      return;\n    }\n  }\n   if (in_atomic() || !mm)\n     goto intr_or_no_mm;\n  perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);\n   if (!down_read_trylock(&mm->mmap_sem)) {\n     if ((regs->tstate & TSTATE_PRIV) &&\n        !search_exception_tables(regs->tpc)) {\n      insn = get_fault_insn(regs, insn);\n      goto handle_kernel_fault;\n    }\n    down_read(&mm->mmap_sem);\n  }\n  vma = find_vma(mm, address);\n  if (!vma)\n    goto bad_area;\n  if (((fault_code &\n        (FAULT_CODE_DTLB | FAULT_CODE_WRITE | FAULT_CODE_WINFIXUP)) == FAULT_CODE_DTLB) &&\n      (vma->vm_flags & VM_WRITE) != 0) {\n    insn = get_fault_insn(regs, 0);\n    if (!insn)\n      goto continue_fault;\n    if ((insn & 0xc0200000) == 0xc0200000 &&\n        (insn & 0x01780000) != 0x01680000) {\n      fault_code |= FAULT_CODE_WRITE;\n    }\n  }\ncontinue_fault:\n  if (vma->vm_start <= address)\n    goto good_area;\n  if (!(vma->vm_flags & VM_GROWSDOWN))\n    goto bad_area;\n  if (!(fault_code & FAULT_CODE_WRITE)) {\n    insn = get_fault_insn(regs, insn);\n    if ((insn & 0xc0800000) == 0xc0800000) {\n      unsigned char asi;\n      if (insn & 0x2000)\n        asi = (regs->tstate >> 24);\n      else\n        asi = (insn >> 5);\n      if ((asi & 0xf2) == 0x82)\n        goto bad_area;\n    }\n  }\n  if (expand_stack(vma, address))\n    goto bad_area;\ngood_area:\n  si_code = SEGV_ACCERR;\n  if ((fault_code & FAULT_CODE_ITLB) && !(vma->vm_flags & VM_EXEC)) {\n    BUG_ON(address != regs->tpc);\n    BUG_ON(regs->tstate & TSTATE_PRIV);\n    goto bad_area;\n  }\n  if (fault_code & FAULT_CODE_WRITE) {\n    if (!(vma->vm_flags & VM_WRITE))\n      goto bad_area;\n    if (tlb_type == spitfire &&\n        (vma->vm_flags & VM_EXEC) != 0 &&\n        vma->vm_file != NULL)\n      set_thread_fault_code(fault_code |\n                FAULT_CODE_BLKCOMMIT);\n  } else {\n    if (!(vma->vm_flags & (VM_READ | VM_EXEC)))\n      goto bad_area;\n  }\n  fault = handle_mm_fault(mm, vma, address, (fault_code & FAULT_CODE_WRITE) ? FAULT_FLAG_WRITE : 0);\n  if (unlikely(fault & VM_FAULT_ERROR)) {\n    if (fault & VM_FAULT_OOM)\n      goto out_of_memory;\n    else if (fault & VM_FAULT_SIGBUS)\n      goto do_sigbus;\n    BUG();\n   }\n   if (fault & VM_FAULT_MAJOR) {\n     current->maj_flt++;\n    perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,\n            regs, address);\n   } else {\n     current->min_flt++;\n    perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,\n            regs, address);\n   }\n   up_read(&mm->mmap_sem);\n  mm_rss = get_mm_rss(mm);\n#ifdef CONFIG_HUGETLB_PAGE\n  mm_rss -= (mm->context.huge_pte_count * (HPAGE_SIZE \/ PAGE_SIZE));\n#endif\n  if (unlikely(mm_rss >\n         mm->context.tsb_block[MM_TSB_BASE].tsb_rss_limit))\n    tsb_grow(mm, MM_TSB_BASE, mm_rss);\n#ifdef CONFIG_HUGETLB_PAGE\n  mm_rss = mm->context.huge_pte_count;\n  if (unlikely(mm_rss >\n         mm->context.tsb_block[MM_TSB_HUGE].tsb_rss_limit))\n    tsb_grow(mm, MM_TSB_HUGE, mm_rss);\n#endif\n  return;\nbad_area:\n  insn = get_fault_insn(regs, insn);\n  up_read(&mm->mmap_sem);\nhandle_kernel_fault:\n  do_kernel_fault(regs, si_code, fault_code, insn, address);\n  return;\nout_of_memory:\n  insn = get_fault_insn(regs, insn);\n  up_read(&mm->mmap_sem);\n  if (!(regs->tstate & TSTATE_PRIV)) {\n    pagefault_out_of_memory();\n    return;\n  }\n  goto handle_kernel_fault;\nintr_or_no_mm:\n  insn = get_fault_insn(regs, 0);\n  goto handle_kernel_fault;\ndo_sigbus:\n  insn = get_fault_insn(regs, insn);\n  up_read(&mm->mmap_sem);\n  do_fault_siginfo(BUS_ADRERR, SIGBUS, regs, insn, fault_code);\n  if (regs->tstate & TSTATE_PRIV)\n    goto handle_kernel_fault;\n}\n",
    "vul":1,
    "flaw_line_no":[
      39,
      110,
      111,
      114,
      115
    ],
    "bigvul_id":178989
  },
  {
    "code":"WebContentsImpl::ColorChooserInfo::ColorChooserInfo(int render_process_id,\n                                                    int render_frame_id,\n                                                    ColorChooser* chooser,\n                                                    int identifier)\n    : render_process_id(render_process_id),\n      render_frame_id(render_frame_id),\n      chooser(chooser),\n      identifier(identifier) {\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":144446
  },
  {
    "code":"LayerListReverseIterator<Layer> LayerTreeHost::rend() {\n  return LayerListReverseIterator<Layer>(nullptr);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":149877
  },
  {
    "code":"void DateTimeSymbolicFieldElement::stepDown()\n{\n    if (hasValue()) {\n        if (!indexIsInRange(--m_selectedIndex))\n            m_selectedIndex = m_maximumIndex;\n    } else\n        m_selectedIndex = m_maximumIndex;\n    updateVisibleValue(DispatchEvent);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":110200
  },
  {
    "code":"void NavigationControllerImpl::SetMaxRestoredPageID(int32 max_id) {\n  max_restored_page_id_ = max_id;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":119822
  },
  {
    "code":"find_KRB5SignedPath(krb5_context context,\n        const AuthorizationData *ad,\n        krb5_data *data)\n{\n    AuthorizationData child;\n    krb5_error_code ret;\n    int pos;\n    if (ad == NULL || ad->len == 0)\n  return KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    pos = ad->len - 1;\n    if (ad->val[pos].ad_type != KRB5_AUTHDATA_IF_RELEVANT)\n  return KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    ret = decode_AuthorizationData(ad->val[pos].ad_data.data,\n           ad->val[pos].ad_data.length,\n           &child,\n           NULL);\n    if (ret) {\n  krb5_set_error_message(context, ret, \"Failed to decode \"\n             \"IF_RELEVANT with %d\", ret);\n  return ret;\n    }\n    if (child.len != 1) {\n  free_AuthorizationData(&child);\n  return KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n    if (child.val[0].ad_type != KRB5_AUTHDATA_SIGNTICKET) {\n  free_AuthorizationData(&child);\n  return KRB5KDC_ERR_PADATA_TYPE_NOSUPP;\n    }\n    if (data)\n  ret = der_copy_octet_string(&child.val[0].ad_data, data);\n    free_AuthorizationData(&child);\n    return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":67983
  },
  {
    "code":"bool Cues::LoadCuePoint() const {\n const long long stop = m_start + m_size;\n if (m_pos >= stop)\n return false; \n if (!Init()) {\n    m_pos = stop;\n return false;\n }\n IMkvReader* const pReader = m_pSegment->m_pReader;\n while (m_pos < stop) {\n const long long idpos = m_pos;\n long len;\n const long long id = ReadID(pReader, m_pos, len);\n if (id < 0 || (m_pos + len) > stop)\n return false;\n    m_pos += len; \n const long long size = ReadUInt(pReader, m_pos, len);\n if (size < 0 || (m_pos + len) > stop)\n return false;\n    m_pos += len; \n if ((m_pos + size) > stop)\n return false;\n if (id != 0x3B) { \n      m_pos += size; \n if (m_pos > stop)\n return false;\n continue;\n }\n if (m_preload_count < 1)\n return false;\n CuePoint* const pCP = m_cue_points[m_count];\n if (!pCP || (pCP->GetTimeCode() < 0 && (-pCP->GetTimeCode() != idpos)))\n return false;\n if (!pCP->Load(pReader)) {\n      m_pos = stop;\n return false;\n }\n ++m_count;\n --m_preload_count;\n    m_pos += size; \n if (m_pos > stop)\n return false;\n return true; \n }\n return false; \n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":177435
  },
  {
    "code":"static int vq2txq(struct virtqueue *vq)\n{\n  return (vq->index - 1) \/ 2;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":43020
  },
  {
    "code":"compare_table(struct rc_search_table *a, struct rc_search_table *b)\n{\n    return strcmp(a->param->name, b->param->name);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":84553
  },
  {
    "code":"extractImageSection(struct image_data *image, struct pageseg *section, \n                    unsigned char *src_buff, unsigned char *sect_buff)\n  {\n  unsigned  char  bytebuff1, bytebuff2;\n#ifdef DEVELMODE\n#endif\n  uint32    img_width, img_rowsize;\n#ifdef DEVELMODE\n  uint32    img_length;\n#endif\n  uint32    j, shift1, shift2, trailing_bits;\n  uint32    row, first_row, last_row, first_col, last_col;\n  uint32    src_offset, dst_offset, row_offset, col_offset;\n  uint32    offset1, offset2, full_bytes;\n  uint32    sect_width;\n#ifdef DEVELMODE\n  uint32    sect_length;\n#endif\n  uint16    bps, spp;\n#ifdef DEVELMODE\n  int      k;\n  unsigned char bitset;\n  static char *bitarray = NULL;\n#endif\n  img_width = image->width;\n#ifdef DEVELMODE\n  img_length = image->length;\n#endif\n  bps = image->bps;\n  spp = image->spp;\n#ifdef DEVELMODE\n#endif\n  src_offset = 0;\n  dst_offset = 0;\n#ifdef DEVELMODE\n  if (bitarray == NULL)\n    {\n    if ((bitarray = (char *)malloc(img_width)) == NULL)\n      {\n      TIFFError (\"\", \"DEBUG: Unable to allocate debugging bitarray\");\n      return (-1);\n      }\n    }\n#endif\n  first_row = section->y1;\n  last_row  = section->y2;\n  first_col = section->x1;\n  last_col  = section->x2;\n  sect_width = last_col - first_col + 1;\n#ifdef DEVELMODE\n  sect_length = last_row - first_row + 1;\n#endif\n  img_rowsize = ((img_width * bps + 7) \/ 8) * spp;\n  full_bytes = (sect_width * spp * bps) \/ 8;   \n  trailing_bits = (sect_width * bps) % 8;\n#ifdef DEVELMODE\n    TIFFError (\"\", \"First row: %d, last row: %d, First col: %d, last col: %d\\n\",\n           first_row, last_row, first_col, last_col);\n    TIFFError (\"\", \"Image width: %d, Image length: %d, bps: %d, spp: %d\\n\",\n     img_width, img_length, bps, spp);\n    TIFFError (\"\", \"Sect  width: %d,  Sect length: %d, full bytes: %d trailing bits %d\\n\", \n           sect_width, sect_length, full_bytes, trailing_bits);\n#endif\n  if ((bps % 8) == 0)\n    {\n    col_offset = first_col * spp * bps \/ 8;\n    for (row = first_row; row <= last_row; row++)\n      {\n      row_offset = row * img_rowsize;\n      src_offset = row_offset + col_offset;\n#ifdef DEVELMODE\n        TIFFError (\"\", \"Src offset: %8d, Dst offset: %8d\", src_offset, dst_offset); \n#endif\n      _TIFFmemcpy (sect_buff + dst_offset, src_buff + src_offset, full_bytes);\n      dst_offset += full_bytes;\n      }        \n    }\n  else\n    { \n    shift1  = spp * ((first_col * bps) % 8);\n    shift2  = spp * ((last_col * bps) % 8);\n    for (row = first_row; row <= last_row; row++)\n      {\n      row_offset = row * img_rowsize;\n      offset1 = row_offset + (first_col * bps \/ 8);\n      offset2 = row_offset + (last_col * bps \/ 8);\n#ifdef DEVELMODE\n      for (j = 0, k = 7; j < 8; j++, k--)\n        {\n        bitset = *(src_buff + offset1) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n        }\n      sprintf(&bitarray[8], \" \");\n      sprintf(&bitarray[9], \" \");\n      for (j = 10, k = 7; j < 18; j++, k--)\n        {\n        bitset = *(src_buff + offset2) & (((unsigned char)1 << k)) ? 1 : 0;\n        sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n        }\n      bitarray[18] = '\\0';\n      TIFFError (\"\", \"Row: %3d Offset1: %d,  Shift1: %d,    Offset2: %d,  Shift2:  %d\\n\", \n                 row, offset1, shift1, offset2, shift2); \n#endif\n      bytebuff1 = bytebuff2 = 0;\n      if (shift1 == 0) \n        {\n  _TIFFmemcpy (sect_buff + dst_offset, src_buff + offset1, full_bytes);\n#ifdef DEVELMODE\n  TIFFError (\"\", \"        Alligned data src offset1: %8d, Dst offset: %8d\\n\", offset1, dst_offset); \n  sprintf(&bitarray[18], \"\\n\");\n  sprintf(&bitarray[19], \"\\t\");\n        for (j = 20, k = 7; j < 28; j++, k--)\n          {\n          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n          sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n          }\n        bitarray[28] = ' ';\n        bitarray[29] = ' ';\n#endif\n        dst_offset += full_bytes;\n        if (trailing_bits != 0)\n          {\n    bytebuff2 = src_buff[offset2] & ((unsigned char)255 << (7 - shift2));\n          sect_buff[dst_offset] = bytebuff2;\n#ifdef DEVELMODE\n    TIFFError (\"\", \"        Trailing bits src offset:  %8d, Dst offset: %8d\\n\", \n                              offset2, dst_offset); \n          for (j = 30, k = 7; j < 38; j++, k--)\n            {\n            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n            sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n            }\n          bitarray[38] = '\\0';\n          TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray);\n#endif\n          dst_offset++;\n          }\n        }\n      else   \n        {\n#ifdef DEVELMODE\n    TIFFError (\"\", \"        Unalligned data src offset: %8d, Dst offset: %8d\\n\", offset1 , dst_offset); \n#endif\n        for (j = 0; j <= full_bytes; j++) \n          {\n    bytebuff1 = src_buff[offset1 + j] & ((unsigned char)255 >> shift1);\n    bytebuff2 = src_buff[offset1 + j + 1] & ((unsigned char)255 << (7 - shift1));\n          sect_buff[dst_offset + j] = (bytebuff1 << shift1) | (bytebuff2 >> (8 - shift1));\n          }\n#ifdef DEVELMODE\n  sprintf(&bitarray[18], \"\\n\");\n  sprintf(&bitarray[19], \"\\t\");\n        for (j = 20, k = 7; j < 28; j++, k--)\n          {\n          bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n          sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n          }\n        bitarray[28] = ' ';\n        bitarray[29] = ' ';\n#endif\n        dst_offset += full_bytes;\n        if (trailing_bits != 0)\n          {\n#ifdef DEVELMODE\n      TIFFError (\"\", \"        Trailing bits   src offset: %8d, Dst offset: %8d\\n\", offset1 + full_bytes, dst_offset); \n#endif\n    if (shift2 > shift1)\n            {\n      bytebuff1 = src_buff[offset1 + full_bytes] & ((unsigned char)255 << (7 - shift2));\n            bytebuff2 = bytebuff1 & ((unsigned char)255 << shift1);\n            sect_buff[dst_offset] = bytebuff2;\n#ifdef DEVELMODE\n      TIFFError (\"\", \"        Shift2 > Shift1\\n\"); \n#endif\n            }\n          else\n            {\n      if (shift2 < shift1)\n              {\n              bytebuff2 = ((unsigned char)255 << (shift1 - shift2 - 1));\n        sect_buff[dst_offset] &= bytebuff2;\n#ifdef DEVELMODE\n        TIFFError (\"\", \"        Shift2 < Shift1\\n\"); \n#endif\n              }\n#ifdef DEVELMODE\n            else\n        TIFFError (\"\", \"        Shift2 == Shift1\\n\"); \n#endif\n            }\n    }\n#ifdef DEVELMODE\n    sprintf(&bitarray[28], \" \");\n    sprintf(&bitarray[29], \" \");\n          for (j = 30, k = 7; j < 38; j++, k--)\n            {\n            bitset = *(sect_buff + dst_offset) & (((unsigned char)1 << k)) ? 1 : 0;\n            sprintf(&bitarray[j], (bitset) ? \"1\" : \"0\");\n            }\n          bitarray[38] = '\\0';\n          TIFFError (\"\", \"\\tFirst and last bytes before and after masking:\\n\\t%s\\n\\n\", bitarray);\n#endif\n        dst_offset++;\n        }\n      }\n    }\n  return (0);\n  } \n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":48257
  },
  {
    "code":" static char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)\n {\n{\n  size_t len;\n  const char *p;\n  char c;\n  int ret = 1;\n  for (p = key; (c = *p); p++) {\n    if (!((c >= 'a' && c <= 'z')\n        || (c >= 'A' && c <= 'Z')\n        || (c >= '0' && c <= '9')\n        || c == ','\n        || c == '-')) {\n      ret = 0;\n      break;\n    }\n  }\n  len = p - key;\n  if (len == 0 || len > 128) {\n    ret = 0;\n  }\n  return ret;\n}\nstatic char *ps_files_path_create(char *buf, size_t buflen, ps_files *data, const char *key)\n{\n  size_t key_len;\n  const char *p;\n  int i;\n  int n;\n  key_len = strlen(key);\n  if (key_len <= data->dirdepth ||\n    buflen < (strlen(data->basedir) + 2 * data->dirdepth + key_len + 5 + sizeof(FILE_PREFIX))) {\n    return NULL;\n  }\n  p = key;\n  memcpy(buf, data->basedir, data->basedir_len);\n  n = data->basedir_len;\n  buf[n++] = PHP_DIR_SEPARATOR;\n  for (i = 0; i < (int)data->dirdepth; i++) {\n    buf[n++] = *p++;\n    buf[n++] = PHP_DIR_SEPARATOR;\n  }\n  memcpy(buf + n, FILE_PREFIX, sizeof(FILE_PREFIX) - 1);\n  n += sizeof(FILE_PREFIX) - 1;\n  memcpy(buf + n, key, key_len);\n  n += key_len;\n                ps_files_close(data);\n               if (!ps_files_valid_key(key)) {\n                        php_error_docref(NULL TSRMLS_CC, E_WARNING, \"The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'\");\n                       PS(invalid_session_id) = 1;\n                        return;\n                }\n                if (!ps_files_path_create(buf, sizeof(buf), data, key)) {\n                        return;\n                }\n  if (data->fd != -1) {\n#ifdef PHP_WIN32\n    flock(data->fd, LOCK_UN);\n#endif\n    close(data->fd);\n    data->fd = -1;\n  }\n}\nstatic void ps_files_open(ps_files *data, const char *key TSRMLS_DC)\n{\n  char buf[MAXPATHLEN];\n  if (data->fd < 0 || !data->lastkey || strcmp(key, data->lastkey)) {\n    if (data->lastkey) {\n      efree(data->lastkey);\n      data->lastkey = NULL;\n    }\n    ps_files_close(data);\n    if (!ps_files_valid_key(key)) {\n      php_error_docref(NULL TSRMLS_CC, E_WARNING, \"The session id is too long or contains illegal characters, valid characters are a-z, A-Z, 0-9 and '-,'\");\n      PS(invalid_session_id) = 1;\n      return;\n    }\n    if (!ps_files_path_create(buf, sizeof(buf), data, key)) {\n      return;\n    }\n    data->lastkey = estrdup(key);\n    data->fd = VCWD_OPEN_MODE(buf, O_CREAT | O_RDWR | O_BINARY, data->filemode);\n    if (data->fd != -1) {\n#ifndef PHP_WIN32\n      if (PG(open_basedir)) {\n        struct stat sbuf;\n        if (fstat(data->fd, &sbuf)) {\n          close(data->fd);\n          return;\n        }\n        if (S_ISLNK(sbuf.st_mode) && php_check_open_basedir(buf TSRMLS_CC)) {\n          close(data->fd);\n          return;\n        }\n      }\n#endif\n      flock(data->fd, LOCK_EX);\n#ifdef F_SETFD\n# ifndef FD_CLOEXEC\n#  define FD_CLOEXEC 1\n# endif\n      if (fcntl(data->fd, F_SETFD, FD_CLOEXEC)) {\n        php_error_docref(NULL TSRMLS_CC, E_WARNING, \"fcntl(%d, F_SETFD, FD_CLOEXEC) failed: %s (%d)\", data->fd, strerror(errno), errno);\n      }\n#endif\n    } else {\n      php_error_docref(NULL TSRMLS_CC, E_WARNING, \"open(%s, O_RDWR) failed: %s (%d)\", buf, strerror(errno), errno);\n    }\n  }\n}\nstatic int ps_files_cleanup_dir(const char *dirname, int maxlifetime TSRMLS_DC)\n{\n  DIR *dir;\n  char dentry[sizeof(struct dirent) + MAXPATHLEN];\n  struct dirent *entry = (struct dirent *) &dentry;\n  struct stat sbuf;\n  char buf[MAXPATHLEN];\n  time_t now;\n  int nrdels = 0;\n  size_t dirname_len;\n  dir = opendir(dirname);\n  if (!dir) {\n    php_error_docref(NULL TSRMLS_CC, E_NOTICE, \"ps_files_cleanup_dir: opendir(%s) failed: %s (%d)\", dirname, strerror(errno), errno);\n    return (0);\n  }\n  time(&now);\n        return (nrdels);\n }\n #define PS_FILES_DATA ps_files *data = PS_GET_MOD_DATA()\n PS_OPEN_FUNC(files)\n            (now - sbuf.st_mtime) > maxlifetime) {\n          VCWD_UNLINK(buf);\n          nrdels++;\n        }\n      }\n",
    "vul":1,
    "flaw_line_no":[
      48,
      50
    ],
    "bigvul_id":178042
  },
  {
    "code":"CString TextCodecUTF8::Encode(const UChar* characters,\n                              wtf_size_t length,\n                              UnencodableHandling) {\n  return EncodeCommon(characters, length);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":156341
  },
  {
    "code":"int CCITTFaxStream::lookChar() {\n  int code1, code2, code3;\n  int b1i, blackPixels, i, bits;\n  GBool gotEOL;\n  if (buf != EOF) {\n    return buf;\n  }\n  if (outputBits == 0) {\n    if (eof) {\n      return EOF;\n    }\n    err = gFalse;\n    if (nextLine2D) {\n      for (i = 0; i < columns && codingLine[i] < columns; ++i) {\n  refLine[i] = codingLine[i];\n      }\n      for (; i < columns + 2; ++i) {\n  refLine[i] = columns;\n      }\n      codingLine[0] = 0;\n      a0i = 0;\n      b1i = 0;\n      blackPixels = 0;\n      while (codingLine[a0i] < columns && !err) {\n  code1 = getTwoDimCode();\n  switch (code1) {\n  case twoDimPass:\n    if (likely(b1i + 1 < columns + 2)) {\n      addPixels(refLine[b1i + 1], blackPixels);\n      if (refLine[b1i + 1] < columns) {\n        b1i += 2;\n      }\n    }\n    break;\n  case twoDimHoriz:\n    code1 = code2 = 0;\n    if (blackPixels) {\n      do {\n        code1 += code3 = getBlackCode();\n      } while (code3 >= 64);\n      do {\n        code2 += code3 = getWhiteCode();\n      } while (code3 >= 64);\n    } else {\n      do {\n        code1 += code3 = getWhiteCode();\n      } while (code3 >= 64);\n      do {\n        code2 += code3 = getBlackCode();\n      } while (code3 >= 64);\n    }\n    addPixels(codingLine[a0i] + code1, blackPixels);\n    if (codingLine[a0i] < columns) {\n      addPixels(codingLine[a0i] + code2, blackPixels ^ 1);\n    }\n    while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n      b1i += 2;\n      if (unlikely(b1i > columns + 1)) {\n        error(errSyntaxError, getPos(),\n    \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n        err = gTrue;\n        break;\n      }\n    }\n    break;\n  case twoDimVertR3:\n    if (unlikely(b1i > columns + 1)) {\n      error(errSyntaxError, getPos(),\n        \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n      err = gTrue;\n      break;\n    }\n    addPixels(refLine[b1i] + 3, blackPixels);\n    blackPixels ^= 1;\n    if (codingLine[a0i] < columns) {\n      ++b1i;\n      while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n        b1i += 2;\n        if (unlikely(b1i > columns + 1)) {\n    error(errSyntaxError, getPos(),\n      \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n    err = gTrue;\n    break;\n        }\n      }\n    }\n    break;\n  case twoDimVertR2:\n    if (unlikely(b1i > columns + 1)) {\n      error(errSyntaxError, getPos(),\n        \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n      err = gTrue;\n      break;\n    }\n    addPixels(refLine[b1i] + 2, blackPixels);\n    blackPixels ^= 1;\n    if (codingLine[a0i] < columns) {\n      ++b1i;\n      while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n        b1i += 2;\n        if (unlikely(b1i > columns + 1)) {\n    error(errSyntaxError, getPos(),\n      \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n    err = gTrue;\n    break;\n        }\n      }\n    }\n    break;\n  case twoDimVertR1:\n    if (unlikely(b1i > columns + 1)) {\n      error(errSyntaxError, getPos(),\n        \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n      err = gTrue;\n      break;\n    }\n    addPixels(refLine[b1i] + 1, blackPixels);\n    blackPixels ^= 1;\n    if (codingLine[a0i] < columns) {\n      ++b1i;\n      while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n        b1i += 2;\n        if (unlikely(b1i > columns + 1)) {\n    error(errSyntaxError, getPos(),\n      \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n    err = gTrue;\n    break;\n        }\n      }\n    }\n    break;\n  case twoDimVert0:\n    if (unlikely(b1i > columns + 1)) {\n      error(errSyntaxError, getPos(),\n        \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n      err = gTrue;\n      break;\n    }\n    addPixels(refLine[b1i], blackPixels);\n    blackPixels ^= 1;\n    if (codingLine[a0i] < columns) {\n      ++b1i;\n      while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n        b1i += 2;\n        if (unlikely(b1i > columns + 1)) {\n    error(errSyntaxError, getPos(),\n      \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n    err = gTrue;\n    break;\n        }\n      }\n    }\n    break;\n  case twoDimVertL3:\n    if (unlikely(b1i > columns + 1)) {\n      error(errSyntaxError, getPos(),\n        \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n      err = gTrue;\n      break;\n    }\n    addPixelsNeg(refLine[b1i] - 3, blackPixels);\n    blackPixels ^= 1;\n    if (codingLine[a0i] < columns) {\n      if (b1i > 0) {\n        --b1i;\n      } else {\n        ++b1i;\n      }\n      while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n        b1i += 2;\n        if (unlikely(b1i > columns + 1)) {\n    error(errSyntaxError, getPos(),\n      \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n    err = gTrue;\n    break;\n        }\n      }\n    }\n    break;\n  case twoDimVertL2:\n    if (unlikely(b1i > columns + 1)) {\n      error(errSyntaxError, getPos(),\n        \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n      err = gTrue;\n      break;\n    }\n    addPixelsNeg(refLine[b1i] - 2, blackPixels);\n    blackPixels ^= 1;\n    if (codingLine[a0i] < columns) {\n      if (b1i > 0) {\n        --b1i;\n      } else {\n        ++b1i;\n      }\n      while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n        b1i += 2;\n        if (unlikely(b1i > columns + 1)) {\n          error(errSyntaxError, getPos(),\n      \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n          err = gTrue;\n          break;\n        }\n      }\n    }\n    break;\n  case twoDimVertL1:\n    if (unlikely(b1i > columns + 1)) {\n      error(errSyntaxError, getPos(),\n        \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n      err = gTrue;\n      break;\n    }\n    addPixelsNeg(refLine[b1i] - 1, blackPixels);\n    blackPixels ^= 1;\n    if (codingLine[a0i] < columns) {\n      if (b1i > 0) {\n        --b1i;\n      } else {\n        ++b1i;\n      }\n      while (refLine[b1i] <= codingLine[a0i] && refLine[b1i] < columns) {\n        b1i += 2;\n        if (unlikely(b1i > columns + 1)) {\n    error(errSyntaxError, getPos(),\n      \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n    err = gTrue;\n    break;\n        }\n      }\n    }\n    break;\n  case EOF:\n    addPixels(columns, 0);\n    eof = gTrue;\n    break;\n  default:\n    error(errSyntaxError, getPos(),\n    \"Bad 2D code {0:04x} in CCITTFax stream\", code1);\n    addPixels(columns, 0);\n    err = gTrue;\n    break;\n  }\n      }\n    } else {\n      codingLine[0] = 0;\n      a0i = 0;\n      blackPixels = 0;\n      while (codingLine[a0i] < columns) {\n  code1 = 0;\n  if (blackPixels) {\n    do {\n      code1 += code3 = getBlackCode();\n    } while (code3 >= 64);\n  } else {\n    do {\n      code1 += code3 = getWhiteCode();\n    } while (code3 >= 64);\n  }\n  addPixels(codingLine[a0i] + code1, blackPixels);\n  blackPixels ^= 1;\n      }\n    }\n    gotEOL = gFalse;\n    if (!endOfBlock && row == rows - 1) {\n      eof = gTrue;\n    } else if (endOfLine || !byteAlign) {\n      code1 = lookBits(12);\n      if (endOfLine) {\n  while (code1 != EOF && code1 != 0x001) {\n    eatBits(1);\n    code1 = lookBits(12);\n  }\n      } else {\n  while (code1 == 0) {\n    eatBits(1);\n    code1 = lookBits(12);\n  }\n      }\n      if (code1 == 0x001) {\n  eatBits(12);\n  gotEOL = gTrue;\n      }\n    }\n    if (byteAlign && !gotEOL) {\n      inputBits &= ~7;\n    }\n    if (lookBits(1) == EOF) {\n      eof = gTrue;\n    }\n    if (!eof && encoding > 0) {\n      nextLine2D = !lookBits(1);\n      eatBits(1);\n    }\n    if (endOfBlock && !endOfLine && byteAlign) {\n      code1 = lookBits(24);\n      if (code1 == 0x001001) {\n  eatBits(12);\n  gotEOL = gTrue;\n      }\n    }\n    if (endOfBlock && gotEOL) {\n      code1 = lookBits(12);\n      if (code1 == 0x001) {\n  eatBits(12);\n  if (encoding > 0) {\n    lookBits(1);\n    eatBits(1);\n  }\n  if (encoding >= 0) {\n    for (i = 0; i < 4; ++i) {\n      code1 = lookBits(12);\n      if (code1 != 0x001) {\n        error(errSyntaxError, getPos(),\n        \"Bad RTC code in CCITTFax stream\");\n      }\n      eatBits(12);\n      if (encoding > 0) {\n        lookBits(1);\n        eatBits(1);\n      }\n    }\n  }\n  eof = gTrue;\n      }\n    } else if (err && endOfLine) {\n      while (1) {\n  code1 = lookBits(13);\n  if (code1 == EOF) {\n    eof = gTrue;\n    return EOF;\n  }\n  if ((code1 >> 1) == 0x001) {\n    break;\n  }\n  eatBits(1);\n      }\n      eatBits(12); \n      if (encoding > 0) {\n  eatBits(1);\n  nextLine2D = !(code1 & 1);\n      }\n    }\n    if (codingLine[0] > 0) {\n      outputBits = codingLine[a0i = 0];\n    } else {\n      outputBits = codingLine[a0i = 1];\n    }\n    ++row;\n  }\n  if (outputBits >= 8) {\n    buf = (a0i & 1) ? 0x00 : 0xff;\n    outputBits -= 8;\n    if (outputBits == 0 && codingLine[a0i] < columns) {\n      ++a0i;\n      outputBits = codingLine[a0i] - codingLine[a0i - 1];\n    }\n  } else {\n    bits = 8;\n    buf = 0;\n    do {\n      if (outputBits > bits) {\n  buf <<= bits;\n  if (!(a0i & 1)) {\n    buf |= 0xff >> (8 - bits);\n  }\n  outputBits -= bits;\n  bits = 0;\n      } else {\n  buf <<= outputBits;\n  if (!(a0i & 1)) {\n    buf |= 0xff >> (8 - outputBits);\n  }\n  bits -= outputBits;\n  outputBits = 0;\n  if (codingLine[a0i] < columns) {\n    ++a0i;\n    if (unlikely(a0i > columns)) {\n      error(errSyntaxError, getPos(),\n        \"Bad bits {0:04x} in CCITTFax stream\", bits);\n        err = gTrue;\n        break;\n    }\n    outputBits = codingLine[a0i] - codingLine[a0i - 1];\n  } else if (bits > 0) {\n    buf <<= bits;\n    bits = 0;\n  }\n      }\n    } while (bits);\n  }\n  if (black) {\n    buf ^= 0xff;\n  }\n  return buf;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":4163
  },
  {
    "code":"SProcXFixesSetCursorName(ClientPtr client)\n{\n    REQUEST(xXFixesSetCursorNameReq);\n    swaps(&stuff->length);\n    REQUEST_AT_LEAST_SIZE(xXFixesSetCursorNameReq);\n    swapl(&stuff->cursor);\n    swaps(&stuff->nbytes);\n    return (*ProcXFixesVector[stuff->xfixesReqType]) (client);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":17666
  },
  {
    "code":"ExprResolveMaskLookup(struct xkb_context *ctx, const ExprDef *expr,\n                      unsigned int *val_rtrn, IdentLookupFunc lookup,\n                      const void *lookupPriv)\n{\n    bool ok = false;\n    unsigned int l = 0, r = 0;\n    int v;\n    ExprDef *left, *right;\n    const char *bogus = NULL;\n    switch (expr->expr.op) {\n    case EXPR_VALUE:\n        if (expr->expr.value_type != EXPR_TYPE_INT) {\n            log_err(ctx,\n                    \"Found constant of type %s where a mask was expected\\n\",\n                    expr_value_type_to_string(expr->expr.value_type));\n            return false;\n        }\n        *val_rtrn = (unsigned int) expr->integer.ival;\n        return true;\n    case EXPR_IDENT:\n        ok = lookup(ctx, lookupPriv, expr->ident.ident, EXPR_TYPE_INT,\n                    val_rtrn);\n        if (!ok)\n            log_err(ctx, \"Identifier \\\"%s\\\" of type int is unknown\\n\",\n                    xkb_atom_text(ctx, expr->ident.ident));\n        return ok;\n    case EXPR_FIELD_REF:\n        log_err(ctx, \"Default \\\"%s.%s\\\" of type int is unknown\\n\",\n                xkb_atom_text(ctx, expr->field_ref.element),\n                xkb_atom_text(ctx, expr->field_ref.field));\n        return false;\n    case EXPR_ARRAY_REF:\n        bogus = \"array reference\";\n    case EXPR_ACTION_DECL:\n        if (bogus == NULL)\n            bogus = \"function use\";\n        log_err(ctx,\n                \"Unexpected %s in mask expression; Expression Ignored\\n\",\n                bogus);\n        return false;\n    case EXPR_ADD:\n    case EXPR_SUBTRACT:\n    case EXPR_MULTIPLY:\n    case EXPR_DIVIDE:\n        left = expr->binary.left;\n        right = expr->binary.right;\n        if (!ExprResolveMaskLookup(ctx, left, &l, lookup, lookupPriv) ||\n            !ExprResolveMaskLookup(ctx, right, &r, lookup, lookupPriv))\n            return false;\n        switch (expr->expr.op) {\n        case EXPR_ADD:\n            *val_rtrn = l | r;\n            break;\n        case EXPR_SUBTRACT:\n            *val_rtrn = l & (~r);\n            break;\n        case EXPR_MULTIPLY:\n        case EXPR_DIVIDE:\n            log_err(ctx, \"Cannot %s masks; Illegal operation ignored\\n\",\n                    (expr->expr.op == EXPR_DIVIDE ? \"divide\" : \"multiply\"));\n            return false;\n        default:\n            break;\n        }\n        return true;\n    case EXPR_ASSIGN:\n        log_wsgo(ctx, \"Assignment operator not implemented yet\\n\");\n        break;\n    case EXPR_INVERT:\n        left = expr->unary.child;\n        if (!ExprResolveIntegerLookup(ctx, left, &v, lookup, lookupPriv))\n            return false;\n        *val_rtrn = ~v;\n        return true;\n    case EXPR_UNARY_PLUS:\n    case EXPR_NEGATE:\n    case EXPR_NOT:\n        left = expr->unary.child;\n        if (!ExprResolveIntegerLookup(ctx, left, &v, lookup, lookupPriv))\n            log_err(ctx, \"The %s operator cannot be used with a mask\\n\",\n                    (expr->expr.op == EXPR_NEGATE ? \"-\" : \"!\"));\n        return false;\n    default:\n        log_wsgo(ctx, \"Unknown operator %d in ResolveMask\\n\",\n                 expr->expr.op);\n        break;\n    }\n    return false;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":78951
  },
  {
    "code":"LayoutUnit RenderFlexibleBox::marginBoxAscentForChild(RenderBox* child)\n{\n    LayoutUnit ascent = child->firstLineBoxBaseline();\n    if (ascent == -1)\n        ascent = crossAxisExtentForChild(child);\n    return ascent + flowAwareMarginBeforeForChild(child);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":125040
  },
  {
    "code":"megasas_issue_polled(struct megasas_instance *instance, struct megasas_cmd *cmd)\n{\n  struct megasas_header *frame_hdr = &cmd->frame->hdr;\n  frame_hdr->cmd_status = MFI_STAT_INVALID_STATUS;\n  frame_hdr->flags |= cpu_to_le16(MFI_FRAME_DONT_POST_IN_REPLY_QUEUE);\n  if (atomic_read(&instance->adprecovery) == MEGASAS_HW_CRITICAL_ERROR) {\n    dev_err(&instance->pdev->dev, \"Failed from %s %d\\n\",\n      __func__, __LINE__);\n    return DCMD_NOT_FIRED;\n  }\n  instance->instancet->issue_dcmd(instance, cmd);\n  return wait_and_poll(instance, cmd, instance->requestorId ?\n      MEGASAS_ROUTINE_WAIT_TIME_VF : MFI_IO_TIMEOUT_SECS);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":90373
  },
  {
    "code":"void WebKitTestController::OnPrintMessage(const std::string& message) {\n  printer_->AddMessageRaw(message);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":132584
  },
  {
    "code":"static int __ip_vs_addr_is_local_v6(const struct in6_addr *addr)\n{\n  struct rt6_info *rt;\n  struct flowi fl = {\n    .oif = 0,\n    .nl_u = {\n      .ip6_u = {\n        .daddr = *addr,\n        .saddr = { .s6_addr32 = {0, 0, 0, 0} }, } },\n  };\n  rt = (struct rt6_info *)ip6_route_output(&init_net, NULL, &fl);\n  if (rt && rt->rt6i_dev && (rt->rt6i_dev->flags & IFF_LOOPBACK))\n      return 1;\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":29224
  },
  {
    "code":"void Performance::clearResourceTimings() {\n  resource_timing_buffer_.clear();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":166907
  },
  {
    "code":"void streamDecodeID(void *buf, streamID *id) {\n    uint64_t e[2];\n    memcpy(e,buf,sizeof(e));\n    id->ms = ntohu64(e[0]);\n    id->seq = ntohu64(e[1]);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":81788
  },
  {
    "code":"void CL_ReferencedPK3List_f( void ) {\n  Com_Printf( \"Referenced PK3 Names: %s\\n\", FS_ReferencedPakNames() );\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":95707
  },
  {
    "code":"line_intersect(PG_FUNCTION_ARGS)\n{\n  LINE     *l1 = PG_GETARG_LINE_P(0);\n  LINE     *l2 = PG_GETARG_LINE_P(1);\n  PG_RETURN_BOOL(!DatumGetBool(DirectFunctionCall2(line_parallel,\n                           LinePGetDatum(l1),\n                           LinePGetDatum(l2))));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":38905
  },
  {
    "code":"bool ewk_view_run_javascript_confirm(Evas_Object* ewkView, Evas_Object* frame, const char* message)\n{\n    DBG(\"ewkView=%p frame=%p message=%s\", ewkView, frame, message);\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api, false);\n    if (!smartData->api->run_javascript_confirm)\n        return false;\n    return smartData->api->run_javascript_confirm(smartData, frame, message);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":107598
  },
  {
    "code":"static void cdc_ncm_set_dgram_size(struct usbnet *dev, int new_size)\n{\n  struct cdc_ncm_ctx *ctx = (struct cdc_ncm_ctx *)dev->data[0];\n  u8 iface_no = ctx->control->cur_altsetting->desc.bInterfaceNumber;\n  __le16 max_datagram_size;\n  u16 mbim_mtu;\n  int err;\n  ctx->max_datagram_size = clamp_t(u32, new_size,\n           cdc_ncm_min_dgram_size(dev),\n           CDC_NCM_MAX_DATAGRAM_SIZE);\n  if (!(cdc_ncm_flags(dev) & USB_CDC_NCM_NCAP_MAX_DATAGRAM_SIZE))\n    goto out;\n  err = usbnet_read_cmd(dev, USB_CDC_GET_MAX_DATAGRAM_SIZE,\n            USB_TYPE_CLASS | USB_DIR_IN | USB_RECIP_INTERFACE,\n            0, iface_no, &max_datagram_size, 2);\n  if (err < 0) {\n    dev_dbg(&dev->intf->dev, \"GET_MAX_DATAGRAM_SIZE failed\\n\");\n    goto out;\n  }\n  if (le16_to_cpu(max_datagram_size) == ctx->max_datagram_size)\n    goto out;\n  max_datagram_size = cpu_to_le16(ctx->max_datagram_size);\n  err = usbnet_write_cmd(dev, USB_CDC_SET_MAX_DATAGRAM_SIZE,\n             USB_TYPE_CLASS | USB_DIR_OUT | USB_RECIP_INTERFACE,\n             0, iface_no, &max_datagram_size, 2);\n  if (err < 0)\n    dev_dbg(&dev->intf->dev, \"SET_MAX_DATAGRAM_SIZE failed\\n\");\nout:\n  dev->net->mtu = min_t(int, dev->net->mtu, ctx->max_datagram_size - cdc_ncm_eth_hlen(dev));\n  if (ctx->mbim_extended_desc) {\n    mbim_mtu = le16_to_cpu(ctx->mbim_extended_desc->wMTU);\n    if (mbim_mtu != 0 && mbim_mtu < dev->net->mtu)\n      dev->net->mtu = mbim_mtu;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":53629
  },
  {
    "code":"void FastEvaluateCurves16(register const cmsUInt16Number In[],\n                          register cmsUInt16Number Out[],\n                          register const void* D)\n{\n    Curves16Data* Data = (Curves16Data*) D;\n    int i;\n    for (i=0; i < Data ->nCurves; i++) {\n         Out[i] = Data -> Curves[i][In[i]];\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":41012
  },
  {
    "code":"    String getSerializedData(const char* url, const char* mimeType = 0)\n    {\n        const SerializedResource* resource = getResource(url, mimeType);\n        if (resource)\n            return String(resource->data->data(), resource->data->size());\n        return String();\n    }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":136230
  },
  {
    "code":"content::DownloadItem* MockDownloadItemFactory::CreateSavePageItem(\n    DownloadItemImpl::Delegate* delegate,\n    const FilePath& path,\n    const GURL& url,\n    bool is_otr,\n    content::DownloadId download_id,\n    const std::string& mime_type,\n    const net::BoundNetLog& bound_net_log) {\n  int local_id = download_id.local();\n  DCHECK(items_.find(local_id) == items_.end());\n  content::MockDownloadItem* result =\n      new StrictMock<content::MockDownloadItem>;\n  EXPECT_CALL(*result, GetId())\n      .WillRepeatedly(Return(local_id));\n  items_[local_id] = result;\n  return result;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":113131
  },
  {
    "code":"MagickExport XMLTreeInfo *NewXMLTree(const char *xml,ExceptionInfo *exception)\n{\n  char\n    **attribute,\n    **attributes,\n    *tag,\n    *utf8;\n  int\n    c,\n    terminal;\n  MagickBooleanType\n    status;\n  register char\n    *p;\n  register ssize_t\n    i;\n  size_t\n    ignore_depth,\n    length;\n  ssize_t\n    j,\n    l;\n  XMLTreeRoot\n    *root;\n  if ((xml == (const char *) NULL) || (strlen(xml) == 0))\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      return((XMLTreeInfo *) NULL);\n    }\n  root=(XMLTreeRoot *) NewXMLTreeTag((char *) NULL);\n  length=strlen(xml);\n  utf8=ConvertUTF16ToUTF8(xml,&length);\n  if (utf8 == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"UTF16 to UTF8 failed\");\n      return((XMLTreeInfo *) NULL);\n    }\n  terminal=utf8[length-1];\n  utf8[length-1]='\\0';\n  p=utf8;\n  while ((*p != '\\0') && (*p != '<'))\n    p++;\n  if (*p == '\\0')\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      utf8=DestroyString(utf8);\n      return((XMLTreeInfo *) NULL);\n    }\n  attribute=(char **) NULL;\n  l=0;\n  ignore_depth=0;\n  for (p++; ; p++)\n  {\n    attributes=(char **) sentinel;\n    tag=p;\n    c=(*p);\n    if ((isalpha((int) ((unsigned char) *p)) !=0) || (*p == '_') ||\n        (*p == ':') || (c < '\\0'))\n      {\n        if (root->node == (XMLTreeInfo *) NULL)\n          {\n            (void) ThrowMagickException(exception,GetMagickModule(),\n              OptionWarning,\"ParseError\",\"root tag missing\");\n            utf8=DestroyString(utf8);\n            return(&root->root);\n          }\n        p+=strcspn(p,XMLWhitespace \"\/>\");\n        while (isspace((int) ((unsigned char) *p)) != 0)\n          *p++='\\0';\n        if (ignore_depth == 0)\n          {\n            if ((*p != '\\0') && (*p != '\/') && (*p != '>'))\n              {\n                i=0;\n                while ((root->attributes[i] != (char **) NULL) &&\n                       (strcmp(root->attributes[i][0],tag) != 0))\n                  i++;\n                attribute=root->attributes[i];\n              }\n            for (l=0; (*p != '\\0') && (*p != '\/') && (*p != '>'); l+=2)\n            {\n              if (l == 0)\n                attributes=(char **) AcquireQuantumMemory(4,\n                  sizeof(*attributes));\n              else\n                attributes=(char **) ResizeQuantumMemory(attributes,\n                  (size_t) (l+4),sizeof(*attributes));\n              if (attributes == (char **) NULL)\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\"\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n              attributes[l+2]=(char *) NULL;\n              attributes[l+1]=(char *) NULL;\n              attributes[l]=p;\n              p+=strcspn(p,XMLWhitespace \"=\/>\");\n              if ((*p != '=') && (isspace((int) ((unsigned char) *p)) == 0))\n                attributes[l]=ConstantString(\"\");\n              else\n                {\n                  *p++='\\0';\n                  p+=strspn(p,XMLWhitespace \"=\");\n                  c=(*p);\n                  if ((c == '\"') || (c == '\\''))\n                    {\n                      p++;\n                      attributes[l+1]=p;\n                      while ((*p != '\\0') && (*p != c))\n                        p++;\n                      if (*p != '\\0')\n                        *p++='\\0';\n                      else\n                        {\n                          attributes[l]=ConstantString(\"\");\n                          attributes[l+1]=ConstantString(\"\");\n                          (void) DestroyXMLTreeAttributes(attributes);\n                          (void) ThrowMagickException(exception,\n                            GetMagickModule(),OptionWarning,\"ParseError\",\n                            \"missing %c\",c);\n                          utf8=DestroyString(utf8);\n                          return(&root->root);\n                        }\n                      j=1;\n                      while ((attribute != (char **) NULL) &&\n                             (attribute[j] != (char *) NULL) &&\n                             (strcmp(attribute[j],attributes[l]) != 0))\n                        j+=3;\n                      attributes[l+1]=ParseEntities(attributes[l+1],\n                        root->entities,(attribute != (char **) NULL) &&\n                        (attribute[j] != (char *) NULL) ? *attribute[j+2] :\n                        ' ');\n                    }\n                  attributes[l]=ConstantString(attributes[l]);\n                }\n              while (isspace((int) ((unsigned char) *p)) != 0)\n                p++;\n            }\n          }\n        else\n          {\n            while((*p != '\\0') && (*p != '\/') && (*p != '>'))\n              p++;\n          }\n        if (*p == '\/')\n          {\n            *p++='\\0';\n            if (((*p != '\\0') && (*p != '>')) ||\n                ((*p == '\\0') && (terminal != '>')))\n              {\n                if (l != 0)\n                  (void) DestroyXMLTreeAttributes(attributes);\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"missing >\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n            if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n              {\n                ParseOpenTag(root,tag,attributes);\n                (void) ParseCloseTag(root,tag,exception);\n              }\n          }\n        else\n          {\n            c=(*p);\n            if ((*p == '>') || ((*p == '\\0') && (terminal == '>')))\n              {\n                *p='\\0';\n                 if ((ignore_depth == 0) && (IsSkipTag(tag) == MagickFalse))\n                   ParseOpenTag(root,tag,attributes);\n                 else\n                  ignore_depth++;\n                 *p=c;\n               }\n             else\n              {\n                if (l != 0)\n                  (void) DestroyXMLTreeAttributes(attributes);\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"missing >\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n          }\n      }\n    else\n      if (*p == '\/')\n        {\n          tag=p+1;\n          p+=strcspn(tag,XMLWhitespace \">\")+1;\n          c=(*p);\n          if ((c == '\\0') && (terminal != '>'))\n            {\n              (void) ThrowMagickException(exception,GetMagickModule(),\n                OptionWarning,\"ParseError\",\"missing >\");\n              utf8=DestroyString(utf8);\n              return(&root->root);\n            }\n          *p='\\0';\n          if (ignore_depth == 0 && ParseCloseTag(root,tag,exception) !=\n              (XMLTreeInfo *) NULL)\n            {\n              utf8=DestroyString(utf8);\n              return(&root->root);\n            }\n          if (ignore_depth > 0)\n            ignore_depth--;\n          *p=c;\n          if (isspace((int) ((unsigned char) *p)) != 0)\n            p+=strspn(p,XMLWhitespace);\n        }\n      else\n        if (strncmp(p,\"!--\",3) == 0)\n          {\n            p=strstr(p+3,\"--\");\n            if ((p == (char *) NULL) || ((*(p+=2) != '>') && (*p != '\\0')) ||\n                ((*p == '\\0') && (terminal != '>')))\n              {\n                (void) ThrowMagickException(exception,GetMagickModule(),\n                  OptionWarning,\"ParseError\",\"unclosed <!--\");\n                utf8=DestroyString(utf8);\n                return(&root->root);\n              }\n          }\n        else\n          if (strncmp(p,\"![CDATA[\",8) == 0)\n            {\n              p=strstr(p,\"]]>\");\n              if (p != (char *) NULL)\n                {\n                  p+=2;\n                  if (ignore_depth == 0)\n                    ParseCharacterContent(root,tag+8,(size_t) (p-tag-10),'c');\n                }\n              else\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    OptionWarning,\"ParseError\",\"unclosed <![CDATA[\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n            }\n          else\n            if (strncmp(p,\"!DOCTYPE\",8) == 0)\n              {\n                for (l=0; (*p != '\\0') && (((l == 0) && (*p != '>')) ||\n                     ((l != 0) && ((*p != ']') ||\n                     (*(p+strspn(p+1,XMLWhitespace)+1) != '>'))));\n                  l=(ssize_t) ((*p == '[') ? 1 : l))\n                p+=strcspn(p+1,\"[]>\")+1;\n                if ((*p == '\\0') && (terminal != '>'))\n                  {\n                    (void) ThrowMagickException(exception,GetMagickModule(),\n                      OptionWarning,\"ParseError\",\"unclosed <!DOCTYPE\");\n                    utf8=DestroyString(utf8);\n                    return(&root->root);\n                  }\n                if (l != 0)\n                  tag=strchr(tag,'[')+1;\n                if (l != 0)\n                  {\n                    status=ParseInternalDoctype(root,tag,(size_t) (p-tag),\n                      exception);\n                    if (status == MagickFalse)\n                      {\n                        utf8=DestroyString(utf8);\n                        return(&root->root);\n                      }\n                    p++;\n                  }\n              }\n            else\n              if (*p == '?')\n                {\n                  do\n                  {\n                    p=strchr(p,'?');\n                    if (p == (char *) NULL)\n                      break;\n                    p++;\n                  } while ((*p != '\\0') && (*p != '>'));\n                  if ((p == (char *) NULL) || ((*p == '\\0') &&\n                      (terminal != '>')))\n                    {\n                      (void) ThrowMagickException(exception,GetMagickModule(),\n                        OptionWarning,\"ParseError\",\"unclosed <?\");\n                      utf8=DestroyString(utf8);\n                      return(&root->root);\n                    }\n                  ParseProcessingInstructions(root,tag+1,(size_t) (p-tag-2));\n                }\n              else\n                {\n                  (void) ThrowMagickException(exception,GetMagickModule(),\n                    OptionWarning,\"ParseError\",\"unexpected <\");\n                  utf8=DestroyString(utf8);\n                  return(&root->root);\n                }\n     if ((p == (char *) NULL) || (*p == '\\0'))\n       break;\n     *p++='\\0';\n     tag=p;\n     if ((*p != '\\0') && (*p != '<'))\n       {\n        while ((*p != '\\0') && (*p != '<'))\n          p++;\n        if (*p == '\\0')\n          break;\n        if (ignore_depth == 0)\n          ParseCharacterContent(root,tag,(size_t) (p-tag),'&');\n      }\n    else\n      if (*p == '\\0')\n        break;\n  }\n  utf8=DestroyString(utf8);\n  if (root->node == (XMLTreeInfo *) NULL)\n    return(&root->root);\n  if (root->node->tag == (char *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n        \"ParseError\",\"root tag missing\");\n      return(&root->root);\n    }\n  (void) ThrowMagickException(exception,GetMagickModule(),OptionWarning,\n    \"ParseError\",\"unclosed tag: `%s'\",root->node->tag);\n  return(&root->root);\n}\n",
    "vul":1,
    "flaw_line_no":[
      177
    ],
    "bigvul_id":181815
  },
  {
    "code":"GF_Err dmax_Write(GF_Box *s, GF_BitStream *bs)\n{\n  GF_Err e;\n  GF_DMAXBox *ptr = (GF_DMAXBox *)s;\n  if (ptr == NULL) return GF_BAD_PARAM;\n  e = gf_isom_box_write_header(s, bs);\n  if (e) return e;\n  gf_bs_write_u32(bs, ptr->maxDur);\n  return GF_OK;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":80059
  },
  {
    "code":"void ScreenRecorder::DoStopOnEncodeThread(const base::Closure& done_task) {\n  DCHECK_EQ(encode_loop_, MessageLoop::current());\n  encoder_stopped_ = true;\n  capture_loop_->PostTask(FROM_HERE, done_task);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":115712
  },
  {
    "code":"static int dccp_v6_send_response(const struct sock *sk, struct request_sock *req)\n{\n  struct inet_request_sock *ireq = inet_rsk(req);\n  struct ipv6_pinfo *np = inet6_sk(sk);\n  struct sk_buff *skb;\n  struct in6_addr *final_p, final;\n  struct flowi6 fl6;\n  int err = -1;\n  struct dst_entry *dst;\n  memset(&fl6, 0, sizeof(fl6));\n  fl6.flowi6_proto = IPPROTO_DCCP;\n  fl6.daddr = ireq->ir_v6_rmt_addr;\n  fl6.saddr = ireq->ir_v6_loc_addr;\n  fl6.flowlabel = 0;\n  fl6.flowi6_oif = ireq->ir_iif;\n  fl6.fl6_dport = ireq->ir_rmt_port;\n  fl6.fl6_sport = htons(ireq->ir_num);\n  security_req_classify_flow(req, flowi6_to_flowi(&fl6));\n  rcu_read_lock();\n  final_p = fl6_update_dst(&fl6, rcu_dereference(np->opt), &final);\n  rcu_read_unlock();\n  dst = ip6_dst_lookup_flow(sk, &fl6, final_p);\n  if (IS_ERR(dst)) {\n    err = PTR_ERR(dst);\n    dst = NULL;\n    goto done;\n  }\n  skb = dccp_make_response(sk, dst, req);\n  if (skb != NULL) {\n    struct dccp_hdr *dh = dccp_hdr(skb);\n    struct ipv6_txoptions *opt;\n    dh->dccph_checksum = dccp_v6_csum_finish(skb,\n               &ireq->ir_v6_loc_addr,\n               &ireq->ir_v6_rmt_addr);\n    fl6.daddr = ireq->ir_v6_rmt_addr;\n    rcu_read_lock();\n    opt = ireq->ipv6_opt;\n    if (!opt)\n      opt = rcu_dereference(np->opt);\n    err = ip6_xmit(sk, skb, &fl6, sk->sk_mark, opt, np->tclass);\n    rcu_read_unlock();\n    err = net_xmit_eval(err);\n  }\ndone:\n  dst_release(dst);\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":65143
  },
  {
    "code":"void WebPluginDelegatePepper::DestroyInstance() {\n  if (instance_ && (instance_->npp()->ndata != NULL)) {\n    instance_->CloseStreams();\n    window_.window = NULL;\n    instance_->NPP_SetWindow(&window_);\n    instance_->NPP_Destroy();\n    instance_->set_web_plugin(NULL);\n    instance_ = 0;\n  }\n  if (nested_delegate_) {\n#if defined(ENABLE_GPU)\n    if (command_buffer_) {\n      nested_delegate_->DestroyCommandBuffer(command_buffer_);\n      command_buffer_ = NULL;\n    }\n#endif\n    nested_delegate_->PluginDestroyed();\n    nested_delegate_ = NULL;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":98685
  },
  {
    "code":"void ewk_view_viewport_attributes_get(const Evas_Object* ewkView, int* width, int* height, float* initScale, float* maxScale, float* minScale, float* devicePixelRatio, Eina_Bool* userScalable)\n{\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv);\n    WebCore::ViewportAttributes attributes = _ewk_view_viewport_attributes_compute(priv);\n    if (width)\n        *width = attributes.layoutSize.width();\n    if (height)\n        *height = attributes.layoutSize.height();\n    if (initScale)\n        *initScale = attributes.initialScale;\n    if (maxScale)\n        *maxScale = attributes.maximumScale;\n    if (minScale)\n        *minScale = attributes.minimumScale;\n    if (devicePixelRatio)\n        *devicePixelRatio = attributes.devicePixelRatio;\n    if (userScalable)\n        *userScalable = static_cast<bool>(attributes.userScalable);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":107682
  },
  {
    "code":"void AudioFlinger::EffectHandle::setControl(bool hasControl, bool signal, bool enabled)\n{\n    ALOGV(\"setControl %p control %d\", this, hasControl);\n    mHasControl = hasControl;\n    mEnabled = enabled;\n if (signal && mEffectClient != 0) {\n        mEffectClient->controlStatusChanged(hasControl);\n }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":171020
  },
  {
    "code":"void GraphicsContext::strokePath(const Path& pathToStroke)\n{\n    if (paintingDisabled())\n        return;\n    SkPath path = *pathToStroke.platformPath();\n    if (!isPathSkiaSafe(getCTM(), path))\n        return;\n    SkPaint paint;\n    platformContext()->setupPaintForStroking(&paint, 0, 0);\n    platformContext()->canvas()->drawPath(path, paint);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":115640
  },
  {
    "code":"int ZEXPORT inflateSetDictionary(strm, dictionary, dictLength)\nz_streamp strm;\nconst Bytef *dictionary;\nuInt dictLength;\n{\n    struct inflate_state FAR *state;\n    unsigned long dictid;\n    int ret;\n    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;\n    state = (struct inflate_state FAR *)strm->state;\n    if (state->wrap != 0 && state->mode != DICT)\n        return Z_STREAM_ERROR;\n    if (state->mode == DICT) {\n        dictid = adler32(0L, Z_NULL, 0);\n        dictid = adler32(dictid, dictionary, dictLength);\n        if (dictid != state->check)\n            return Z_DATA_ERROR;\n    }\n    ret = updatewindow(strm, dictionary + dictLength, dictLength);\n    if (ret) {\n        state->mode = MEM;\n        return Z_MEM_ERROR;\n    }\n    state->havedict = 1;\n    Tracev((stderr, \"inflate:   dictionary set\\n\"));\n    return Z_OK;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":72500
  },
  {
    "code":"static MagickBooleanType RenderFreetype(Image *image,const DrawInfo *draw_info,\n  const char *magick_unused(encoding),const PointInfo *offset,\n  TypeMetric *metrics)\n{\n  (void) ThrowMagickException(&image->exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (Freetype)\",\n    draw_info->font != (char *) NULL ? draw_info->font : \"none\");\n  return(RenderPostscript(image,draw_info,offset,metrics));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":88875
  },
  {
    "code":"SPICE_GNUC_VISIBLE int spice_server_is_server_mouse(SpiceServer *s)\n{\n    spice_assert(reds == s);\n    return reds->mouse_mode == SPICE_MOUSE_MODE_SERVER;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":1963
  },
  {
    "code":"bool ExtensionPrefs::IsExtensionAllowedByPolicy(\n    const std::string& extension_id,\n    Extension::Location location) {\n  std::string string_value;\n  if (location == Extension::COMPONENT ||\n      location == Extension::EXTERNAL_POLICY_DOWNLOAD) {\n    return true;\n  }\n  const ListValue* blacklist =\n      prefs_->GetList(prefs::kExtensionInstallDenyList);\n  if (!blacklist || blacklist->empty())\n    return true;\n  const ListValue* whitelist =\n      prefs_->GetList(prefs::kExtensionInstallAllowList);\n  if (whitelist) {\n    for (ListValue::const_iterator it = whitelist->begin();\n         it != whitelist->end(); ++it) {\n      if (!(*it)->GetAsString(&string_value))\n        LOG(WARNING) << \"Failed to read whitelist string.\";\n      else if (string_value == extension_id)\n        return true;\n    }\n  }\n  if (blacklist) {\n    for (ListValue::const_iterator it = blacklist->begin();\n         it != blacklist->end(); ++it) {\n      if (!(*it)->GetAsString(&string_value)) {\n        LOG(WARNING) << \"Failed to read blacklist string.\";\n      } else {\n        if (string_value == \"*\")\n          return false;  \n        if (string_value == extension_id)\n          return false;\n      }\n    }\n  }\n  return true;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":102278
  },
  {
    "code":"GdkColor SelectedURLColor(GdkColor foreground, GdkColor background) {\n  color_utils::HSL fg_hsl;\n  color_utils::SkColorToHSL(gfx::GdkColorToSkColor(foreground), &fg_hsl);\n  color_utils::HSL bg_hsl;\n  color_utils::SkColorToHSL(gfx::GdkColorToSkColor(background), &bg_hsl);\n  color_utils::HSL hue_hsl;\n  color_utils::SkColorToHSL(gfx::GdkColorToSkColor(kURLTextColor), &hue_hsl);\n  double opposite_s = 1 - bg_hsl.s;\n  double s = std::max(0.2, std::min(0.8, opposite_s));\n  double opposite_l = fg_hsl.l;\n  double l = std::max(0.1, std::min(0.9, opposite_l));\n  color_utils::HSL output = { hue_hsl.h, s, l };\n  return gfx::SkColorToGdkColor(color_utils::HSLToSkColor(output, 255));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":98525
  },
  {
    "code":"static char *get_default_chdir(pool *p, xaset_t *conf) {\n  config_rec *c;\n  char *dir = NULL;\n  int ret;\n  c = find_config(conf, CONF_PARAM, \"DefaultChdir\", FALSE);\n  while (c) {\n    if (c->argc < 2) {\n      dir = c->argv[0];\n      break;\n    }\n    ret = pr_expr_eval_group_and(((char **) c->argv)+1);\n    if (ret) {\n      dir = c->argv[0];\n      break;\n    }\n    c = find_config_next(c, c->next, CONF_PARAM, \"DefaultChdir\", FALSE);\n  }\n  if (dir && *dir != '\/' && *dir != '~')\n    dir = pdircat(p, session.cwd, dir, NULL);\n  if (dir)\n    dir = path_subst_uservar(p, &dir);\n   return dir;\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":95409
  },
  {
    "code":"bool Document::hasPendingForcedStyleRecalc() const\n{\n    return m_styleRecalcTimer.isActive() && m_pendingStyleRecalcShouldForce;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":112476
  },
  {
    "code":"int kvm_arch_vcpu_ioctl_get_mpstate(struct kvm_vcpu *vcpu,\n            struct kvm_mp_state *mp_state)\n{\n  return -EINVAL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":28959
  },
  {
    "code":"static int nested_vmx_check_msr_bitmap_controls(struct kvm_vcpu *vcpu,\n            struct vmcs12 *vmcs12)\n{\n  if (!nested_cpu_has(vmcs12, CPU_BASED_USE_MSR_BITMAPS))\n    return 0;\n  if (!page_address_valid(vcpu, vmcs12->msr_bitmap))\n    return -EINVAL;\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":63000
  },
  {
    "code":"check_notify_script_secure(notify_script_t **script_p, magic_t magic)\n{\n  int flags;\n  notify_script_t *script = *script_p;\n  if (!script)\n    return 0;\n  flags = check_script_secure(script, magic);\n  if ((flags & (SC_INHIBIT | SC_NOTFOUND)) ||\n      !(flags & SC_EXECUTABLE))\n    free_notify_script(script_p);\n  return flags;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":76117
  },
  {
    "code":"    virtual void beginTest()\n    {\n        endTest();\n    }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":102760
  },
  {
    "code":"void RenderFrameImpl::OnDidUpdateFramePolicy(\n    const blink::FramePolicy& frame_policy) {\n  frame_->SetFrameOwnerPolicy(frame_policy.sandbox_flags,\n                              frame_policy.container_policy);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":160656
  },
  {
    "code":"void PrintPreviewDialogDelegate::GetWebUIMessageHandlers(\n    std::vector<WebUIMessageHandler*>* ) const {\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":137671
  },
  {
    "code":"bool RenderWidgetHostImpl::GetVisualProperties(\n    VisualProperties* visual_properties,\n    bool* needs_ack) {\n  *visual_properties = VisualProperties();\n  GetScreenInfo(&visual_properties->screen_info);\n  if (delegate_) {\n    visual_properties->is_fullscreen_granted =\n        delegate_->IsFullscreenForCurrentTab();\n    visual_properties->display_mode = delegate_->GetDisplayMode(this);\n    visual_properties->zoom_level = delegate_->GetPendingPageZoomLevel();\n  } else {\n    visual_properties->is_fullscreen_granted = false;\n    visual_properties->display_mode = blink::kWebDisplayModeBrowser;\n    visual_properties->zoom_level = 0;\n  }\n  visual_properties->auto_resize_enabled = auto_resize_enabled_;\n  visual_properties->min_size_for_auto_resize = min_size_for_auto_resize_;\n  visual_properties->max_size_for_auto_resize = max_size_for_auto_resize_;\n  if (view_) {\n    visual_properties->new_size = view_->GetRequestedRendererSize();\n    visual_properties->capture_sequence_number =\n        view_->GetCaptureSequenceNumber();\n    visual_properties->compositor_viewport_pixel_size =\n        view_->GetCompositorViewportPixelSize();\n    visual_properties->top_controls_height = view_->GetTopControlsHeight();\n    visual_properties->bottom_controls_height =\n        view_->GetBottomControlsHeight();\n    if (IsUseZoomForDSFEnabled()) {\n      float device_scale = visual_properties->screen_info.device_scale_factor;\n      visual_properties->top_controls_height *= device_scale;\n      visual_properties->bottom_controls_height *= device_scale;\n    }\n    visual_properties->browser_controls_shrink_blink_size =\n        view_->DoBrowserControlsShrinkBlinkSize();\n    visual_properties->visible_viewport_size = view_->GetVisibleViewportSize();\n    viz::LocalSurfaceId local_surface_id = view_->GetLocalSurfaceId();\n    if (local_surface_id.is_valid())\n      visual_properties->local_surface_id = local_surface_id;\n  }\n  if (screen_orientation_type_for_testing_) {\n    visual_properties->screen_info.orientation_type =\n        *screen_orientation_type_for_testing_;\n  }\n  if (screen_orientation_angle_for_testing_) {\n    visual_properties->screen_info.orientation_angle =\n        *screen_orientation_angle_for_testing_;\n  }\n  const bool size_changed =\n      !old_visual_properties_ ||\n      old_visual_properties_->auto_resize_enabled !=\n          visual_properties->auto_resize_enabled ||\n      (old_visual_properties_->auto_resize_enabled &&\n       (old_visual_properties_->min_size_for_auto_resize !=\n            visual_properties->min_size_for_auto_resize ||\n        old_visual_properties_->max_size_for_auto_resize !=\n            visual_properties->max_size_for_auto_resize)) ||\n      (!old_visual_properties_->auto_resize_enabled &&\n       (old_visual_properties_->new_size != visual_properties->new_size ||\n        (old_visual_properties_->compositor_viewport_pixel_size.IsEmpty() &&\n         !visual_properties->compositor_viewport_pixel_size.IsEmpty())));\n  viz::LocalSurfaceId old_parent_local_surface_id =\n      old_visual_properties_\n          ? old_visual_properties_->local_surface_id.value_or(\n                viz::LocalSurfaceId())\n          : viz::LocalSurfaceId();\n  viz::LocalSurfaceId new_parent_local_surface_id =\n      visual_properties->local_surface_id.value_or(viz::LocalSurfaceId());\n  const bool parent_local_surface_id_changed =\n      !old_visual_properties_ ||\n      old_parent_local_surface_id.parent_sequence_number() !=\n          new_parent_local_surface_id.parent_sequence_number() ||\n      old_parent_local_surface_id.embed_token() !=\n          new_parent_local_surface_id.embed_token();\n  const bool zoom_changed =\n      !old_visual_properties_ ||\n      old_visual_properties_->zoom_level != visual_properties->zoom_level;\n  bool dirty =\n      zoom_changed || size_changed || parent_local_surface_id_changed ||\n      old_visual_properties_->screen_info != visual_properties->screen_info ||\n      old_visual_properties_->compositor_viewport_pixel_size !=\n          visual_properties->compositor_viewport_pixel_size ||\n      old_visual_properties_->is_fullscreen_granted !=\n          visual_properties->is_fullscreen_granted ||\n      old_visual_properties_->display_mode != visual_properties->display_mode ||\n      old_visual_properties_->top_controls_height !=\n          visual_properties->top_controls_height ||\n      old_visual_properties_->browser_controls_shrink_blink_size !=\n          visual_properties->browser_controls_shrink_blink_size ||\n      old_visual_properties_->bottom_controls_height !=\n          visual_properties->bottom_controls_height ||\n      old_visual_properties_->visible_viewport_size !=\n          visual_properties->visible_viewport_size ||\n      old_visual_properties_->capture_sequence_number !=\n          visual_properties->capture_sequence_number;\n  *needs_ack = g_check_for_pending_visual_properties_ack &&\n               !visual_properties->auto_resize_enabled &&\n               !visual_properties->new_size.IsEmpty() &&\n               !visual_properties->compositor_viewport_pixel_size.IsEmpty() &&\n               visual_properties->local_surface_id && size_changed;\n  return dirty;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":158287
  },
  {
    "code":"bool WakeOnWifiEnabled() {\n  return !base::CommandLine::ForCurrentProcess()->HasSwitch(kDisableWakeOnWifi);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":134944
  },
  {
    "code":"  void WaitForMessageProcessing(WebContents* wc) {\n    bool result = false;\n    ASSERT_TRUE(content::ExecuteScriptAndExtractBool(\n        wc, \"window.domAutomationController.send(true);\", &result));\n    ASSERT_TRUE(result);\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":167558
  },
  {
    "code":"static int clie_3_5_startup(struct usb_serial *serial)\n{\n  struct device *dev = &serial->dev->dev;\n  int result;\n  u8 *data;\n  data = kmalloc(1, GFP_KERNEL);\n  if (!data)\n    return -ENOMEM;\n  result = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n          USB_REQ_GET_CONFIGURATION, USB_DIR_IN,\n          0, 0, data, 1, 3000);\n  if (result < 0) {\n    dev_err(dev, \"%s: get config number failed: %d\\n\",\n              __func__, result);\n    goto out;\n  }\n  if (result != 1) {\n    dev_err(dev, \"%s: get config number bad return length: %d\\n\",\n              __func__, result);\n    result = -EIO;\n    goto out;\n  }\n  result = usb_control_msg(serial->dev, usb_rcvctrlpipe(serial->dev, 0),\n          USB_REQ_GET_INTERFACE,\n          USB_DIR_IN | USB_RECIP_INTERFACE,\n          0, 0, data, 1, 3000);\n  if (result < 0) {\n    dev_err(dev, \"%s: get interface number failed: %d\\n\",\n              __func__, result);\n    goto out;\n  }\n  if (result != 1) {\n    dev_err(dev,\n      \"%s: get interface number bad return length: %d\\n\",\n              __func__, result);\n    result = -EIO;\n    goto out;\n  }\n  result = 0;\nout:\n  kfree(data);\n  return result;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":54562
  },
  {
    "code":"ZEND_API void zend_objects_store_destroy(zend_objects_store *objects)\n{\n  efree(objects->object_buckets);\n  objects->object_buckets = NULL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":49979
  },
  {
    "code":"void OmniboxViewViews::AppendDropFormats(\n    int* formats,\n    std::set<ui::ClipboardFormatType>* format_types) {\n  *formats = *formats | ui::OSExchangeData::URL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":155101
  },
  {
    "code":"void addReplyLongLong(client *c, long long ll) {\n    if (ll == 0)\n        addReply(c,shared.czero);\n    else if (ll == 1)\n        addReply(c,shared.cone);\n    else\n        addReplyLongLongWithPrefix(c,ll,':');\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":69942
  },
  {
    "code":"static void ip6_copy_metadata(struct sk_buff *to, struct sk_buff *from)\n{\n  to->pkt_type = from->pkt_type;\n  to->priority = from->priority;\n  to->protocol = from->protocol;\n  skb_dst_drop(to);\n  skb_dst_set(to, dst_clone(skb_dst(from)));\n  to->dev = from->dev;\n  to->mark = from->mark;\n#ifdef CONFIG_NET_SCHED\n  to->tc_index = from->tc_index;\n#endif\n  nf_copy(to, from);\n  skb_copy_secmark(to, from);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":64626
  },
  {
    "code":"scheme_default_port (enum url_scheme scheme)\n{\n  return supported_schemes[scheme].default_port;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":8694
  },
  {
    "code":"void AudioNode::setChannelInterpretation(const String& interpretation,\n                                         ExceptionState& exception_state) {\n  Handler().SetChannelInterpretation(interpretation, exception_state);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":161665
  },
  {
    "code":"eXosip_get_version (void)\n{\n  return EXOSIP_VERSION;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":17287
  },
  {
    "code":"int Parcel::readParcelFileDescriptor(int& outCommChannel) const {\n int fd;\n    outCommChannel = -1;\n if (readInt32() == 0) {\n        fd = -1;\n } else {\n        fd = readFileDescriptor();\n if (fd >= 0 && readInt32() != 0) {\n            outCommChannel = readFileDescriptor();\n }\n }\n return fd;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":170480
  },
  {
    "code":"UsbInterruptTransferFunction::UsbInterruptTransferFunction() {\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":132499
  },
  {
    "code":"size_t GLES2Util::GetGLTypeSizeForGLPathNameType(uint32_t type) {\n  switch (type) {\n    case GL_BYTE:\n      return sizeof(GLbyte);  \n    case GL_UNSIGNED_BYTE:\n      return sizeof(GLubyte);  \n    case GL_SHORT:\n      return sizeof(GLshort);  \n    case GL_UNSIGNED_SHORT:\n      return sizeof(GLushort);  \n    case GL_INT:\n      return sizeof(GLint);  \n    case GL_UNSIGNED_INT:\n      return sizeof(GLuint);  \n    default:\n      return 0;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":166391
  },
  {
    "code":"releaseStringBuffer(int idx) {\n  if (idx >= 0 && idx < stringBufferPool->size) {\n    int inUse = stringBufferPool->inUse[idx];\n    if (inUse && stringBufferPool->free)\n      stringBufferPool->free(stringBufferPool->buffers[idx]);\n    stringBufferPool->inUse[idx] = 0;\n    return inUse;\n  }\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":76769
  },
  {
    "code":"cJSON *cJSON_GetObjectItem( cJSON *object, const char *string )\n{\n  cJSON *c = object->child;\n  while ( c && cJSON_strcasecmp( c->string, string ) )\n    c = c->next;\n  return c;\n}\n",
    "vul":1,
    "flaw_line_no":[
      2,
      3,
      4,
      5,
      6,
      7
    ],
    "bigvul_id":180461
  },
  {
    "code":"static struct page *next_active_pageblock(struct page *page)\n{\n  BUG_ON(page_to_pfn(page) & (pageblock_nr_pages - 1));\n  if (pageblock_free(page)) {\n    int order;\n    order = page_order(page);\n    if ((order < MAX_ORDER) && (order >= pageblock_order))\n      return page + (1 << order);\n  }\n  return page + pageblock_nr_pages;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":18506
  },
  {
    "code":"void gf_sm_reset(GF_SceneManager *ctx)\n{\n  GF_StreamContext *sc;\n  u32 i=0;\n  while ( (sc = gf_list_enum(ctx->streams, &i)) ) {\n    gf_sm_reset_stream(sc);\n  }\n  if (ctx->root_od) gf_odf_desc_del((GF_Descriptor *) ctx->root_od);\n  ctx->root_od = NULL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":92878
  },
  {
    "code":"R_API void U(copy_type_info_to_stack_frame_list_up_to_idx)(RList * type_list, RList * sf_list, ut64 idx) {\n  RListIter *iter, *iter_tmp;\n  RBinJavaVerificationObj *ver_obj, *new_ver_obj;\n  ut32 pos = 0;\n  if (type_list == NULL) {\n    return;\n  }\n  if (sf_list == NULL) {\n    return;\n  }\n  r_list_foreach_safe (type_list, iter, iter_tmp, ver_obj) {\n    new_ver_obj = (RBinJavaVerificationObj *) malloc (sizeof (RBinJavaVerificationObj));\n    if (new_ver_obj && ver_obj) {\n      memcpy (new_ver_obj, ver_obj, sizeof (RBinJavaVerificationObj));\n      if (!r_list_append (sf_list, (void *) new_ver_obj)) {\n        R_FREE (new_ver_obj);\n      }\n    } else {\n      R_FREE (new_ver_obj);\n    }\n    pos++;\n    if (pos == idx) {\n      break;\n    }\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":79661
  },
  {
    "code":"    TraitsInFamilyProcData(const AtomicString& familyName)\n        : m_familyName(familyName)\n    {\n    }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":108571
  },
  {
    "code":"static void utf8cvt_emitoctet(struct iw_utf8cvt_struct *s, unsigned char c)\n{\n  if(s->dp > s->dstlen-2) return;\n  s->dst[s->dp] = (char)c;\n  s->dp++;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":66308
  },
  {
    "code":"void TabStripModelObserver::TabBlockedStateChanged(WebContents* contents,\n                                                   int index) {\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":126664
  },
  {
    "code":" BpHDCPObserver(const sp<IBinder> &impl)\n : BpInterface<IHDCPObserver>(impl) {\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":170768
  },
  {
    "code":"asmlinkage long sys_waitid(int which, pid_t upid,\n         struct siginfo __user *infop, int options,\n         struct rusage __user *ru)\n{\n  struct pid *pid = NULL;\n  enum pid_type type;\n  long ret;\n  if (options & ~(WNOHANG|WNOWAIT|WEXITED|WSTOPPED|WCONTINUED))\n    return -EINVAL;\n  if (!(options & (WEXITED|WSTOPPED|WCONTINUED)))\n    return -EINVAL;\n  switch (which) {\n  case P_ALL:\n    type = PIDTYPE_MAX;\n    break;\n  case P_PID:\n    type = PIDTYPE_PID;\n    if (upid <= 0)\n      return -EINVAL;\n    break;\n  case P_PGID:\n    type = PIDTYPE_PGID;\n    if (upid <= 0)\n      return -EINVAL;\n    break;\n  default:\n    return -EINVAL;\n  }\n  if (type < PIDTYPE_MAX)\n    pid = find_get_pid(upid);\n  ret = do_wait(type, pid, options, infop, NULL, ru);\n  put_pid(pid);\n  asmlinkage_protect(5, ret, which, upid, infop, options, ru);\n  return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":22132
  },
  {
    "code":"zexecuteonly(i_ctx_t *i_ctx_p)\n{\n    os_ptr op = osp;\n    check_op(1);\n    if (r_has_type(op, t_dictionary))\n        return_error(gs_error_typecheck);\n    return access_check(i_ctx_p, a_execute, true);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":3203
  },
  {
    "code":"void GDataFileSystem::UpdateFileByEntryOnUIThread(\n    const FileOperationCallback& callback,\n    GDataEntry* entry) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  if (!entry || !entry->AsGDataFile()) {\n    base::MessageLoopProxy::current()->PostTask(\n        FROM_HERE,\n        base::Bind(callback,\n                   GDATA_FILE_ERROR_NOT_FOUND));\n    return;\n  }\n  GDataFile* file = entry->AsGDataFile();\n  cache_->GetFileOnUIThread(\n      file->resource_id(),\n      file->file_md5(),\n      base::Bind(&GDataFileSystem::OnGetFileCompleteForUpdateFile,\n                 ui_weak_ptr_,\n                 callback));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":125477
  },
  {
    "code":"void AsyncFileSystemChromium::remove(const KURL& path, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)\n{\n    m_webFileSystem->remove(path, new WebKit::WebFileSystemCallbacksImpl(callbacks));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":109419
  },
  {
    "code":"void RTCPeerConnectionHandler::CreateAnswer(\n    const blink::WebRTCSessionDescriptionRequest& request,\n    const blink::WebMediaConstraints& options) {\n  DCHECK(task_runner_->RunsTasksInCurrentSequence());\n  TRACE_EVENT0(\"webrtc\", \"RTCPeerConnectionHandler::createAnswer\");\n  scoped_refptr<CreateSessionDescriptionRequest> description_request(\n      new rtc::RefCountedObject<CreateSessionDescriptionRequest>(\n          task_runner_, request, weak_factory_.GetWeakPtr(),\n          peer_connection_tracker_,\n          PeerConnectionTracker::ACTION_CREATE_ANSWER));\n  webrtc::PeerConnectionInterface::RTCOfferAnswerOptions webrtc_options;\n  ConvertConstraintsToWebrtcOfferOptions(options, &webrtc_options);\n  native_peer_connection_->CreateAnswer(description_request.get(),\n                                        webrtc_options);\n  if (peer_connection_tracker_)\n    peer_connection_tracker_->TrackCreateAnswer(this, options);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":165957
  },
  {
    "code":"static size_t WritePSDChannel(const PSDInfo *psd_info,\n  const ImageInfo *image_info,Image *image,Image *next_image,\n  const QuantumType quantum_type, unsigned char *compact_pixels,\n  MagickOffsetType size_offset,const MagickBooleanType separate,\n  ExceptionInfo *exception)\n{\n  int\n    y;\n  MagickBooleanType\n    monochrome;\n  QuantumInfo\n    *quantum_info;\n  register const Quantum\n    *p;\n  register ssize_t\n    i;\n  size_t\n    count,\n    length;\n  unsigned char\n    *pixels;\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n#define CHUNK 16384\n  int\n    flush,\n    level;\n  unsigned char\n    *compressed_pixels;\n  z_stream\n    stream;\n  compressed_pixels=(unsigned char *) NULL;\n  flush=Z_NO_FLUSH;\n#endif\n  count=0;\n  if (separate != MagickFalse)\n    {\n      size_offset=TellBlob(image)+2;\n      count+=WriteCompressionStart(psd_info,image,next_image,1);\n    }\n  if (next_image->depth > 8)\n    next_image->depth=16;\n  monochrome=IsImageMonochrome(image) && (image->depth == 1) ?\n    MagickTrue : MagickFalse;\n  quantum_info=AcquireQuantumInfo(image_info,next_image);\n  if (quantum_info == (QuantumInfo *) NULL)\n    return(0);\n  pixels=(unsigned char *) GetQuantumPixels(quantum_info);\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (next_image->compression == ZipCompression)\n    {\n      compressed_pixels=(unsigned char *) AcquireQuantumMemory(CHUNK,\n        sizeof(*compressed_pixels));\n      if (compressed_pixels == (unsigned char *) NULL)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n      ResetMagickMemory(&stream,0,sizeof(stream));\n      stream.data_type=Z_BINARY;\n      level=Z_DEFAULT_COMPRESSION;\n      if ((image_info->quality > 0 && image_info->quality < 10))\n        level=(int) image_info->quality;\n      if (deflateInit(&stream,level) != Z_OK)\n        {\n          quantum_info=DestroyQuantumInfo(quantum_info);\n          return(0);\n        }\n    }\n#endif\n  for (y=0; y < (ssize_t) next_image->rows; y++)\n  {\n    p=GetVirtualPixels(next_image,0,y,next_image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    length=ExportQuantumPixels(next_image,(CacheView *) NULL,quantum_info,\n      quantum_type,pixels,exception);\n    if (monochrome != MagickFalse)\n      for (i=0; i < (ssize_t) length; i++)\n        pixels[i]=(~pixels[i]);\n    if (next_image->compression == RLECompression)\n      {\n        length=PSDPackbitsEncodeImage(image,length,pixels,compact_pixels,\n          exception);\n        count+=WriteBlob(image,length,compact_pixels);\n        size_offset+=WritePSDOffset(psd_info,image,length,size_offset);\n      }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n    else if (next_image->compression == ZipCompression)\n      {\n        stream.avail_in=(uInt) length;\n        stream.next_in=(Bytef *) pixels;\n        if (y == (ssize_t) next_image->rows-1)\n          flush=Z_FINISH;\n        do {\n            stream.avail_out=(uInt) CHUNK;\n            stream.next_out=(Bytef *) compressed_pixels;\n            if (deflate(&stream,flush) == Z_STREAM_ERROR)\n              break;\n            length=(size_t) CHUNK-stream.avail_out;\n            if (length > 0)\n              count+=WriteBlob(image,length,compressed_pixels);\n        } while (stream.avail_out == 0);\n      }\n#endif\n    else\n      count+=WriteBlob(image,length,pixels);\n  }\n#ifdef MAGICKCORE_ZLIB_DELEGATE\n  if (next_image->compression == ZipCompression)\n    {\n      (void) deflateEnd(&stream);\n      compressed_pixels=(unsigned char *) RelinquishMagickMemory(\n        compressed_pixels);\n    }\n#endif\n  quantum_info=DestroyQuantumInfo(quantum_info);\n  return(count);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":69060
  },
  {
    "code":"void DownloadItemImpl::SetDangerType(content::DownloadDangerType danger_type) {\n  danger_type_ = danger_type;\n  SafetyState updated_value = IsDangerous() ?\n      DownloadItem::DANGEROUS : DownloadItem::SAFE;\n  if (updated_value != safety_state_) {\n    safety_state_ = updated_value;\n    bound_net_log_.AddEvent(\n        net::NetLog::TYPE_DOWNLOAD_ITEM_SAFETY_STATE_UPDATED,\n        base::Bind(&download_net_logs::ItemCheckedCallback,\n                   GetDangerType(), GetSafetyState()));\n    UpdateObservers();\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":113095
  },
  {
    "code":"ftp_get(ftpbuf_t *ftp, php_stream *outstream, const char *path, ftptype_t type, long resumepos TSRMLS_DC)\n{\n  databuf_t    *data = NULL;\n  int      lastch;\n  size_t      rcvd;\n  char      arg[11];\n  if (ftp == NULL) {\n    return 0;\n  }\n  if (!ftp_type(ftp, type)) {\n    goto bail;\n  }\n  if ((data = ftp_getdata(ftp TSRMLS_CC)) == NULL) {\n    goto bail;\n  }\n  ftp->data = data;\n  if (resumepos > 0) {\n    snprintf(arg, sizeof(arg), \"%ld\", resumepos);\n    if (!ftp_putcmd(ftp, \"REST\", arg)) {\n      goto bail;\n    }\n    if (!ftp_getresp(ftp) || (ftp->resp != 350)) {\n      goto bail;\n    }\n  }\n  if (!ftp_putcmd(ftp, \"RETR\", path)) {\n    goto bail;\n  }\n  if (!ftp_getresp(ftp) || (ftp->resp != 150 && ftp->resp != 125)) {\n    goto bail;\n  }\n  if ((data = data_accept(data, ftp TSRMLS_CC)) == NULL) {\n    goto bail;\n  }\n  lastch = 0;\n  while ((rcvd = my_recv(ftp, data->fd, data->buf, FTP_BUFSIZE))) {\n    if (rcvd == -1) {\n      goto bail;\n    }\n    if (type == FTPTYPE_ASCII) {\n#ifndef PHP_WIN32\n      char *s;\n#endif\n      char *ptr = data->buf;\n      char *e = ptr + rcvd;\n#ifdef PHP_WIN32\n      php_stream_write(outstream, ptr, (e - ptr));\n      ptr = e;\n#else\n      while (e > ptr && (s = memchr(ptr, '\\r', (e - ptr)))) {\n        php_stream_write(outstream, ptr, (s - ptr));\n        if (*(s + 1) == '\\n') {\n          s++;\n          php_stream_putc(outstream, '\\n');\n        }\n        ptr = s + 1;\n      }\n#endif\n      if (ptr < e) {\n        php_stream_write(outstream, ptr, (e - ptr));\n      }\n    } else if (rcvd != php_stream_write(outstream, data->buf, rcvd)) {\n      goto bail;\n    }\n  }\n  ftp->data = data = data_close(ftp, data);\n  if (!ftp_getresp(ftp) || (ftp->resp != 226 && ftp->resp != 250)) {\n    goto bail;\n  }\n  return 1;\nbail:\n  ftp->data = data_close(ftp, data);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":14792
  },
  {
    "code":"static struct nfs4_state *nfs4_try_open_cached(struct nfs4_opendata *opendata)\n{\n  struct nfs4_state *state = opendata->state;\n  struct nfs_inode *nfsi = NFS_I(state->inode);\n  struct nfs_delegation *delegation;\n  int open_mode = opendata->o_arg.open_flags & (O_EXCL|O_TRUNC);\n  fmode_t fmode = opendata->o_arg.fmode;\n  nfs4_stateid stateid;\n  int ret = -EAGAIN;\n  for (;;) {\n    if (can_open_cached(state, fmode, open_mode)) {\n      spin_lock(&state->owner->so_lock);\n      if (can_open_cached(state, fmode, open_mode)) {\n        update_open_stateflags(state, fmode);\n        spin_unlock(&state->owner->so_lock);\n        goto out_return_state;\n      }\n      spin_unlock(&state->owner->so_lock);\n    }\n    rcu_read_lock();\n    delegation = rcu_dereference(nfsi->delegation);\n    if (!can_open_delegated(delegation, fmode)) {\n      rcu_read_unlock();\n      break;\n    }\n    nfs4_stateid_copy(&stateid, &delegation->stateid);\n    rcu_read_unlock();\n    ret = nfs_may_open(state->inode, state->owner->so_cred, open_mode);\n    if (ret != 0)\n      goto out;\n    ret = -EAGAIN;\n    if (update_open_stateid(state, NULL, &stateid, fmode))\n      goto out_return_state;\n  }\nout:\n  return ERR_PTR(ret);\nout_return_state:\n  atomic_inc(&state->count);\n  return state;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":20033
  },
  {
    "code":" uint32_t parserFlags() const {\n return mParser->mFlags;\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":173676
  },
  {
    "code":"OneClickSigninHelper::~OneClickSigninHelper() {\n  content::WebContents* contents = web_contents();\n  if (contents) {\n    Profile* profile =\n        Profile::FromBrowserContext(contents->GetBrowserContext());\n    ProfileSyncService* sync_service =\n        ProfileSyncServiceFactory::GetForProfile(profile);\n    if (sync_service && sync_service->HasObserver(this))\n      sync_service->RemoveObserver(this);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":120859
  },
  {
    "code":"void RenderView::PluginCrashed(const FilePath& plugin_path) {\n  Send(new ViewHostMsg_CrashedPlugin(routing_id_, plugin_path));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":98017
  },
  {
    "code":"static int __init cryptd_init(void)\n{\n  int err;\n  err = cryptd_init_queue(&queue, CRYPTD_MAX_CPU_QLEN);\n  if (err)\n    return err;\n  err = crypto_register_template(&cryptd_tmpl);\n  if (err)\n    cryptd_fini_queue(&queue);\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":45675
  },
  {
    "code":"static unsigned long mem_cgroup_nr_lru_pages(struct mem_cgroup *memcg,\n      unsigned int lru_mask)\n{\n  int nid;\n  u64 total = 0;\n  for_each_node_state(nid, N_HIGH_MEMORY)\n    total += mem_cgroup_node_nr_lru_pages(memcg, nid, lru_mask);\n  return total;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":21096
  },
  {
    "code":"bool HTMLFormControlElement::supportsAutofocus() const\n{\n    return false;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":130372
  },
  {
    "code":"bool Browser::PreHandleKeyboardEvent(content::WebContents* source,\n                                     const NativeWebKeyboardEvent& event,\n                                     bool* is_keyboard_shortcut) {\n  if (event.windowsKeyCode == 27 &&\n      fullscreen_controller_->HandleUserPressedEscape()) {\n    return true;\n  }\n  return window()->PreHandleKeyboardEvent(event, is_keyboard_shortcut);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":126219
  },
  {
    "code":"void OfflinePageModelImpl::DeleteOrphanedArchives(\n    const std::set<base::FilePath>& archive_paths) {\n  std::set<base::FilePath> orphaned_archive_set(archive_paths);\n  for (const auto& id_page_pair : offline_pages_)\n    orphaned_archive_set.erase(id_page_pair.second.file_path);\n  if (orphaned_archive_set.empty())\n    return;\n  std::vector<base::FilePath> orphaned_archives(orphaned_archive_set.begin(),\n                                                orphaned_archive_set.end());\n  archive_manager_->DeleteMultipleArchives(\n      orphaned_archives,\n      base::Bind(&OfflinePageModelImpl::OnDeleteOrphanedArchivesDone,\n                 weak_ptr_factory_.GetWeakPtr(), orphaned_archives));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":169039
  },
  {
    "code":"int modbus_write_bits(modbus_t *ctx, int addr, int nb, const uint8_t *src)\n{\n    int rc;\n    int i;\n    int byte_count;\n    int req_length;\n    int bit_check = 0;\n    int pos = 0;\n    uint8_t req[MAX_MESSAGE_LENGTH];\n    if (ctx == NULL) {\n        errno = EINVAL;\n        return -1;\n    }\n    if (nb > MODBUS_MAX_WRITE_BITS) {\n        if (ctx->debug) {\n            fprintf(stderr, \"ERROR Writing too many bits (%d > %d)\\n\",\n                    nb, MODBUS_MAX_WRITE_BITS);\n        }\n        errno = EMBMDATA;\n        return -1;\n    }\n    req_length = ctx->backend->build_request_basis(ctx,\n                                                   MODBUS_FC_WRITE_MULTIPLE_COILS,\n                                                   addr, nb, req);\n    byte_count = (nb \/ 8) + ((nb % 8) ? 1 : 0);\n    req[req_length++] = byte_count;\n    for (i = 0; i < byte_count; i++) {\n        int bit;\n        bit = 0x01;\n        req[req_length] = 0;\n        while ((bit & 0xFF) && (bit_check++ < nb)) {\n            if (src[pos++])\n                req[req_length] |= bit;\n            else\n                req[req_length] &=~ bit;\n            bit = bit << 1;\n        }\n        req_length++;\n    }\n    rc = send_msg(ctx, req, req_length);\n    if (rc > 0) {\n        uint8_t rsp[MAX_MESSAGE_LENGTH];\n        rc = _modbus_receive_msg(ctx, rsp, MSG_CONFIRMATION);\n        if (rc == -1)\n            return -1;\n        rc = check_confirmation(ctx, req, rsp, rc);\n    }\n    return rc;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":88757
  },
  {
    "code":"void ap_lua_load_request_lmodule(lua_State *L, apr_pool_t *p)\n{\n    apr_hash_t *dispatch = apr_hash_make(p);\n    apr_hash_set(dispatch, \"puts\", APR_HASH_KEY_STRING,\n                 makefun(&req_puts, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"write\", APR_HASH_KEY_STRING,\n                 makefun(&req_write, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"document_root\", APR_HASH_KEY_STRING,\n                 makefun(&req_document_root, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"context_prefix\", APR_HASH_KEY_STRING,\n                 makefun(&req_context_prefix, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"context_document_root\", APR_HASH_KEY_STRING,\n                 makefun(&req_context_document_root, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"parseargs\", APR_HASH_KEY_STRING,\n                 makefun(&req_parseargs, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"parsebody\", APR_HASH_KEY_STRING,\n                 makefun(&req_parsebody, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"debug\", APR_HASH_KEY_STRING,\n                 makefun(&req_debug, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"info\", APR_HASH_KEY_STRING,\n                 makefun(&req_info, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"notice\", APR_HASH_KEY_STRING,\n                 makefun(&req_notice, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"warn\", APR_HASH_KEY_STRING,\n                 makefun(&req_warn, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"err\", APR_HASH_KEY_STRING,\n                 makefun(&req_err, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"crit\", APR_HASH_KEY_STRING,\n                 makefun(&req_crit, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"alert\", APR_HASH_KEY_STRING,\n                 makefun(&req_alert, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"emerg\", APR_HASH_KEY_STRING,\n                 makefun(&req_emerg, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"trace1\", APR_HASH_KEY_STRING,\n                 makefun(&req_trace1, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"trace2\", APR_HASH_KEY_STRING,\n                 makefun(&req_trace2, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"trace3\", APR_HASH_KEY_STRING,\n                 makefun(&req_trace3, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"trace4\", APR_HASH_KEY_STRING,\n                 makefun(&req_trace4, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"trace5\", APR_HASH_KEY_STRING,\n                 makefun(&req_trace5, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"trace6\", APR_HASH_KEY_STRING,\n                 makefun(&req_trace6, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"trace7\", APR_HASH_KEY_STRING,\n                 makefun(&req_trace7, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"trace8\", APR_HASH_KEY_STRING,\n                 makefun(&req_trace8, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"add_output_filter\", APR_HASH_KEY_STRING,\n                 makefun(&req_add_output_filter, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"construct_url\", APR_HASH_KEY_STRING,\n                 makefun(&req_construct_url, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"escape_html\", APR_HASH_KEY_STRING,\n                 makefun(&req_escape_html, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"ssl_var_lookup\", APR_HASH_KEY_STRING,\n                 makefun(&req_ssl_var_lookup, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"is_https\", APR_HASH_KEY_STRING,\n                 makefun(&req_ssl_is_https_field, APL_REQ_FUNTYPE_BOOLEAN, p));\n    apr_hash_set(dispatch, \"assbackwards\", APR_HASH_KEY_STRING,\n                 makefun(&req_assbackwards_field, APL_REQ_FUNTYPE_BOOLEAN, p));\n    apr_hash_set(dispatch, \"status\", APR_HASH_KEY_STRING,\n                 makefun(&req_status_field, APL_REQ_FUNTYPE_INT, p));\n    apr_hash_set(dispatch, \"protocol\", APR_HASH_KEY_STRING,\n                 makefun(&req_protocol_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"range\", APR_HASH_KEY_STRING,\n                 makefun(&req_range_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"content_type\", APR_HASH_KEY_STRING,\n                 makefun(&req_content_type_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"content_encoding\", APR_HASH_KEY_STRING,\n                 makefun(&req_content_encoding_field, APL_REQ_FUNTYPE_STRING,\n                         p));\n    apr_hash_set(dispatch, \"ap_auth_type\", APR_HASH_KEY_STRING,\n                 makefun(&req_ap_auth_type_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"unparsed_uri\", APR_HASH_KEY_STRING,\n                 makefun(&req_unparsed_uri_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"user\", APR_HASH_KEY_STRING,\n                 makefun(&req_user_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"filename\", APR_HASH_KEY_STRING,\n                 makefun(&req_filename_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"canonical_filename\", APR_HASH_KEY_STRING,\n                 makefun(&req_canonical_filename_field,\n                         APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"path_info\", APR_HASH_KEY_STRING,\n                 makefun(&req_path_info_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"args\", APR_HASH_KEY_STRING,\n                 makefun(&req_args_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"handler\", APR_HASH_KEY_STRING,\n                 makefun(&req_handler_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"hostname\", APR_HASH_KEY_STRING,\n                 makefun(&req_hostname_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"uri\", APR_HASH_KEY_STRING,\n                 makefun(&req_uri_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"the_request\", APR_HASH_KEY_STRING,\n                 makefun(&req_the_request_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"log_id\", APR_HASH_KEY_STRING,\n                 makefun(&req_log_id_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"useragent_ip\", APR_HASH_KEY_STRING,\n                 makefun(&req_useragent_ip_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"method\", APR_HASH_KEY_STRING,\n                 makefun(&req_method_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"proxyreq\", APR_HASH_KEY_STRING,\n                 makefun(&req_proxyreq_field, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"headers_in\", APR_HASH_KEY_STRING,\n                 makefun(&req_headers_in, APL_REQ_FUNTYPE_TABLE, p));\n    apr_hash_set(dispatch, \"headers_out\", APR_HASH_KEY_STRING,\n                 makefun(&req_headers_out, APL_REQ_FUNTYPE_TABLE, p));\n    apr_hash_set(dispatch, \"err_headers_out\", APR_HASH_KEY_STRING,\n                 makefun(&req_err_headers_out, APL_REQ_FUNTYPE_TABLE, p));\n    apr_hash_set(dispatch, \"notes\", APR_HASH_KEY_STRING,\n                 makefun(&req_notes, APL_REQ_FUNTYPE_TABLE, p));\n    apr_hash_set(dispatch, \"subprocess_env\", APR_HASH_KEY_STRING,\n                 makefun(&req_subprocess_env, APL_REQ_FUNTYPE_TABLE, p));\n    apr_hash_set(dispatch, \"flush\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_rflush, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"port\", APR_HASH_KEY_STRING,\n                 makefun(&req_ap_get_server_port, APL_REQ_FUNTYPE_INT, p));\n    apr_hash_set(dispatch, \"banner\", APR_HASH_KEY_STRING,\n                 makefun(&ap_get_server_banner, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"options\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_options, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"allowoverrides\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_allowoverrides, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"started\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_started, APL_REQ_FUNTYPE_INT, p));\n    apr_hash_set(dispatch, \"basic_auth_pw\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_basic_auth_pw, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"limit_req_body\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_limit_req_body, APL_REQ_FUNTYPE_INT, p));\n    apr_hash_set(dispatch, \"server_built\", APR_HASH_KEY_STRING,\n                 makefun(&ap_get_server_built, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"is_initial_req\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_is_initial_req, APL_REQ_FUNTYPE_BOOLEAN, p));\n    apr_hash_set(dispatch, \"remaining\", APR_HASH_KEY_STRING,\n                 makefun(&req_remaining_field, APL_REQ_FUNTYPE_INT, p));\n    apr_hash_set(dispatch, \"some_auth_required\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_some_auth_required, APL_REQ_FUNTYPE_BOOLEAN, p));\n    apr_hash_set(dispatch, \"server_name\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_get_server_name, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"auth_name\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_auth_name, APL_REQ_FUNTYPE_STRING, p));\n    apr_hash_set(dispatch, \"sendfile\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_sendfile, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"dbacquire\", APR_HASH_KEY_STRING,\n                 makefun(&lua_db_acquire, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"stat\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_stat, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"get_direntries\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_getdir, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"regex\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_regex, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"usleep\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_usleep, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"base64_encode\", APR_HASH_KEY_STRING,\n                 makefun(&lua_apr_b64encode, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"base64_decode\", APR_HASH_KEY_STRING,\n                 makefun(&lua_apr_b64decode, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"md5\", APR_HASH_KEY_STRING,\n                 makefun(&lua_apr_md5, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"sha1\", APR_HASH_KEY_STRING,\n                 makefun(&lua_apr_sha1, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"htpassword\", APR_HASH_KEY_STRING,\n                 makefun(&lua_apr_htpassword, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"touch\", APR_HASH_KEY_STRING,\n                 makefun(&lua_apr_touch, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"mkdir\", APR_HASH_KEY_STRING,\n                 makefun(&lua_apr_mkdir, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"mkrdir\", APR_HASH_KEY_STRING,\n                 makefun(&lua_apr_mkrdir, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"rmdir\", APR_HASH_KEY_STRING,\n                 makefun(&lua_apr_rmdir, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"date_parse_rfc\", APR_HASH_KEY_STRING,\n                 makefun(&lua_apr_date_parse_rfc, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"escape\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_escape, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"unescape\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_unescape, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"mpm_query\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_mpm_query, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"expr\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_expr, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"scoreboard_process\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_scoreboard_process, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"scoreboard_worker\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_scoreboard_worker, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"clock\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_clock, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"requestbody\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_requestbody, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"add_input_filter\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_add_input_filter, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"module_info\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_module_info, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"loaded_modules\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_loaded_modules, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"runtime_dir_relative\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_runtime_dir_relative, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"server_info\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_server_info, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"set_document_root\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_set_document_root, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"set_context_info\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_set_context_info, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"os_escape_path\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_os_escape_path, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"escape_logitem\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_escape_logitem, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"strcmp_match\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_strcmp_match, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"set_keepalive\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_set_keepalive, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"make_etag\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_make_etag, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"send_interim_response\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_send_interim_response, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"custom_response\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_custom_response, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"exists_config_define\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_exists_config_define, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"state_query\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_state_query, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"get_server_name_for_url\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_get_server_name_for_url, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"ivm_get\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ivm_get, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"ivm_set\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ivm_set, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"getcookie\", APR_HASH_KEY_STRING,\n                 makefun(&lua_get_cookie, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"setcookie\", APR_HASH_KEY_STRING,\n                 makefun(&lua_set_cookie, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"wsupgrade\", APR_HASH_KEY_STRING,\n                 makefun(&lua_websocket_greet, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"wsread\", APR_HASH_KEY_STRING,\n                 makefun(&lua_websocket_read, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"wspeek\", APR_HASH_KEY_STRING,\n                 makefun(&lua_websocket_peek, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"wswrite\", APR_HASH_KEY_STRING,\n                 makefun(&lua_websocket_write, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"wsclose\", APR_HASH_KEY_STRING,\n                 makefun(&lua_websocket_close, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"wsping\", APR_HASH_KEY_STRING,\n                 makefun(&lua_websocket_ping, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"config\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_get_config, APL_REQ_FUNTYPE_LUACFUN, p));\n    apr_hash_set(dispatch, \"activeconfig\", APR_HASH_KEY_STRING,\n                 makefun(&lua_ap_get_active_config, APL_REQ_FUNTYPE_LUACFUN, p));\n    lua_pushlightuserdata(L, dispatch);\n    lua_setfield(L, LUA_REGISTRYINDEX, \"Apache2.Request.dispatch\");\n    luaL_newmetatable(L, \"Apache2.Request\");    \n    lua_pushvalue(L, -1);\n    lua_setfield(L, -2, \"__index\");\n    luaL_register(L, NULL, request_methods);    \n    lua_pop(L, 2);\n    luaL_newmetatable(L, \"Apache2.Connection\"); \n    lua_pushvalue(L, -1);\n    lua_setfield(L, -2, \"__index\");\n    luaL_register(L, NULL, connection_methods); \n    lua_pop(L, 2);\n    luaL_newmetatable(L, \"Apache2.Server\");     \n    lua_pushvalue(L, -1);\n    lua_setfield(L, -2, \"__index\");\n    luaL_register(L, NULL, server_methods);     \n    lua_pop(L, 2);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":45045
  },
  {
    "code":"SavePageResult ArchiverResultToSavePageResult(ArchiverResult archiver_result) {\n  switch (archiver_result) {\n    case ArchiverResult::SUCCESSFULLY_CREATED:\n      return SavePageResult::SUCCESS;\n    case ArchiverResult::ERROR_DEVICE_FULL:\n      return SavePageResult::DEVICE_FULL;\n    case ArchiverResult::ERROR_CONTENT_UNAVAILABLE:\n      return SavePageResult::CONTENT_UNAVAILABLE;\n    case ArchiverResult::ERROR_ARCHIVE_CREATION_FAILED:\n      return SavePageResult::ARCHIVE_CREATION_FAILED;\n    case ArchiverResult::ERROR_CANCELED:\n      return SavePageResult::CANCELLED;\n    case ArchiverResult::ERROR_SECURITY_CERTIFICATE:\n      return SavePageResult::SECURITY_CERTIFICATE_ERROR;\n    case ArchiverResult::ERROR_ERROR_PAGE:\n      return SavePageResult::ERROR_PAGE;\n    case ArchiverResult::ERROR_INTERSTITIAL_PAGE:\n      return SavePageResult::INTERSTITIAL_PAGE;\n    case ArchiverResult::ERROR_SKIPPED:\n      return SavePageResult::SKIPPED;\n    case ArchiverResult::ERROR_DIGEST_CALCULATION_FAILED:\n      return SavePageResult::DIGEST_CALCULATION_FAILED;\n  }\n  NOTREACHED();\n  return SavePageResult::CONTENT_UNAVAILABLE;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":168992
  },
  {
    "code":"daemon_linux_lvm2_lv_remove_authorized_cb (Daemon *daemon,\n                                           Device *device,\n                                           DBusGMethodInvocation *context,\n                                           const gchar *action_id,\n                                           guint num_user_data,\n                                           gpointer *user_data_elements)\n{\n  const gchar *group_uuid = user_data_elements[0];\n  const gchar *uuid = user_data_elements[1];\n  gchar *lv_name;\n  guint n;\n  gchar *argv[10];\n  lv_name = find_lvm2_lv_name_for_uuids (daemon, group_uuid, uuid);\n  if (lv_name == NULL)\n    {\n      throw_error (context, ERROR_FAILED, \"Cannot find LV with UUID `%s'\", uuid);\n      goto out;\n    }\n  n = 0;\n  argv[n++] = \"lvremove\";\n  argv[n++] = lv_name;\n  argv[n++] = \"--force\";\n  argv[n++] = NULL;\n  if (!job_new (context, \"LinuxLvm2LVRemove\", TRUE, NULL, argv, NULL, linux_lvm2_lv_remove_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  g_free (lv_name);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":11587
  },
  {
    "code":"void GLES2DecoderImpl::DoBlitFramebufferCHROMIUM(\n    GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1,\n    GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1,\n    GLbitfield mask, GLenum filter) {\n  DCHECK(!ShouldDeferReads() && !ShouldDeferDraws());\n  if (!CheckBoundFramebuffersValid(\"glBlitFramebufferCHROMIUM\")) {\n    return;\n  }\n  state_.SetDeviceCapabilityState(GL_SCISSOR_TEST, false);\n  ScopedRenderTo do_render(framebuffer_state_.bound_draw_framebuffer.get());\n  BlitFramebufferHelper(\n      srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);\n  state_.SetDeviceCapabilityState(GL_SCISSOR_TEST,\n                                  state_.enable_flags.scissor_test);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":140722
  },
  {
    "code":"_archive_write_disk_header(struct archive *_a, struct archive_entry *entry)\n{\n  struct archive_write_disk *a = (struct archive_write_disk *)_a;\n  struct fixup_entry *fe;\n  int ret, r;\n  archive_check_magic(&a->archive, ARCHIVE_WRITE_DISK_MAGIC,\n      ARCHIVE_STATE_HEADER | ARCHIVE_STATE_DATA,\n      \"archive_write_disk_header\");\n  archive_clear_error(&a->archive);\n  if (a->archive.state & ARCHIVE_STATE_DATA) {\n    r = _archive_write_disk_finish_entry(&a->archive);\n    if (r == ARCHIVE_FATAL)\n      return (r);\n  }\n  a->pst = NULL;\n  a->current_fixup = NULL;\n  a->deferred = 0;\n  if (a->entry) {\n    archive_entry_free(a->entry);\n    a->entry = NULL;\n  }\n  a->entry = archive_entry_clone(entry);\n  a->fd = -1;\n  a->fd_offset = 0;\n  a->offset = 0;\n  a->restore_pwd = -1;\n  a->uid = a->user_uid;\n  a->mode = archive_entry_mode(a->entry);\n  if (archive_entry_size_is_set(a->entry))\n    a->filesize = archive_entry_size(a->entry);\n  else\n    a->filesize = -1;\n  archive_strcpy(&(a->_name_data), archive_entry_pathname(a->entry));\n  a->name = a->_name_data.s;\n  archive_clear_error(&a->archive);\n  ret = cleanup_pathname(a);\n  if (ret != ARCHIVE_OK)\n    return (ret);\n  umask(a->user_umask = umask(0));\n  a->todo = TODO_MODE_BASE;\n  if (a->flags & ARCHIVE_EXTRACT_PERM) {\n    a->todo |= TODO_MODE_FORCE; \n    if (a->mode & S_ISGID)\n      a->todo |= TODO_SGID | TODO_SGID_CHECK;\n    if (a->mode & S_ISUID)\n      a->todo |= TODO_SUID | TODO_SUID_CHECK;\n  } else {\n    a->mode &= ~S_ISUID;\n    a->mode &= ~S_ISGID;\n    a->mode &= ~S_ISVTX;\n    a->mode &= ~a->user_umask;\n  }\n  if (a->flags & ARCHIVE_EXTRACT_OWNER)\n    a->todo |= TODO_OWNER;\n  if (a->flags & ARCHIVE_EXTRACT_TIME)\n    a->todo |= TODO_TIMES;\n  if (a->flags & ARCHIVE_EXTRACT_ACL) {\n    if (archive_entry_filetype(a->entry) == AE_IFDIR)\n      a->deferred |= TODO_ACLS;\n    else\n      a->todo |= TODO_ACLS;\n  }\n  if (a->flags & ARCHIVE_EXTRACT_MAC_METADATA) {\n    if (archive_entry_filetype(a->entry) == AE_IFDIR)\n      a->deferred |= TODO_MAC_METADATA;\n    else\n      a->todo |= TODO_MAC_METADATA;\n  }\n#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_ZLIB_H)\n  if ((a->flags & ARCHIVE_EXTRACT_NO_HFS_COMPRESSION) == 0) {\n    unsigned long set, clear;\n    archive_entry_fflags(a->entry, &set, &clear);\n    if ((set & ~clear) & UF_COMPRESSED) {\n      a->todo |= TODO_HFS_COMPRESSION;\n      a->decmpfs_block_count = (unsigned)-1;\n    }\n  }\n  if ((a->flags & ARCHIVE_EXTRACT_HFS_COMPRESSION_FORCED) != 0 &&\n      (a->mode & AE_IFMT) == AE_IFREG && a->filesize > 0) {\n    a->todo |= TODO_HFS_COMPRESSION;\n    a->decmpfs_block_count = (unsigned)-1;\n  }\n  {\n    const char *p;\n    p = strrchr(a->name, '\/');\n    if (p == NULL)\n      p = a->name;\n    else\n      p++;\n    if (p[0] == '.' && p[1] == '_') {\n      a->todo &= ~TODO_HFS_COMPRESSION;\n      if (a->filesize > 0)\n        a->todo |= TODO_APPLEDOUBLE;\n    }\n  }\n#endif\n  if (a->flags & ARCHIVE_EXTRACT_XATTR)\n    a->todo |= TODO_XATTR;\n  if (a->flags & ARCHIVE_EXTRACT_FFLAGS)\n    a->todo |= TODO_FFLAGS;\n  if (a->flags & ARCHIVE_EXTRACT_SECURE_SYMLINKS) {\n    ret = check_symlinks(a);\n    if (ret != ARCHIVE_OK)\n      return (ret);\n  }\n#if defined(HAVE_FCHDIR) && defined(PATH_MAX)\n  edit_deep_directories(a);\n#endif\n  ret = restore_entry(a);\n#if defined(__APPLE__) && defined(UF_COMPRESSED) && defined(HAVE_ZLIB_H)\n  if (a->todo | TODO_HFS_COMPRESSION) {\n    if (a->fd < 0 || fchflags(a->fd, UF_COMPRESSED) != 0)\n      a->todo &= ~TODO_HFS_COMPRESSION;\n  }\n#endif\n#ifdef HAVE_FCHDIR\n  if (a->restore_pwd >= 0) {\n    r = fchdir(a->restore_pwd);\n    if (r != 0) {\n      archive_set_error(&a->archive, errno, \"chdir() failure\");\n      ret = ARCHIVE_FATAL;\n    }\n    close(a->restore_pwd);\n    a->restore_pwd = -1;\n  }\n#endif\n  if (a->deferred & TODO_MODE) {\n    fe = current_fixup(a, archive_entry_pathname(entry));\n    if (fe == NULL)\n      return (ARCHIVE_FATAL);\n    fe->fixup |= TODO_MODE_BASE;\n    fe->mode = a->mode;\n  }\n  if ((a->deferred & TODO_TIMES)\n    && (archive_entry_mtime_is_set(entry)\n        || archive_entry_atime_is_set(entry))) {\n    fe = current_fixup(a, archive_entry_pathname(entry));\n    if (fe == NULL)\n      return (ARCHIVE_FATAL);\n    fe->mode = a->mode;\n    fe->fixup |= TODO_TIMES;\n    if (archive_entry_atime_is_set(entry)) {\n      fe->atime = archive_entry_atime(entry);\n      fe->atime_nanos = archive_entry_atime_nsec(entry);\n    } else {\n      fe->atime = a->start_time;\n      fe->atime_nanos = 0;\n    }\n    if (archive_entry_mtime_is_set(entry)) {\n      fe->mtime = archive_entry_mtime(entry);\n      fe->mtime_nanos = archive_entry_mtime_nsec(entry);\n    } else {\n      fe->mtime = a->start_time;\n      fe->mtime_nanos = 0;\n    }\n    if (archive_entry_birthtime_is_set(entry)) {\n      fe->birthtime = archive_entry_birthtime(entry);\n      fe->birthtime_nanos = archive_entry_birthtime_nsec(entry);\n    } else {\n      fe->birthtime = fe->mtime;\n      fe->birthtime_nanos = fe->mtime_nanos;\n    }\n  }\n  if (a->deferred & TODO_ACLS) {\n    fe = current_fixup(a, archive_entry_pathname(entry));\n    if (fe == NULL)\n      return (ARCHIVE_FATAL);\n    fe->fixup |= TODO_ACLS;\n    archive_acl_copy(&fe->acl, archive_entry_acl(entry));\n  }\n  if (a->deferred & TODO_MAC_METADATA) {\n    const void *metadata;\n    size_t metadata_size;\n    metadata = archive_entry_mac_metadata(a->entry, &metadata_size);\n    if (metadata != NULL && metadata_size > 0) {\n      fe = current_fixup(a, archive_entry_pathname(entry));\n      if (fe == NULL)\n        return (ARCHIVE_FATAL);\n      fe->mac_metadata = malloc(metadata_size);\n      if (fe->mac_metadata != NULL) {\n        memcpy(fe->mac_metadata, metadata, metadata_size);\n        fe->mac_metadata_size = metadata_size;\n        fe->fixup |= TODO_MAC_METADATA;\n      }\n    }\n  }\n  if (a->deferred & TODO_FFLAGS) {\n    fe = current_fixup(a, archive_entry_pathname(entry));\n    if (fe == NULL)\n      return (ARCHIVE_FATAL);\n    fe->fixup |= TODO_FFLAGS;\n  }\n  if (ret >= ARCHIVE_WARN)\n    a->archive.state = ARCHIVE_STATE_DATA;\n  if (a->fd < 0) {\n    archive_entry_set_size(entry, 0);\n    a->filesize = 0;\n  }\n  return (ret);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":43892
  },
  {
    "code":"static int vmx_pre_block(struct kvm_vcpu *vcpu)\n{\n  if (pi_pre_block(vcpu))\n    return 1;\n  if (kvm_lapic_hv_timer_in_use(vcpu))\n    kvm_lapic_switch_to_sw_timer(vcpu);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":48127
  },
  {
    "code":"struct net_device *__dev_get_by_index(struct net *net, int ifindex)\n{\n  struct net_device *dev;\n  struct hlist_head *head = dev_index_hash(net, ifindex);\n  hlist_for_each_entry(dev, head, index_hlist)\n    if (dev->ifindex == ifindex)\n      return dev;\n  return NULL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":48731
  },
  {
    "code":"void RenderProcessHostImpl::RegisterAecDumpConsumerOnUIThread(int id) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  aec_dump_consumers_.push_back(id);\n  WebRTCInternals* webrtc_internals = WebRTCInternals::GetInstance();\n  if (webrtc_internals->IsAudioDebugRecordingsEnabled()) {\n    base::FilePath file_with_extensions = GetAecDumpFilePathWithExtensions(\n        webrtc_internals->GetAudioDebugRecordingsFilePath());\n    EnableAecDumpForId(file_with_extensions, id);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":162130
  },
  {
    "code":"void LayerTreeHostImpl::DidChangeBrowserControlsPosition() {\n  UpdateViewportContainerSizes();\n  SetNeedsRedraw();\n  SetNeedsOneBeginImplFrame();\n  active_tree_->set_needs_update_draw_properties();\n  SetFullViewportDamage();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":149930
  },
  {
    "code":"_tiffUnmapProc(thandle_t fd, void* base, toff_t size)\n{\n  (void) fd; (void) base; (void) size;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":86773
  },
  {
    "code":"LayoutSVGTransformableContainer::LayoutSVGTransformableContainer(SVGGraphicsElement* node)\n    : LayoutSVGContainer(node)\n    , m_needsTransformUpdate(true)\n{\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":129599
  },
  {
    "code":"void ssl3_set_handshake_header(SSL *s, int htype, unsigned long len)\n{\n    unsigned char *p = (unsigned char *)s->init_buf->data;\n    *(p++) = htype;\n    l2n3(len, p);\n    s->init_num = (int)len + SSL3_HM_HEADER_LENGTH;\n    s->init_off = 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":13703
  },
  {
    "code":"SyncManager::~SyncManager() {\n  DCHECK(thread_checker_.CalledOnValidThread());\n  delete data_;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":112141
  },
  {
    "code":"static int xts_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\n           struct scatterlist *src, unsigned int nbytes)\n{\n  struct crypto_aes_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\n  int err, first, rounds = 6 + ctx->key1.key_length \/ 4;\n  struct blkcipher_walk walk;\n  unsigned int blocks;\n  desc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\n  blkcipher_walk_init(&walk, dst, src, nbytes);\n  err = blkcipher_walk_virt(desc, &walk);\n  kernel_neon_begin();\n  for (first = 1; (blocks = (walk.nbytes \/ AES_BLOCK_SIZE)); first = 0) {\n    aes_xts_encrypt(walk.dst.virt.addr, walk.src.virt.addr,\n        (u8 *)ctx->key1.key_enc, rounds, blocks,\n        (u8 *)ctx->key2.key_enc, walk.iv, first);\n    err = blkcipher_walk_done(desc, &walk, walk.nbytes % AES_BLOCK_SIZE);\n  }\n  kernel_neon_end();\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":46641
  },
  {
    "code":" ZEND_API void zend_update_property_null(zend_class_entry *scope, zval *object, const char *name, int name_length TSRMLS_DC) \n {\n        zval *tmp;\n  ALLOC_ZVAL(tmp);\n  Z_UNSET_ISREF_P(tmp);\n  Z_SET_REFCOUNT_P(tmp, 0);\n  ZVAL_LONG(tmp, value);\n  zend_update_property(scope, object, name, name_length, tmp TSRMLS_CC);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":13845
  },
  {
    "code":"static void cassignforin(JF, js_Ast *stm)\n{\n  js_Ast *lhs = stm->a;\n  if (stm->type == STM_FOR_IN_VAR) {\n    if (lhs->b)\n      jsC_error(J, lhs->b, \"more than one loop variable in for-in statement\");\n    emitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs->a->a); \n    emit(J, F, OP_POP);\n    return;\n  }\n  switch (lhs->type) {\n  case EXP_IDENTIFIER:\n    emitlocal(J, F, OP_SETLOCAL, OP_SETVAR, lhs);\n    emit(J, F, OP_POP);\n    break;\n  case EXP_INDEX:\n    cexp(J, F, lhs->a);\n    cexp(J, F, lhs->b);\n    emit(J, F, OP_ROT3);\n    emit(J, F, OP_SETPROP);\n    emit(J, F, OP_POP);\n    break;\n  case EXP_MEMBER:\n    cexp(J, F, lhs->a);\n    emit(J, F, OP_ROT2);\n    emitstring(J, F, OP_SETPROP_S, lhs->b->string);\n    emit(J, F, OP_POP);\n    break;\n  default:\n    jsC_error(J, lhs, \"invalid l-value in for-in loop assignment\");\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":7899
  },
  {
    "code":"FileTransfer::~FileTransfer()\n{\n  if (daemonCore && ActiveTransferTid >= 0) {\n    dprintf(D_ALWAYS, \"FileTransfer object destructor called during \"\n        \"active transfer.  Cancelling transfer.\\n\");\n    daemonCore->Kill_Thread(ActiveTransferTid);\n    TransThreadTable->remove(ActiveTransferTid);\n    ActiveTransferTid = -1;\n  }\n  if (TransferPipe[0] >= 0) close(TransferPipe[0]);\n  if (TransferPipe[1] >= 0) close(TransferPipe[1]);\n  if (Iwd) free(Iwd);\n  if (ExecFile) free(ExecFile);\n  if (UserLogFile) free(UserLogFile);\n  if (X509UserProxy) free(X509UserProxy);\n  if (SpoolSpace) free(SpoolSpace);\n  if (TmpSpoolSpace) free(TmpSpoolSpace);\n  if (ExceptionFiles) delete ExceptionFiles;\n  if (InputFiles) delete InputFiles;\n  if (OutputFiles) delete OutputFiles;\n  if (EncryptInputFiles) delete EncryptInputFiles;\n  if (EncryptOutputFiles) delete EncryptOutputFiles;\n  if (DontEncryptInputFiles) delete DontEncryptInputFiles;\n  if (DontEncryptOutputFiles) delete DontEncryptOutputFiles;\n  if (OutputDestination) delete OutputDestination;\n  if (IntermediateFiles) delete IntermediateFiles;\n  if (SpooledIntermediateFiles) delete SpooledIntermediateFiles;\n  if (last_download_catalog) {\n    CatalogEntry *entry_pointer;\n    last_download_catalog->startIterations();\n    while(last_download_catalog->iterate(entry_pointer)) {\n      delete entry_pointer;\n    }\n    delete last_download_catalog;\n  }\n  if (TransSock) free(TransSock);\n  if (TransKey) {\n    if ( TranskeyTable ) {\n      MyString key(TransKey);\n      TranskeyTable->remove(key);\n      if ( TranskeyTable->getNumElements() == 0 ) {\n        delete TranskeyTable;\n        TranskeyTable = NULL;\n        delete TransThreadTable;\n        TransThreadTable = NULL;\n      }\n    }    \n    free(TransKey);\n  }  \n#ifdef WIN32\n  if (perm_obj) delete perm_obj;\n#endif\n  free(m_sec_session_id);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":16616
  },
  {
    "code":"static ssize_t sock_sendpage(struct file *file, struct page *page,\n           int offset, size_t size, loff_t *ppos, int more)\n{\n  struct socket *sock;\n  int flags;\n  sock = file->private_data;\n  flags = (file->f_flags & O_NONBLOCK) ? MSG_DONTWAIT : 0;\n  flags |= more;\n  return kernel_sendpage(sock, page, offset, size, flags);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":18701
  },
  {
    "code":"ftp_mkdir(ftpbuf_t *ftp, const char *dir)\n{\n  char *mkd, *end;\n  if (ftp == NULL) {\n    return NULL;\n  }\n  if (!ftp_putcmd(ftp, \"MKD\", dir)) {\n    return NULL;\n  }\n  if (!ftp_getresp(ftp) || ftp->resp != 257) {\n    return NULL;\n  }\n  if ((mkd = strchr(ftp->inbuf, '\"')) == NULL) {\n    mkd = estrdup(dir);\n    return mkd;\n  }\n  if ((end = strrchr(++mkd, '\"')) == NULL) {\n    return NULL;\n  }\n  *end = 0;\n  mkd = estrdup(mkd);\n  *end = '\"';\n  return mkd;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":14797
  },
  {
    "code":"static int ipx_ioctl(struct socket *sock, unsigned int cmd, unsigned long arg)\n{\n  int rc = 0;\n  long amount = 0;\n  struct sock *sk = sock->sk;\n  void __user *argp = (void __user *)arg;\n  lock_sock(sk);\n  switch (cmd) {\n  case TIOCOUTQ:\n    amount = sk->sk_sndbuf - sk_wmem_alloc_get(sk);\n    if (amount < 0)\n      amount = 0;\n    rc = put_user(amount, (int __user *)argp);\n    break;\n  case TIOCINQ: {\n    struct sk_buff *skb = skb_peek(&sk->sk_receive_queue);\n    if (skb)\n      amount = skb->len - sizeof(struct ipxhdr);\n    rc = put_user(amount, (int __user *)argp);\n    break;\n  }\n  case SIOCADDRT:\n  case SIOCDELRT:\n    rc = -EPERM;\n    if (capable(CAP_NET_ADMIN))\n      rc = ipxrtr_ioctl(cmd, argp);\n    break;\n  case SIOCSIFADDR:\n  case SIOCAIPXITFCRT:\n  case SIOCAIPXPRISLT:\n    rc = -EPERM;\n    if (!capable(CAP_NET_ADMIN))\n      break;\n  case SIOCGIFADDR:\n    rc = ipxitf_ioctl(cmd, argp);\n    break;\n  case SIOCIPXCFGDATA:\n    rc = ipxcfg_get_config_data(argp);\n    break;\n  case SIOCIPXNCPCONN:\n    rc = -EPERM;\n    if (!capable(CAP_NET_ADMIN))\n      break;\n    rc = get_user(ipx_sk(sk)->ipx_ncp_conn,\n            (const unsigned short __user *)argp);\n    break;\n  case SIOCGSTAMP:\n    rc = sock_get_timestamp(sk, argp);\n    break;\n  case SIOCGIFDSTADDR:\n  case SIOCSIFDSTADDR:\n  case SIOCGIFBRDADDR:\n  case SIOCSIFBRDADDR:\n  case SIOCGIFNETMASK:\n  case SIOCSIFNETMASK:\n    rc = -EINVAL;\n    break;\n  default:\n    rc = -ENOIOCTLCMD;\n    break;\n  }\n  release_sock(sk);\n  return rc;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":40431
  },
  {
    "code":"struct blk_desc *blk_get_dev(const char *ifname, int dev)\n{\n  return get_dev_hwpart(ifname, dev, 0);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":89373
  },
  {
    "code":"status_t MediaPlayer::setListener(const sp<MediaPlayerListener>& listener)\n{\n    ALOGV(\"setListener\");\n Mutex::Autolock _l(mLock);\n    mListener = listener;\n return NO_ERROR;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":172682
  },
  {
    "code":" void test_base64_decode(void)\n {\n   char buffer[16];\n  int len = mutt_b64_decode(buffer, encoded);\n   if (!TEST_CHECK(len == sizeof(clear) - 1))\n   {\n     TEST_MSG(\"Expected: %zu\", sizeof(clear) - 1);\n    TEST_MSG(\"Actual  : %zu\", len);\n  }\n  buffer[len] = '\\0';\n  if (!TEST_CHECK(strcmp(buffer, clear) == 0))\n  {\n    TEST_MSG(\"Expected: %s\", clear);\n    TEST_MSG(\"Actual  : %s\", buffer);\n  }\n}\n",
    "vul":1,
    "flaw_line_no":[
      4,
      5,
      8,
      10
    ],
    "bigvul_id":182302
  },
  {
    "code":"xsltDocumentFunctionLoadDocument(xmlXPathParserContextPtr ctxt, xmlChar* URI)\n{\n    xsltTransformContextPtr tctxt;\n    xmlURIPtr uri;\n    xmlChar *fragment;\n    xsltDocumentPtr idoc; \n    xmlDocPtr doc;\n    xmlXPathContextPtr xptrctxt = NULL;\n    xmlXPathObjectPtr resObj = NULL;\n    tctxt = xsltXPathGetTransformContext(ctxt);\n    if (tctxt == NULL) {\n  xsltTransformError(NULL, NULL, NULL,\n      \"document() : internal error tctxt == NULL\\n\");\n  valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n  return;\n    }\n    uri = xmlParseURI((const char *) URI);\n    if (uri == NULL) {\n  xsltTransformError(tctxt, NULL, NULL,\n      \"document() : failed to parse URI\\n\");\n  valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n  return;\n    }\n    fragment = (xmlChar *)uri->fragment;\n    if (fragment != NULL) {\n        xmlChar *newURI;\n  uri->fragment = NULL;\n  newURI = xmlSaveUri(uri);\n  idoc = xsltLoadDocument(tctxt, newURI);\n  xmlFree(newURI);\n    } else\n  idoc = xsltLoadDocument(tctxt, URI);\n    xmlFreeURI(uri);\n    if (idoc == NULL) {\n  if ((URI == NULL) ||\n      (URI[0] == '#') ||\n      ((tctxt->style->doc != NULL) &&\n      (xmlStrEqual(tctxt->style->doc->URL, URI))))\n  {\n      doc = tctxt->style->doc;\n  } else {\n      valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n      if (fragment != NULL)\n    xmlFree(fragment);\n      return;\n  }\n    } else\n  doc = idoc->doc;\n    if (fragment == NULL) {\n  valuePush(ctxt, xmlXPathNewNodeSet((xmlNodePtr) doc));\n  return;\n    }\n#ifdef LIBXML_XPTR_ENABLED\n    xptrctxt = xmlXPtrNewContext(doc, NULL, NULL);\n    if (xptrctxt == NULL) {\n  xsltTransformError(tctxt, NULL, NULL,\n      \"document() : internal error xptrctxt == NULL\\n\");\n  goto out_fragment;\n    }\n     resObj = xmlXPtrEval(fragment, xptrctxt);\n     xmlXPathFreeContext(xptrctxt);\n #endif\n    xmlFree(fragment);\n     if (resObj == NULL)\n   goto out_fragment;\n    switch (resObj->type) {\n  case XPATH_NODESET:\n      break;\n  case XPATH_UNDEFINED:\n  case XPATH_BOOLEAN:\n  case XPATH_NUMBER:\n  case XPATH_STRING:\n  case XPATH_POINT:\n  case XPATH_USERS:\n  case XPATH_XSLT_TREE:\n  case XPATH_RANGE:\n  case XPATH_LOCATIONSET:\n      xsltTransformError(tctxt, NULL, NULL,\n    \"document() : XPointer does not select a node set: #%s\\n\",\n    fragment);\n  goto out_object;\n     }\n     valuePush(ctxt, resObj);\n     return;\n out_object:\n     xmlXPathFreeObject(resObj);\n out_fragment:\n     valuePush(ctxt, xmlXPathNewNodeSet(NULL));\n }\n",
    "vul":1,
    "flaw_line_no":[
      63
    ],
    "bigvul_id":187323
  },
  {
    "code":"static int decode_slice_header(H264Context *h, H264Context *h0)\n{\n    unsigned int first_mb_in_slice;\n    unsigned int pps_id;\n    int ret;\n    unsigned int slice_type, tmp, i, j;\n    int last_pic_structure, last_pic_droppable;\n    int must_reinit;\n    int needs_reinit = 0;\n    int field_pic_flag, bottom_field_flag;\n    h->me.qpel_put = h->h264qpel.put_h264_qpel_pixels_tab;\n    h->me.qpel_avg = h->h264qpel.avg_h264_qpel_pixels_tab;\n    first_mb_in_slice = get_ue_golomb_long(&h->gb);\n    if (first_mb_in_slice == 0) { \n        if (h0->current_slice && FIELD_PICTURE(h)) {\n            field_end(h, 1);\n        }\n        h0->current_slice = 0;\n        if (!h0->first_field) {\n            if (h->cur_pic_ptr && !h->droppable) {\n                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n                                          h->picture_structure == PICT_BOTTOM_FIELD);\n            }\n            h->cur_pic_ptr = NULL;\n        }\n    }\n    slice_type = get_ue_golomb_31(&h->gb);\n    if (slice_type > 9) {\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"slice type too large (%d) at %d %d\\n\",\n               slice_type, h->mb_x, h->mb_y);\n        return AVERROR_INVALIDDATA;\n    }\n    if (slice_type > 4) {\n        slice_type -= 5;\n        h->slice_type_fixed = 1;\n    } else\n        h->slice_type_fixed = 0;\n    slice_type = golomb_to_pict_type[slice_type];\n    h->slice_type     = slice_type;\n    h->slice_type_nos = slice_type & 3;\n    h->pict_type = h->slice_type;\n    pps_id = get_ue_golomb(&h->gb);\n    if (pps_id >= MAX_PPS_COUNT) {\n        av_log(h->avctx, AV_LOG_ERROR, \"pps_id %d out of range\\n\", pps_id);\n        return AVERROR_INVALIDDATA;\n    }\n    if (!h0->pps_buffers[pps_id]) {\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"non-existing PPS %u referenced\\n\",\n               pps_id);\n        return AVERROR_INVALIDDATA;\n    }\n    h->pps = *h0->pps_buffers[pps_id];\n    if (!h0->sps_buffers[h->pps.sps_id]) {\n        av_log(h->avctx, AV_LOG_ERROR,\n               \"non-existing SPS %u referenced\\n\",\n               h->pps.sps_id);\n        return AVERROR_INVALIDDATA;\n    }\n    if (h->pps.sps_id != h->current_sps_id ||\n        h0->sps_buffers[h->pps.sps_id]->new) {\n        h0->sps_buffers[h->pps.sps_id]->new = 0;\n        h->current_sps_id = h->pps.sps_id;\n        h->sps            = *h0->sps_buffers[h->pps.sps_id];\n        if (h->mb_width  != h->sps.mb_width ||\n            h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) ||\n            h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma ||\n            h->cur_chroma_format_idc != h->sps.chroma_format_idc\n        )\n            needs_reinit = 1;\n        if (h->bit_depth_luma    != h->sps.bit_depth_luma ||\n            h->chroma_format_idc != h->sps.chroma_format_idc) {\n            h->bit_depth_luma    = h->sps.bit_depth_luma;\n            h->chroma_format_idc = h->sps.chroma_format_idc;\n            needs_reinit         = 1;\n        }\n        if ((ret = h264_set_parameter_from_sps(h)) < 0)\n            return ret;\n    }\n    h->avctx->profile = ff_h264_get_profile(&h->sps);\n    h->avctx->level   = h->sps.level_idc;\n    h->avctx->refs    = h->sps.ref_frame_count;\n    must_reinit = (h->context_initialized &&\n                    (   16*h->sps.mb_width != h->avctx->coded_width\n                     || 16*h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag) != h->avctx->coded_height\n                     || h->avctx->bits_per_raw_sample != h->sps.bit_depth_luma\n                     || h->cur_chroma_format_idc != h->sps.chroma_format_idc\n                     || av_cmp_q(h->sps.sar, h->avctx->sample_aspect_ratio)\n                     || h->mb_width  != h->sps.mb_width\n                     || h->mb_height != h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag)\n                    ));\n    if (h0->avctx->pix_fmt != get_pixel_format(h0, 0))\n        must_reinit = 1;\n    h->mb_width  = h->sps.mb_width;\n    h->mb_height = h->sps.mb_height * (2 - h->sps.frame_mbs_only_flag);\n    h->mb_num    = h->mb_width * h->mb_height;\n    h->mb_stride = h->mb_width + 1;\n    h->b_stride = h->mb_width * 4;\n    h->chroma_y_shift = h->sps.chroma_format_idc <= 1; \n    h->width  = 16 * h->mb_width;\n    h->height = 16 * h->mb_height;\n    ret = init_dimensions(h);\n    if (ret < 0)\n        return ret;\n    if (h->sps.video_signal_type_present_flag) {\n        h->avctx->color_range = h->sps.full_range>0 ? AVCOL_RANGE_JPEG\n                                                    : AVCOL_RANGE_MPEG;\n        if (h->sps.colour_description_present_flag) {\n            if (h->avctx->colorspace != h->sps.colorspace)\n                needs_reinit = 1;\n            h->avctx->color_primaries = h->sps.color_primaries;\n            h->avctx->color_trc       = h->sps.color_trc;\n            h->avctx->colorspace      = h->sps.colorspace;\n        }\n    }\n    if (h->context_initialized &&\n        (h->width  != h->avctx->coded_width   ||\n         h->height != h->avctx->coded_height  ||\n         must_reinit ||\n         needs_reinit)) {\n        if (h != h0) {\n            av_log(h->avctx, AV_LOG_ERROR, \"changing width\/height on \"\n                   \"slice %d\\n\", h0->current_slice + 1);\n            return AVERROR_INVALIDDATA;\n        }\n        flush_change(h);\n        if ((ret = get_pixel_format(h, 1)) < 0)\n            return ret;\n        h->avctx->pix_fmt = ret;\n        av_log(h->avctx, AV_LOG_INFO, \"Reinit context to %dx%d, \"\n               \"pix_fmt: %s\\n\", h->width, h->height, av_get_pix_fmt_name(h->avctx->pix_fmt));\n        if ((ret = h264_slice_header_init(h, 1)) < 0) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"h264_slice_header_init() failed\\n\");\n            return ret;\n        }\n    }\n    if (!h->context_initialized) {\n        if (h != h0) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"Cannot (re-)initialize context during parallel decoding.\\n\");\n            return AVERROR_PATCHWELCOME;\n        }\n        if ((ret = get_pixel_format(h, 1)) < 0)\n            return ret;\n        h->avctx->pix_fmt = ret;\n        if ((ret = h264_slice_header_init(h, 0)) < 0) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"h264_slice_header_init() failed\\n\");\n            return ret;\n        }\n    }\n    if (h == h0 && h->dequant_coeff_pps != pps_id) {\n        h->dequant_coeff_pps = pps_id;\n        init_dequant_tables(h);\n    }\n    h->frame_num = get_bits(&h->gb, h->sps.log2_max_frame_num);\n    h->mb_mbaff        = 0;\n    h->mb_aff_frame    = 0;\n    last_pic_structure = h0->picture_structure;\n    last_pic_droppable = h0->droppable;\n    h->droppable       = h->nal_ref_idc == 0;\n    if (h->sps.frame_mbs_only_flag) {\n        h->picture_structure = PICT_FRAME;\n    } else {\n        if (!h->sps.direct_8x8_inference_flag && slice_type == AV_PICTURE_TYPE_B) {\n            av_log(h->avctx, AV_LOG_ERROR, \"This stream was generated by a broken encoder, invalid 8x8 inference\\n\");\n            return -1;\n        }\n        field_pic_flag = get_bits1(&h->gb);\n        if (field_pic_flag) {\n            bottom_field_flag = get_bits1(&h->gb);\n            h->picture_structure = PICT_TOP_FIELD + bottom_field_flag;\n        } else {\n            h->picture_structure = PICT_FRAME;\n            h->mb_aff_frame      = h->sps.mb_aff;\n        }\n    }\n    h->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;\n    if (h0->current_slice != 0) {\n        if (last_pic_structure != h->picture_structure ||\n            last_pic_droppable != h->droppable) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"Changing field mode (%d -> %d) between slices is not allowed\\n\",\n                   last_pic_structure, h->picture_structure);\n            h->picture_structure = last_pic_structure;\n            h->droppable         = last_pic_droppable;\n            return AVERROR_INVALIDDATA;\n        } else if (!h0->cur_pic_ptr) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"unset cur_pic_ptr on %d. slice\\n\",\n                   h0->current_slice + 1);\n            return AVERROR_INVALIDDATA;\n        }\n    } else {\n        if (h->frame_num != h->prev_frame_num && h->prev_frame_num >= 0) {\n            int unwrap_prev_frame_num = h->prev_frame_num;\n            int max_frame_num         = 1 << h->sps.log2_max_frame_num;\n            if (unwrap_prev_frame_num > h->frame_num)\n                unwrap_prev_frame_num -= max_frame_num;\n            if ((h->frame_num - unwrap_prev_frame_num) > h->sps.ref_frame_count) {\n                unwrap_prev_frame_num = (h->frame_num - h->sps.ref_frame_count) - 1;\n                if (unwrap_prev_frame_num < 0)\n                    unwrap_prev_frame_num += max_frame_num;\n                h->prev_frame_num = unwrap_prev_frame_num;\n            }\n        }\n        if (h0->first_field) {\n            assert(h0->cur_pic_ptr);\n            assert(h0->cur_pic_ptr->f.data[0]);\n             assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);\n            if (!last_pic_droppable && h0->cur_pic_ptr->tf.owner == h0->avctx) {\n                 ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,\n                                           last_pic_structure == PICT_BOTTOM_FIELD);\n             }\n             if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n                if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {\n                     ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,\n                                               last_pic_structure == PICT_TOP_FIELD);\n                 }\n            } else {\n                if (h0->cur_pic_ptr->frame_num != h->frame_num) {\n                    if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {\n                         ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,\n                                                   last_pic_structure == PICT_TOP_FIELD);\n                     }\n                } else {\n                    if (!((last_pic_structure   == PICT_TOP_FIELD &&\n                           h->picture_structure == PICT_BOTTOM_FIELD) ||\n                          (last_pic_structure   == PICT_BOTTOM_FIELD &&\n                           h->picture_structure == PICT_TOP_FIELD))) {\n                        av_log(h->avctx, AV_LOG_ERROR,\n                               \"Invalid field mode combination %d\/%d\\n\",\n                               last_pic_structure, h->picture_structure);\n                        h->picture_structure = last_pic_structure;\n                        h->droppable         = last_pic_droppable;\n                        return AVERROR_INVALIDDATA;\n                    } else if (last_pic_droppable != h->droppable) {\n                        avpriv_request_sample(h->avctx,\n                                              \"Found reference and non-reference fields in the same frame, which\");\n                        h->picture_structure = last_pic_structure;\n                        h->droppable         = last_pic_droppable;\n                        return AVERROR_PATCHWELCOME;\n                    }\n                }\n            }\n        }\n        while (h->frame_num != h->prev_frame_num && h->prev_frame_num >= 0 && !h0->first_field &&\n               h->frame_num != (h->prev_frame_num + 1) % (1 << h->sps.log2_max_frame_num)) {\n            Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;\n            av_log(h->avctx, AV_LOG_DEBUG, \"Frame num gap %d %d\\n\",\n                   h->frame_num, h->prev_frame_num);\n            if (!h->sps.gaps_in_frame_num_allowed_flag)\n                for(i=0; i<FF_ARRAY_ELEMS(h->last_pocs); i++)\n                    h->last_pocs[i] = INT_MIN;\n            ret = h264_frame_start(h);\n            if (ret < 0)\n                return ret;\n            h->prev_frame_num++;\n            h->prev_frame_num        %= 1 << h->sps.log2_max_frame_num;\n            h->cur_pic_ptr->frame_num = h->prev_frame_num;\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);\n            ret = ff_generate_sliding_window_mmcos(h, 1);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                return ret;\n            ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n                return ret;\n            if (h->short_ref_count) {\n                if (prev) {\n                    av_image_copy(h->short_ref[0]->f.data,\n                                  h->short_ref[0]->f.linesize,\n                                  (const uint8_t **)prev->f.data,\n                                  prev->f.linesize,\n                                  h->avctx->pix_fmt,\n                                  h->mb_width  * 16,\n                                  h->mb_height * 16);\n                    h->short_ref[0]->poc = prev->poc + 2;\n                }\n                h->short_ref[0]->frame_num = h->prev_frame_num;\n            }\n        }\n        if (h0->first_field) {\n            assert(h0->cur_pic_ptr);\n            assert(h0->cur_pic_ptr->f.data[0]);\n            assert(h0->cur_pic_ptr->reference != DELAYED_PIC_REF);\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n                h0->cur_pic_ptr = NULL;\n                h0->first_field = FIELD_PICTURE(h);\n            } else {\n                if (h0->cur_pic_ptr->frame_num != h->frame_num) {\n                    ff_thread_report_progress(&h0->cur_pic_ptr->tf, INT_MAX,\n                                              h0->picture_structure==PICT_BOTTOM_FIELD);\n                    h0->first_field = 1;\n                    h0->cur_pic_ptr = NULL;\n                } else {\n                    h0->first_field = 0;\n                }\n            }\n        } else {\n            h0->first_field = FIELD_PICTURE(h);\n        }\n        if (!FIELD_PICTURE(h) || h0->first_field) {\n            if (h264_frame_start(h) < 0) {\n                h0->first_field = 0;\n                return AVERROR_INVALIDDATA;\n            }\n        } else {\n            release_unused_pictures(h, 0);\n        }\n        if (FIELD_PICTURE(h)) {\n            for(i = (h->picture_structure == PICT_BOTTOM_FIELD); i<h->mb_height; i++)\n                memset(h->slice_table + i*h->mb_stride, -1, (h->mb_stride - (i+1==h->mb_height)) * sizeof(*h->slice_table));\n        } else {\n            memset(h->slice_table, -1,\n                (h->mb_height * h->mb_stride - 1) * sizeof(*h->slice_table));\n        }\n        h0->last_slice_type = -1;\n    }\n    if (h != h0 && (ret = clone_slice(h, h0)) < 0)\n        return ret;\n    for (i = 0; i < h->slice_context_count; i++)\n        if (h->thread_context[i]) {\n            ret = alloc_scratch_buffers(h->thread_context[i], h->linesize);\n            if (ret < 0)\n                return ret;\n        }\n    h->cur_pic_ptr->frame_num = h->frame_num; \n    av_assert1(h->mb_num == h->mb_width * h->mb_height);\n    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||\n        first_mb_in_slice >= h->mb_num) {\n        av_log(h->avctx, AV_LOG_ERROR, \"first_mb_in_slice overflow\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    h->resync_mb_x = h->mb_x =  first_mb_in_slice % h->mb_width;\n    h->resync_mb_y = h->mb_y = (first_mb_in_slice \/ h->mb_width) <<\n                               FIELD_OR_MBAFF_PICTURE(h);\n    if (h->picture_structure == PICT_BOTTOM_FIELD)\n        h->resync_mb_y = h->mb_y = h->mb_y + 1;\n    av_assert1(h->mb_y < h->mb_height);\n    if (h->picture_structure == PICT_FRAME) {\n        h->curr_pic_num = h->frame_num;\n        h->max_pic_num  = 1 << h->sps.log2_max_frame_num;\n    } else {\n        h->curr_pic_num = 2 * h->frame_num + 1;\n        h->max_pic_num  = 1 << (h->sps.log2_max_frame_num + 1);\n    }\n    if (h->nal_unit_type == NAL_IDR_SLICE)\n        get_ue_golomb(&h->gb); \n    if (h->sps.poc_type == 0) {\n        h->poc_lsb = get_bits(&h->gb, h->sps.log2_max_poc_lsb);\n        if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)\n            h->delta_poc_bottom = get_se_golomb(&h->gb);\n    }\n    if (h->sps.poc_type == 1 && !h->sps.delta_pic_order_always_zero_flag) {\n        h->delta_poc[0] = get_se_golomb(&h->gb);\n        if (h->pps.pic_order_present == 1 && h->picture_structure == PICT_FRAME)\n            h->delta_poc[1] = get_se_golomb(&h->gb);\n    }\n    ff_init_poc(h, h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc);\n    if (h->pps.redundant_pic_cnt_present)\n        h->redundant_pic_count = get_ue_golomb(&h->gb);\n    ret = ff_set_ref_count(h);\n    if (ret < 0)\n        return ret;\n    if (slice_type != AV_PICTURE_TYPE_I &&\n        (h0->current_slice == 0 ||\n         slice_type != h0->last_slice_type ||\n         memcmp(h0->last_ref_count, h0->ref_count, sizeof(h0->ref_count)))) {\n        ff_h264_fill_default_ref_list(h);\n    }\n    if (h->slice_type_nos != AV_PICTURE_TYPE_I) {\n       ret = ff_h264_decode_ref_pic_list_reordering(h);\n       if (ret < 0) {\n           h->ref_count[1] = h->ref_count[0] = 0;\n           return ret;\n       }\n    }\n    if ((h->pps.weighted_pred && h->slice_type_nos == AV_PICTURE_TYPE_P) ||\n        (h->pps.weighted_bipred_idc == 1 &&\n         h->slice_type_nos == AV_PICTURE_TYPE_B))\n        ff_pred_weight_table(h);\n    else if (h->pps.weighted_bipred_idc == 2 &&\n             h->slice_type_nos == AV_PICTURE_TYPE_B) {\n        implicit_weight_table(h, -1);\n    } else {\n        h->use_weight = 0;\n        for (i = 0; i < 2; i++) {\n            h->luma_weight_flag[i]   = 0;\n            h->chroma_weight_flag[i] = 0;\n        }\n    }\n    if (h->nal_ref_idc) {\n        ret = ff_h264_decode_ref_pic_marking(h0, &h->gb,\n                                             !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||\n                                             h0->current_slice == 0);\n        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n            return AVERROR_INVALIDDATA;\n    }\n    if (FRAME_MBAFF(h)) {\n        ff_h264_fill_mbaff_ref_list(h);\n        if (h->pps.weighted_bipred_idc == 2 && h->slice_type_nos == AV_PICTURE_TYPE_B) {\n            implicit_weight_table(h, 0);\n            implicit_weight_table(h, 1);\n        }\n    }\n    if (h->slice_type_nos == AV_PICTURE_TYPE_B && !h->direct_spatial_mv_pred)\n        ff_h264_direct_dist_scale_factor(h);\n    ff_h264_direct_ref_list_init(h);\n    if (h->slice_type_nos != AV_PICTURE_TYPE_I && h->pps.cabac) {\n        tmp = get_ue_golomb_31(&h->gb);\n        if (tmp > 2) {\n            av_log(h->avctx, AV_LOG_ERROR, \"cabac_init_idc overflow\\n\");\n            return AVERROR_INVALIDDATA;\n        }\n        h->cabac_init_idc = tmp;\n    }\n    h->last_qscale_diff = 0;\n    tmp = h->pps.init_qp + get_se_golomb(&h->gb);\n    if (tmp > 51 + 6 * (h->sps.bit_depth_luma - 8)) {\n        av_log(h->avctx, AV_LOG_ERROR, \"QP %u out of range\\n\", tmp);\n        return AVERROR_INVALIDDATA;\n    }\n    h->qscale       = tmp;\n    h->chroma_qp[0] = get_chroma_qp(h, 0, h->qscale);\n    h->chroma_qp[1] = get_chroma_qp(h, 1, h->qscale);\n    if (h->slice_type == AV_PICTURE_TYPE_SP)\n        get_bits1(&h->gb); \n    if (h->slice_type == AV_PICTURE_TYPE_SP ||\n        h->slice_type == AV_PICTURE_TYPE_SI)\n        get_se_golomb(&h->gb); \n    h->deblocking_filter     = 1;\n    h->slice_alpha_c0_offset = 52;\n    h->slice_beta_offset     = 52;\n    if (h->pps.deblocking_filter_parameters_present) {\n        tmp = get_ue_golomb_31(&h->gb);\n        if (tmp > 2) {\n            av_log(h->avctx, AV_LOG_ERROR,\n                   \"deblocking_filter_idc %u out of range\\n\", tmp);\n            return AVERROR_INVALIDDATA;\n        }\n        h->deblocking_filter = tmp;\n        if (h->deblocking_filter < 2)\n            h->deblocking_filter ^= 1;  \n        if (h->deblocking_filter) {\n            h->slice_alpha_c0_offset += get_se_golomb(&h->gb) << 1;\n            h->slice_beta_offset     += get_se_golomb(&h->gb) << 1;\n            if (h->slice_alpha_c0_offset > 104U ||\n                h->slice_beta_offset     > 104U) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"deblocking filter parameters %d %d out of range\\n\",\n                       h->slice_alpha_c0_offset, h->slice_beta_offset);\n                return AVERROR_INVALIDDATA;\n            }\n        }\n    }\n    if (h->avctx->skip_loop_filter >= AVDISCARD_ALL ||\n        (h->avctx->skip_loop_filter >= AVDISCARD_NONKEY &&\n         h->slice_type_nos != AV_PICTURE_TYPE_I) ||\n        (h->avctx->skip_loop_filter >= AVDISCARD_BIDIR  &&\n         h->slice_type_nos == AV_PICTURE_TYPE_B) ||\n        (h->avctx->skip_loop_filter >= AVDISCARD_NONREF &&\n         h->nal_ref_idc == 0))\n        h->deblocking_filter = 0;\n    if (h->deblocking_filter == 1 && h0->max_contexts > 1) {\n        if (h->avctx->flags2 & CODEC_FLAG2_FAST) {\n            h->deblocking_filter = 2;\n        } else {\n            h0->max_contexts = 1;\n            if (!h0->single_decode_warning) {\n                av_log(h->avctx, AV_LOG_INFO,\n                       \"Cannot parallelize deblocking type 1, decoding such frames in sequential order\\n\");\n                h0->single_decode_warning = 1;\n            }\n            if (h != h0) {\n                av_log(h->avctx, AV_LOG_ERROR,\n                       \"Deblocking switched inside frame.\\n\");\n                return 1;\n            }\n        }\n    }\n    h->qp_thresh = 15 + 52 -\n                   FFMIN(h->slice_alpha_c0_offset, h->slice_beta_offset) -\n                   FFMAX3(0,\n                          h->pps.chroma_qp_index_offset[0],\n                          h->pps.chroma_qp_index_offset[1]) +\n                   6 * (h->sps.bit_depth_luma - 8);\n    h0->last_slice_type = slice_type;\n    memcpy(h0->last_ref_count, h0->ref_count, sizeof(h0->last_ref_count));\n    h->slice_num        = ++h0->current_slice;\n    if (h->slice_num)\n        h0->slice_row[(h->slice_num-1)&(MAX_SLICES-1)]= h->resync_mb_y;\n    if (   h0->slice_row[h->slice_num&(MAX_SLICES-1)] + 3 >= h->resync_mb_y\n        && h0->slice_row[h->slice_num&(MAX_SLICES-1)] <= h->resync_mb_y\n        && h->slice_num >= MAX_SLICES) {\n        av_log(h->avctx, AV_LOG_WARNING, \"Possibly too many slices (%d >= %d), increase MAX_SLICES and recompile if there are artifacts\\n\", h->slice_num, MAX_SLICES);\n    }\n    for (j = 0; j < 2; j++) {\n        int id_list[16];\n        int *ref2frm = h->ref2frm[h->slice_num & (MAX_SLICES - 1)][j];\n        for (i = 0; i < 16; i++) {\n            id_list[i] = 60;\n            if (j < h->list_count && i < h->ref_count[j] &&\n                h->ref_list[j][i].f.buf[0]) {\n                int k;\n                AVBuffer *buf = h->ref_list[j][i].f.buf[0]->buffer;\n                for (k = 0; k < h->short_ref_count; k++)\n                    if (h->short_ref[k]->f.buf[0]->buffer == buf) {\n                        id_list[i] = k;\n                        break;\n                    }\n                for (k = 0; k < h->long_ref_count; k++)\n                    if (h->long_ref[k] && h->long_ref[k]->f.buf[0]->buffer == buf) {\n                        id_list[i] = h->short_ref_count + k;\n                        break;\n                    }\n            }\n        }\n        ref2frm[0] =\n        ref2frm[1] = -1;\n        for (i = 0; i < 16; i++)\n            ref2frm[i + 2] = 4 * id_list[i] + (h->ref_list[j][i].reference & 3);\n        ref2frm[18 + 0] =\n        ref2frm[18 + 1] = -1;\n        for (i = 16; i < 48; i++)\n            ref2frm[i + 4] = 4 * id_list[(i - 16) >> 1] +\n                             (h->ref_list[j][i].reference & 3);\n    }\n    if (h->ref_count[0]) h->er.last_pic = &h->ref_list[0][0];\n    if (h->ref_count[1]) h->er.next_pic = &h->ref_list[1][0];\n    h->er.ref_count = h->ref_count[0];\n    if (h->avctx->debug & FF_DEBUG_PICT_INFO) {\n        av_log(h->avctx, AV_LOG_DEBUG,\n               \"slice:%d %s mb:%d %c%s%s pps:%u frame:%d poc:%d\/%d ref:%d\/%d qp:%d loop:%d:%d:%d weight:%d%s %s\\n\",\n               h->slice_num,\n               (h->picture_structure == PICT_FRAME ? \"F\" : h->picture_structure == PICT_TOP_FIELD ? \"T\" : \"B\"),\n               first_mb_in_slice,\n               av_get_picture_type_char(h->slice_type),\n               h->slice_type_fixed ? \" fix\" : \"\",\n               h->nal_unit_type == NAL_IDR_SLICE ? \" IDR\" : \"\",\n               pps_id, h->frame_num,\n               h->cur_pic_ptr->field_poc[0],\n               h->cur_pic_ptr->field_poc[1],\n               h->ref_count[0], h->ref_count[1],\n               h->qscale,\n               h->deblocking_filter,\n               h->slice_alpha_c0_offset \/ 2 - 26, h->slice_beta_offset \/ 2 - 26,\n               h->use_weight,\n               h->use_weight == 1 && h->use_weight_chroma ? \"c\" : \"\",\n               h->slice_type == AV_PICTURE_TYPE_B ? (h->direct_spatial_mv_pred ? \"SPAT\" : \"TEMP\") : \"\");\n    }\n    return 0;\n}\n",
    "vul":1,
    "flaw_line_no":[
      213,
      218,
      224
    ],
    "bigvul_id":179104
  },
  {
    "code":"int __init register_tracer(struct tracer *type)\n{\n  struct tracer *t;\n  int ret = 0;\n  if (!type->name) {\n    pr_info(\"Tracer must have a name\\n\");\n    return -1;\n  }\n  if (strlen(type->name) >= MAX_TRACER_SIZE) {\n    pr_info(\"Tracer has a name longer than %d\\n\", MAX_TRACER_SIZE);\n    return -1;\n  }\n  mutex_lock(&trace_types_lock);\n  tracing_selftest_running = true;\n  for (t = trace_types; t; t = t->next) {\n    if (strcmp(type->name, t->name) == 0) {\n      pr_info(\"Tracer %s already registered\\n\",\n        type->name);\n      ret = -1;\n      goto out;\n    }\n  }\n  if (!type->set_flag)\n    type->set_flag = &dummy_set_flag;\n  if (!type->flags) {\n    type->flags = kmalloc(sizeof(*type->flags), GFP_KERNEL);\n    if (!type->flags) {\n      ret = -ENOMEM;\n      goto out;\n    }\n    type->flags->val = 0;\n    type->flags->opts = dummy_tracer_opt;\n  } else\n    if (!type->flags->opts)\n      type->flags->opts = dummy_tracer_opt;\n  type->flags->trace = type;\n  ret = run_tracer_selftest(type);\n  if (ret < 0)\n    goto out;\n  type->next = trace_types;\n  trace_types = type;\n  add_tracer_options(&global_trace, type);\n out:\n  tracing_selftest_running = false;\n  mutex_unlock(&trace_types_lock);\n  if (ret || !default_bootup_tracer)\n    goto out_unlock;\n  if (strncmp(default_bootup_tracer, type->name, MAX_TRACER_SIZE))\n    goto out_unlock;\n  printk(KERN_INFO \"Starting tracer '%s'\\n\", type->name);\n  tracing_set_tracer(&global_trace, type->name);\n  default_bootup_tracer = NULL;\n  apply_trace_boot_options();\n  tracing_selftest_disabled = true;\n#ifdef CONFIG_FTRACE_STARTUP_TEST\n  printk(KERN_INFO \"Disabling FTRACE selftests due to running tracer '%s'\\n\",\n         type->name);\n#endif\n out_unlock:\n  return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":81322
  },
  {
    "code":"data_sock_release(struct socket *sock)\n{\n  struct sock *sk = sock->sk;\n  if (*debug & DEBUG_SOCKET)\n    printk(KERN_DEBUG \"%s(%p) sk=%p\\n\", __func__, sock, sk);\n  if (!sk)\n    return 0;\n  switch (sk->sk_protocol) {\n  case ISDN_P_TE_S0:\n  case ISDN_P_NT_S0:\n  case ISDN_P_TE_E1:\n  case ISDN_P_NT_E1:\n    if (sk->sk_state == MISDN_BOUND)\n      delete_channel(&_pms(sk)->ch);\n    else\n      mISDN_sock_unlink(&data_sockets, sk);\n    break;\n  case ISDN_P_LAPD_TE:\n  case ISDN_P_LAPD_NT:\n  case ISDN_P_B_RAW:\n  case ISDN_P_B_HDLC:\n  case ISDN_P_B_X75SLP:\n  case ISDN_P_B_L2DTMF:\n  case ISDN_P_B_L2DSP:\n  case ISDN_P_B_L2DSPHDLC:\n    delete_channel(&_pms(sk)->ch);\n    mISDN_sock_unlink(&data_sockets, sk);\n    break;\n  }\n  lock_sock(sk);\n  sock_orphan(sk);\n  skb_queue_purge(&sk->sk_receive_queue);\n  release_sock(sk);\n  sock_put(sk);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":40255
  },
  {
    "code":"static MagickBooleanType ReadPSDMergedImage(const ImageInfo *image_info,\n  Image* image,const PSDInfo* psd_info,ExceptionInfo *exception)\n{\n  MagickOffsetType\n    *sizes;\n  MagickBooleanType\n    status;\n  PSDCompressionType\n    compression;\n  register ssize_t\n    i;\n  compression=(PSDCompressionType) ReadBlobMSBShort(image);\n  image->compression=ConvertPSDCompression(compression);\n  if (compression != Raw && compression != RLE)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        TypeWarning,\"CompressionNotSupported\",\"'%.20g'\",(double) compression);\n      return(MagickFalse);\n    }\n  sizes=(MagickOffsetType *) NULL;\n  if (compression == RLE)\n    {\n      sizes=ReadPSDRLESizes(image,psd_info,image->rows*psd_info->channels);\n      if (sizes == (MagickOffsetType *) NULL)\n        ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n          image->filename);\n    }\n  status=MagickTrue;\n  for (i=0; i < (ssize_t) psd_info->channels; i++)\n  {\n    if (compression == RLE)\n      status=ReadPSDChannelRLE(image,psd_info,i,sizes+(i*image->rows),\n        exception);\n    else\n      status=ReadPSDChannelRaw(image,psd_info->channels,i,exception);\n    if (status != MagickFalse)\n      status=SetImageProgress(image,LoadImagesTag,i,psd_info->channels);\n    if (status == MagickFalse)\n      break;\n  }\n  if ((status != MagickFalse) && (image->colorspace == CMYKColorspace))\n    status=NegateImage(image,MagickFalse);\n  if (status != MagickFalse)\n    status=CorrectPSDAlphaBlend(image_info,image,exception);\n  sizes=(MagickOffsetType *) RelinquishMagickMemory(sizes);\n  return(status);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":61519
  },
  {
    "code":"bool RenderFrameHostImpl::CreateRenderFrame(int proxy_routing_id,\n                                            int opener_routing_id,\n                                            int parent_routing_id,\n                                            int previous_sibling_routing_id) {\n  TRACE_EVENT0(\"navigation\", \"RenderFrameHostImpl::CreateRenderFrame\");\n  DCHECK(!IsRenderFrameLive()) << \"Creating frame twice\";\n  if (!GetProcess()->Init())\n    return false;\n  DCHECK(GetProcess()->IsInitializedAndNotDead());\n  service_manager::mojom::InterfaceProviderPtr interface_provider;\n  BindInterfaceProviderRequest(mojo::MakeRequest(&interface_provider));\n  blink::mojom::DocumentInterfaceBrokerPtrInfo\n      document_interface_broker_content_info;\n  blink::mojom::DocumentInterfaceBrokerPtrInfo\n      document_interface_broker_blink_info;\n  BindDocumentInterfaceBrokerRequest(\n      mojo::MakeRequest(&document_interface_broker_content_info),\n      mojo::MakeRequest(&document_interface_broker_blink_info));\n  mojom::CreateFrameParamsPtr params = mojom::CreateFrameParams::New();\n  params->interface_bundle = mojom::DocumentScopedInterfaceBundle::New(\n      interface_provider.PassInterface(),\n      std::move(document_interface_broker_content_info),\n      std::move(document_interface_broker_blink_info));\n  params->routing_id = routing_id_;\n  params->proxy_routing_id = proxy_routing_id;\n  params->opener_routing_id = opener_routing_id;\n  params->parent_routing_id = parent_routing_id;\n  params->previous_sibling_routing_id = previous_sibling_routing_id;\n  params->replication_state = frame_tree_node()->current_replication_state();\n  params->devtools_frame_token = frame_tree_node()->devtools_frame_token();\n  params->replication_state.frame_policy =\n      frame_tree_node()->pending_frame_policy();\n  params->frame_owner_properties =\n      FrameOwnerProperties(frame_tree_node()->frame_owner_properties());\n  params->has_committed_real_load =\n      frame_tree_node()->has_committed_real_load();\n  params->widget_params = mojom::CreateFrameWidgetParams::New();\n  if (render_widget_host_) {\n    params->widget_params->routing_id = render_widget_host_->GetRoutingID();\n    params->widget_params->hidden = render_widget_host_->is_hidden();\n  } else {\n    params->widget_params->routing_id = MSG_ROUTING_NONE;\n    params->widget_params->hidden = true;\n  }\n  GetProcess()->GetRendererInterface()->CreateFrame(std::move(params));\n  if (parent_routing_id != MSG_ROUTING_NONE && render_widget_host_) {\n    RenderWidgetHostView* rwhv =\n        RenderWidgetHostViewChildFrame::Create(render_widget_host_);\n    rwhv->Hide();\n  }\n  if (proxy_routing_id != MSG_ROUTING_NONE) {\n    RenderFrameProxyHost* proxy = RenderFrameProxyHost::FromID(\n        GetProcess()->GetID(), proxy_routing_id);\n    proxy->set_render_frame_proxy_created(true);\n  }\n  SetRenderFrameCreated(true);\n  return true;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":164686
  },
  {
    "code":"static jobject android_net_wifi_get_tdls_status(JNIEnv *env,jclass cls, jint iface,jstring addr) {\n JNIHelper helper(env);\n    wifi_interface_handle handle = getIfaceHandle(helper, cls, iface);\n    mac_addr address;\n    parseMacAddress(env, addr, address);\n    wifi_tdls_status status;\n    wifi_error ret;\n    ret = hal_fn.wifi_get_tdls_status(handle, address, &status );\n if (ret != WIFI_SUCCESS) {\n return NULL;\n } else {\n JNIObject<jobject> tdls_status = helper.createObject(\n \"com\/android\/server\/wifi\/WifiNative$TdlsStatus\");\n        helper.setIntField(tdls_status, \"channel\", status.channel);\n        helper.setIntField(tdls_status, \"global_operating_class\", status.global_operating_class);\n        helper.setIntField(tdls_status, \"state\", status.state);\n        helper.setIntField(tdls_status, \"reason\", status.reason);\n return tdls_status.detach();\n }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":172258
  },
  {
    "code":"void LocalFrame::RemoveSpellingMarkersUnderWords(const Vector<String>& words) {\n  GetSpellChecker().RemoveSpellingMarkersUnderWords(words);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":167965
  },
  {
    "code":"static int nfs4_proc_remove(struct inode *dir, struct qstr *name)\n{\n  struct nfs4_exception exception = { };\n  int err;\n  do {\n    err = nfs4_handle_exception(NFS_SERVER(dir),\n        _nfs4_proc_remove(dir, name),\n        &exception);\n  } while (exception.retry);\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":19986
  },
  {
    "code":"rb_wakeups(struct ring_buffer *buffer, struct ring_buffer_per_cpu *cpu_buffer)\n{\n  bool pagebusy;\n  if (buffer->irq_work.waiters_pending) {\n    buffer->irq_work.waiters_pending = false;\n    irq_work_queue(&buffer->irq_work.work);\n  }\n  if (cpu_buffer->irq_work.waiters_pending) {\n    cpu_buffer->irq_work.waiters_pending = false;\n    irq_work_queue(&cpu_buffer->irq_work.work);\n  }\n  pagebusy = cpu_buffer->reader_page == cpu_buffer->commit_page;\n  if (!pagebusy && cpu_buffer->irq_work.full_waiters_pending) {\n    cpu_buffer->irq_work.wakeup_full = true;\n    cpu_buffer->irq_work.full_waiters_pending = false;\n    irq_work_queue(&cpu_buffer->irq_work.work);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":72588
  },
  {
    "code":"static int req_crit(lua_State *L)\n{\n    return req_log_at(L, APLOG_CRIT);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":45126
  },
  {
    "code":"void dev_remove_pack(struct packet_type *pt)\n{\n  __dev_remove_pack(pt);\n  synchronize_net();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":32138
  },
  {
    "code":"CreateDownloadURLLoaderFactoryGetter(StoragePartitionImpl* storage_partition,\n                                     RenderFrameHost* rfh,\n                                     bool is_download) {\n  network::mojom::URLLoaderFactoryPtrInfo proxy_factory_ptr_info;\n  network::mojom::URLLoaderFactoryRequest proxy_factory_request;\n  if (rfh) {\n    bool should_proxy = false;\n    network::mojom::URLLoaderFactoryPtrInfo maybe_proxy_factory_ptr_info;\n    network::mojom::URLLoaderFactoryRequest maybe_proxy_factory_request =\n        MakeRequest(&maybe_proxy_factory_ptr_info);\n    should_proxy = devtools_instrumentation::WillCreateURLLoaderFactory(\n        static_cast<RenderFrameHostImpl*>(rfh), true, is_download,\n        &maybe_proxy_factory_request);\n    should_proxy |= GetContentClient()->browser()->WillCreateURLLoaderFactory(\n        rfh->GetSiteInstance()->GetBrowserContext(), rfh,\n        rfh->GetProcess()->GetID(), false ,\n        true , url::Origin(), &maybe_proxy_factory_request,\n        nullptr , nullptr );\n    if (should_proxy) {\n      proxy_factory_ptr_info = std::move(maybe_proxy_factory_ptr_info);\n      proxy_factory_request = std::move(maybe_proxy_factory_request);\n    }\n  }\n  return base::MakeRefCounted<NetworkDownloadURLLoaderFactoryGetter>(\n      storage_partition->url_loader_factory_getter(),\n      std::move(proxy_factory_ptr_info), std::move(proxy_factory_request));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":164018
  },
  {
    "code":"mm_auth2_read_banner(void)\n{\n  Buffer m;\n  char *banner;\n  debug3(\"%s entering\", __func__);\n  buffer_init(&m);\n  mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_AUTH2_READ_BANNER, &m);\n  buffer_clear(&m);\n  mm_request_receive_expect(pmonitor->m_recvfd,\n      MONITOR_ANS_AUTH2_READ_BANNER, &m);\n  banner = buffer_get_string(&m, NULL);\n  buffer_free(&m);\n  if (strlen(banner) == 0) {\n    free(banner);\n    banner = NULL;\n  }\n  return (banner);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":42137
  },
  {
    "code":"    int stopLoadingCount() const { return m_stopLoadingCount; }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":119543
  },
  {
    "code":"nfs4_find_slot(struct nfs4_slot_table *tbl)\n{\n  u32 slotid;\n  u32 ret_id = NFS4_NO_SLOT;\n  dprintk(\"--> %s used_slots=%04lx highest_used=%u max_slots=%u\\n\",\n    __func__, tbl->used_slots[0], tbl->highest_used_slotid,\n    tbl->max_slots);\n  slotid = find_first_zero_bit(tbl->used_slots, tbl->max_slots);\n  if (slotid >= tbl->max_slots)\n    goto out;\n  __set_bit(slotid, tbl->used_slots);\n  if (slotid > tbl->highest_used_slotid ||\n      tbl->highest_used_slotid == NFS4_NO_SLOT)\n    tbl->highest_used_slotid = slotid;\n  ret_id = slotid;\nout:\n  dprintk(\"<-- %s used_slots=%04lx highest_used=%d slotid=%d \\n\",\n    __func__, tbl->used_slots[0], tbl->highest_used_slotid, ret_id);\n  return ret_id;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":19906
  },
  {
    "code":"static HB_Error  Load_LigatureArray( HB_LigatureArray*  la,\n             HB_UShort           num_classes,\n             HB_Stream           stream )\n{\n  HB_Error  error;\n  HB_UShort            n, m, count;\n  HB_UInt             cur_offset, new_offset, base_offset;\n  HB_LigatureAttach*  lat;\n  base_offset = FILE_Pos();\n  if ( ACCESS_Frame( 2L ) )\n    return error;\n  count = la->LigatureCount = GET_UShort();\n  FORGET_Frame();\n  la->LigatureAttach = NULL;\n  if ( ALLOC_ARRAY( la->LigatureAttach, count, HB_LigatureAttach ) )\n    return error;\n  lat = la->LigatureAttach;\n  for ( n = 0; n < count; n++ )\n  {\n    if ( ACCESS_Frame( 2L ) )\n      goto Fail;\n    new_offset = GET_UShort() + base_offset;\n    FORGET_Frame();\n    cur_offset = FILE_Pos();\n    if ( FILE_Seek( new_offset ) ||\n   ( error = Load_LigatureAttach( &lat[n], num_classes,\n          stream ) ) != HB_Err_Ok )\n      goto Fail;\n    (void)FILE_Seek( cur_offset );\n  }\n  return HB_Err_Ok;\nFail:\n  for ( m = 0; m < n; m++ )\n    Free_LigatureAttach( &lat[m], num_classes );\n  FREE( lat );\n  return error;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":13580
  },
  {
    "code":"dtls1_process_record(SSL *s)\n{\n  int i,al;\n  int enc_err;\n  SSL_SESSION *sess;\n  SSL3_RECORD *rr;\n  unsigned int mac_size;\n  unsigned char md[EVP_MAX_MD_SIZE];\n  rr= &(s->s3->rrec);\n  sess = s->session;\n  rr->input= &(s->packet[DTLS1_RT_HEADER_LENGTH]);\n  if (rr->length > SSL3_RT_MAX_ENCRYPTED_LENGTH)\n    {\n    al=SSL_AD_RECORD_OVERFLOW;\n    SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_ENCRYPTED_LENGTH_TOO_LONG);\n    goto f_err;\n    }\n  rr->data=rr->input;\n  rr->orig_len=rr->length;\n  enc_err = s->method->ssl3_enc->enc(s,0);\n  if (enc_err == 0)\n    {\n    rr->length = 0;\n    s->packet_length = 0;\n    goto err;\n    }\n#ifdef TLS_DEBUG\nprintf(\"dec %d\\n\",rr->length);\n{ unsigned int z; for (z=0; z<rr->length; z++) printf(\"%02X%c\",rr->data[z],((z+1)%16)?' ':'\\n'); }\nprintf(\"\\n\");\n#endif\n  if ((sess != NULL) &&\n      (s->enc_read_ctx != NULL) &&\n      (EVP_MD_CTX_md(s->read_hash) != NULL))\n    {\n    unsigned char *mac = NULL;\n    unsigned char mac_tmp[EVP_MAX_MD_SIZE];\n    mac_size=EVP_MD_CTX_size(s->read_hash);\n    OPENSSL_assert(mac_size <= EVP_MAX_MD_SIZE);\n    if (rr->orig_len < mac_size ||\n        (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE &&\n         rr->orig_len < mac_size+1))\n      {\n      al=SSL_AD_DECODE_ERROR;\n      SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_LENGTH_TOO_SHORT);\n      goto f_err;\n      }\n    if (EVP_CIPHER_CTX_mode(s->enc_read_ctx) == EVP_CIPH_CBC_MODE)\n      {\n      mac = mac_tmp;\n      ssl3_cbc_copy_mac(mac_tmp, rr, mac_size);\n      rr->length -= mac_size;\n      }\n    else\n      {\n      rr->length -= mac_size;\n      mac = &rr->data[rr->length];\n      }\n    i=s->method->ssl3_enc->mac(s,md,0 );\n    if (i < 0 || mac == NULL || CRYPTO_memcmp(md, mac, (size_t)mac_size) != 0)\n      enc_err = -1;\n    if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH+mac_size)\n      enc_err = -1;\n    }\n  if (enc_err < 0)\n    {\n    rr->length = 0;\n    s->packet_length = 0;\n    goto err;\n    }\n  if (s->expand != NULL)\n    {\n    if (rr->length > SSL3_RT_MAX_COMPRESSED_LENGTH)\n      {\n      al=SSL_AD_RECORD_OVERFLOW;\n      SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_COMPRESSED_LENGTH_TOO_LONG);\n      goto f_err;\n      }\n    if (!ssl3_do_uncompress(s))\n      {\n      al=SSL_AD_DECOMPRESSION_FAILURE;\n      SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_BAD_DECOMPRESSION);\n      goto f_err;\n      }\n    }\n  if (rr->length > SSL3_RT_MAX_PLAIN_LENGTH)\n    {\n    al=SSL_AD_RECORD_OVERFLOW;\n    SSLerr(SSL_F_DTLS1_PROCESS_RECORD,SSL_R_DATA_LENGTH_TOO_LONG);\n    goto f_err;\n    }\n  rr->off=0;\n  s->packet_length=0;\n  dtls1_record_bitmap_update(s, &(s->d1->bitmap));\n  return(1);\nf_err:\n  ssl3_send_alert(s,SSL3_AL_FATAL,al);\nerr:\n  return(0);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":46481
  },
  {
    "code":"void RenderFrameHostImpl::Create(\n    const service_manager::Identity& remote_identity,\n    media::mojom::InterfaceFactoryRequest request) {\n  DCHECK(!media_interface_proxy_);\n  media_interface_proxy_.reset(new MediaInterfaceProxy(\n      this, std::move(request),\n      base::Bind(&RenderFrameHostImpl::OnMediaInterfaceFactoryConnectionError,\n                 base::Unretained(this))));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":138653
  },
  {
    "code":"void omx_video::complete_pending_buffer_done_cbs()\n{\n unsigned long p1;\n unsigned long p2;\n unsigned long ident;\n    omx_cmd_queue tmp_q, pending_bd_q;\n    pthread_mutex_lock(&m_lock);\n while (m_ftb_q.m_size) {\n        m_ftb_q.pop_entry(&p1,&p2,&ident);\n if (ident == OMX_COMPONENT_GENERATE_FBD) {\n            pending_bd_q.insert_entry(p1,p2,ident);\n } else {\n            tmp_q.insert_entry(p1,p2,ident);\n }\n }\n while (tmp_q.m_size) {\n        tmp_q.pop_entry(&p1,&p2,&ident);\n        m_ftb_q.insert_entry(p1,p2,ident);\n }\n while (m_etb_q.m_size) {\n        m_etb_q.pop_entry(&p1,&p2,&ident);\n if (ident == OMX_COMPONENT_GENERATE_EBD) {\n            pending_bd_q.insert_entry(p1,p2,ident);\n } else {\n            tmp_q.insert_entry(p1,p2,ident);\n }\n }\n while (tmp_q.m_size) {\n        tmp_q.pop_entry(&p1,&p2,&ident);\n        m_etb_q.insert_entry(p1,p2,ident);\n }\n    pthread_mutex_unlock(&m_lock);\n while (pending_bd_q.m_size) {\n        pending_bd_q.pop_entry(&p1,&p2,&ident);\n switch (ident) {\n case OMX_COMPONENT_GENERATE_EBD:\n if (empty_buffer_done(&m_cmp, (OMX_BUFFERHEADERTYPE *)p1) != OMX_ErrorNone) {\n                    DEBUG_PRINT_ERROR(\"ERROR: empty_buffer_done() failed!\");\n                    omx_report_error ();\n }\n break;\n case OMX_COMPONENT_GENERATE_FBD:\n if (fill_buffer_done(&m_cmp, (OMX_BUFFERHEADERTYPE *)p1) != OMX_ErrorNone ) {\n                    DEBUG_PRINT_ERROR(\"ERROR: fill_buffer_done() failed!\");\n                    omx_report_error ();\n }\n break;\n }\n }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":172328
  },
  {
    "code":"void group_pin_kill(struct hlist_head *p)\n{\n  while (1) {\n    struct hlist_node *q;\n    rcu_read_lock();\n    q = ACCESS_ONCE(p->first);\n    if (!q) {\n      rcu_read_unlock();\n      break;\n    }\n    pin_kill(hlist_entry(q, struct fs_pin, s_list));\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":57812
  },
  {
    "code":"  static void  Ins_RTDG( INS_ARG )\n  { (void)args;\n    CUR.GS.round_state = TT_Round_To_Double_Grid;\n    CUR.func_round = (TRound_Function)Round_To_Double_Grid;\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":5434
  },
  {
    "code":"DownloadFileFactory* DownloadManagerImpl::GetDownloadFileFactoryForTesting() {\n  return file_factory_.get();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":159249
  },
  {
    "code":"void DocumentLoader::ResetSourceLocation() {\n  source_location_ = nullptr;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":156912
  },
  {
    "code":"bool HTMLInputElement::IsSteppable() const {\n  return input_type_->IsSteppable();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":136920
  },
  {
    "code":"static void sas_eh_handle_sas_errors(struct Scsi_Host *shost, struct list_head *work_q)\n{\n  struct scsi_cmnd *cmd, *n;\n  enum task_disposition res = TASK_IS_DONE;\n  int tmf_resp, need_reset;\n  struct sas_internal *i = to_sas_internal(shost->transportt);\n  unsigned long flags;\n  struct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);\n  LIST_HEAD(done);\n  list_for_each_entry_safe(cmd, n, work_q, eh_entry) {\n    struct domain_device *dev = cmd_to_domain_dev(cmd);\n    struct sas_task *task;\n    spin_lock_irqsave(&dev->done_lock, flags);\n    task = TO_SAS_TASK(cmd);\n    spin_unlock_irqrestore(&dev->done_lock, flags);\n    if (!task)\n      list_move_tail(&cmd->eh_entry, &done);\n  }\n Again:\n  list_for_each_entry_safe(cmd, n, work_q, eh_entry) {\n    struct sas_task *task = TO_SAS_TASK(cmd);\n    list_del_init(&cmd->eh_entry);\n    spin_lock_irqsave(&task->task_state_lock, flags);\n    need_reset = task->task_state_flags & SAS_TASK_NEED_DEV_RESET;\n    spin_unlock_irqrestore(&task->task_state_lock, flags);\n    if (need_reset) {\n      SAS_DPRINTK(\"%s: task 0x%p requests reset\\n\",\n            __func__, task);\n      goto reset;\n    }\n    SAS_DPRINTK(\"trying to find task 0x%p\\n\", task);\n    res = sas_scsi_find_task(task);\n    switch (res) {\n     case TASK_IS_DONE:\n       SAS_DPRINTK(\"%s: task 0x%p is done\\n\", __func__,\n             task);\n      sas_eh_defer_cmd(cmd);\n       continue;\n     case TASK_IS_ABORTED:\n       SAS_DPRINTK(\"%s: task 0x%p is aborted\\n\",\n             __func__, task);\n      sas_eh_defer_cmd(cmd);\n       continue;\n     case TASK_IS_AT_LU:\n       SAS_DPRINTK(\"task 0x%p is at LU: lu recover\\n\", task);\n reset:\n      tmf_resp = sas_recover_lu(task->dev, cmd);\n      if (tmf_resp == TMF_RESP_FUNC_COMPLETE) {\n        SAS_DPRINTK(\"dev %016llx LU %llx is \"\n               \"recovered\\n\",\n               SAS_ADDR(task->dev),\n               cmd->device->lun);\n        sas_eh_defer_cmd(cmd);\n         sas_scsi_clear_queue_lu(work_q, cmd);\n         goto Again;\n       }\n    case TASK_IS_NOT_AT_LU:\n    case TASK_ABORT_FAILED:\n      SAS_DPRINTK(\"task 0x%p is not at LU: I_T recover\\n\",\n            task);\n      tmf_resp = sas_recover_I_T(task->dev);\n      if (tmf_resp == TMF_RESP_FUNC_COMPLETE ||\n          tmf_resp == -ENODEV) {\n        struct domain_device *dev = task->dev;\n        SAS_DPRINTK(\"I_T %016llx recovered\\n\",\n              SAS_ADDR(task->dev->sas_addr));\n        sas_eh_finish_cmd(cmd);\n        sas_scsi_clear_queue_I_T(work_q, dev);\n        goto Again;\n      }\n      try_to_reset_cmd_device(cmd);\n      if (i->dft->lldd_clear_nexus_port) {\n        struct asd_sas_port *port = task->dev->port;\n        SAS_DPRINTK(\"clearing nexus for port:%d\\n\",\n              port->id);\n        res = i->dft->lldd_clear_nexus_port(port);\n        if (res == TMF_RESP_FUNC_COMPLETE) {\n          SAS_DPRINTK(\"clear nexus port:%d \"\n                \"succeeded\\n\", port->id);\n          sas_eh_finish_cmd(cmd);\n          sas_scsi_clear_queue_port(work_q,\n                  port);\n          goto Again;\n        }\n      }\n      if (i->dft->lldd_clear_nexus_ha) {\n        SAS_DPRINTK(\"clear nexus ha\\n\");\n        res = i->dft->lldd_clear_nexus_ha(ha);\n        if (res == TMF_RESP_FUNC_COMPLETE) {\n          SAS_DPRINTK(\"clear nexus ha \"\n                \"succeeded\\n\");\n          sas_eh_finish_cmd(cmd);\n          goto clear_q;\n        }\n      }\n      SAS_DPRINTK(\"error from  device %llx, LUN %llx \"\n            \"couldn't be recovered in any way\\n\",\n            SAS_ADDR(task->dev->sas_addr),\n            cmd->device->lun);\n      sas_eh_finish_cmd(cmd);\n      goto clear_q;\n    }\n  }\n out:\n  list_splice_tail(&done, work_q);\n  list_splice_tail_init(&ha->eh_ata_q, work_q);\n  return;\n clear_q:\n  SAS_DPRINTK(\"--- Exit %s -- clear_q\\n\", __func__);\n  list_for_each_entry_safe(cmd, n, work_q, eh_entry)\n    sas_eh_finish_cmd(cmd);\n  goto out;\n}\n",
    "vul":1,
    "flaw_line_no":[
      37,
      42,
      53
    ],
    "bigvul_id":182434
  },
  {
    "code":"static int panic_op_read_handler(char *buffer, const struct kernel_param *kp)\n{\n  switch (ipmi_send_panic_event) {\n  case IPMI_SEND_PANIC_EVENT_NONE:\n    strcpy(buffer, \"none\");\n    break;\n  case IPMI_SEND_PANIC_EVENT:\n    strcpy(buffer, \"event\");\n    break;\n  case IPMI_SEND_PANIC_EVENT_STRING:\n    strcpy(buffer, \"string\");\n    break;\n  default:\n    strcpy(buffer, \"???\");\n    break;\n  }\n  return strlen(buffer);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":91310
  },
  {
    "code":"void LaunchUrlWithoutSecurityCheckWithDelegate(\n    const GURL& url,\n    int render_process_host_id,\n    int render_view_routing_id,\n    ExternalProtocolHandler::Delegate* delegate) {\n  content::WebContents* web_contents = tab_util::GetWebContentsByID(\n      render_process_host_id, render_view_routing_id);\n  if (delegate) {\n    delegate->LaunchUrlWithoutSecurityCheck(url, web_contents);\n    return;\n  }\n  ExternalProtocolHandler::LaunchUrlWithoutSecurityCheck(url, web_contents);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":159687
  },
  {
    "code":"static void sig_server_reconnect_save_status(IRC_SERVER_CONNECT_REC *conn,\n               IRC_SERVER_REC *server)\n{\n  if (!IS_IRC_SERVER_CONNECT(conn) || !IS_IRC_SERVER(server) ||\n      !server->connected)\n    return;\n  g_free_not_null(conn->channels);\n  conn->channels = irc_server_get_channels(server);\n  g_free_not_null(conn->usermode);\n  conn->usermode = g_strdup(server->wanted_usermode);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":89417
  },
  {
    "code":"ModuleExport void UnregisterTIFFImage(void)\n{\n  (void) UnregisterMagickInfo(\"TIFF64\");\n  (void) UnregisterMagickInfo(\"TIFF\");\n  (void) UnregisterMagickInfo(\"TIF\");\n  (void) UnregisterMagickInfo(\"PTIF\");\n  if (tiff_semaphore == (SemaphoreInfo *) NULL)\n    ActivateSemaphoreInfo(&tiff_semaphore);\n  LockSemaphoreInfo(tiff_semaphore);\n  if (instantiate_key != MagickFalse)\n    {\n      if (MagickDeleteThreadKey(tiff_exception) == MagickFalse)\n        ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n#if defined(MAGICKCORE_HAVE_TIFFMERGEFIELDINFO) && defined(MAGICKCORE_HAVE_TIFFSETTAGEXTENDER)\n      if (tag_extender == (TIFFExtendProc) NULL)\n        (void) TIFFSetTagExtender(tag_extender);\n#endif\n      instantiate_key=MagickFalse;\n    }\n  UnlockSemaphoreInfo(tiff_semaphore);\n  DestroySemaphoreInfo(&tiff_semaphore);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":71761
  },
  {
    "code":"ikev1_print(netdissect_options *ndo,\n      const u_char *bp,  u_int length,\n      const u_char *bp2, struct isakmp *base)\n{\n  const struct isakmp *p;\n  const u_char *ep;\n  u_char np;\n  int i;\n  int phase;\n  p = (const struct isakmp *)bp;\n  ep = ndo->ndo_snapend;\n  phase = (EXTRACT_32BITS(base->msgid) == 0) ? 1 : 2;\n  if (phase == 1)\n    ND_PRINT((ndo,\" phase %d\", phase));\n  else\n    ND_PRINT((ndo,\" phase %d\/others\", phase));\n  i = cookie_find(&base->i_ck);\n  if (i < 0) {\n    if (iszero((const u_char *)&base->r_ck, sizeof(base->r_ck))) {\n      ND_PRINT((ndo,\" I\"));\n      if (bp2)\n        cookie_record(&base->i_ck, bp2);\n    } else\n      ND_PRINT((ndo,\" ?\"));\n  } else {\n    if (bp2 && cookie_isinitiator(i, bp2))\n      ND_PRINT((ndo,\" I\"));\n    else if (bp2 && cookie_isresponder(i, bp2))\n      ND_PRINT((ndo,\" R\"));\n    else\n      ND_PRINT((ndo,\" ?\"));\n  }\n  ND_PRINT((ndo,\" %s\", ETYPESTR(base->etype)));\n  if (base->flags) {\n    ND_PRINT((ndo,\"[%s%s]\", base->flags & ISAKMP_FLAG_E ? \"E\" : \"\",\n        base->flags & ISAKMP_FLAG_C ? \"C\" : \"\"));\n  }\n  if (ndo->ndo_vflag) {\n    const struct isakmp_gen *ext;\n    ND_PRINT((ndo,\":\"));\n    if (base->flags & ISAKMP_FLAG_E) {\n      ND_PRINT((ndo,\" [encrypted %s]\", NPSTR(base->np)));\n      goto done;\n    }\n    CHECKLEN(p + 1, base->np);\n    np = base->np;\n    ext = (const struct isakmp_gen *)(p + 1);\n    ikev1_sub_print(ndo, np, ext, ep, phase, 0, 0, 0);\n  }\ndone:\n  if (ndo->ndo_vflag) {\n    if (ntohl(base->len) != length) {\n      ND_PRINT((ndo,\" (len mismatch: isakmp %u\/ip %u)\",\n          (uint32_t)ntohl(base->len), length));\n    }\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":61997
  },
  {
    "code":"void red_channel_client_pipe_add_after(RedChannelClient *rcc,\n                                       PipeItem *item, PipeItem *pos)\n{\n    spice_assert(rcc);\n    spice_assert(pos);\n    spice_assert(item);\n    rcc->pipe_size++;\n    ring_add_after(&item->link, &pos->link);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":2111
  },
  {
    "code":"String referrerPolicy(net::URLRequest::ReferrerPolicy referrer_policy) {\n  switch (referrer_policy) {\n    case net::URLRequest::CLEAR_REFERRER_ON_TRANSITION_FROM_SECURE_TO_INSECURE:\n      return Network::Request::ReferrerPolicyEnum::NoReferrerWhenDowngrade;\n    case net::URLRequest::\n        REDUCE_REFERRER_GRANULARITY_ON_TRANSITION_CROSS_ORIGIN:\n      return Network::Request::ReferrerPolicyEnum::StrictOriginWhenCrossOrigin;\n    case net::URLRequest::ORIGIN_ONLY_ON_TRANSITION_CROSS_ORIGIN:\n      return Network::Request::ReferrerPolicyEnum::OriginWhenCrossOrigin;\n    case net::URLRequest::NEVER_CLEAR_REFERRER:\n      return Network::Request::ReferrerPolicyEnum::Origin;\n    case net::URLRequest::ORIGIN:\n      return Network::Request::ReferrerPolicyEnum::Origin;\n    case net::URLRequest::NO_REFERRER:\n      return Network::Request::ReferrerPolicyEnum::NoReferrer;\n    default:\n      break;\n  }\n  NOTREACHED();\n  return Network::Request::ReferrerPolicyEnum::NoReferrerWhenDowngrade;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":161361
  },
  {
    "code":"bool GLES2Util::ComputeImagePaddedRowSize(int width,\n                                          int format,\n                                          int type,\n                                          int alignment,\n                                          uint32_t* padded_row_size) {\n  uint32_t bytes_per_group = ComputeImageGroupSize(format, type);\n  return ComputeImageRowSizeHelper(\n      width, bytes_per_group, alignment, nullptr, padded_row_size, nullptr);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":166370
  },
  {
    "code":"test_append_uri_pathel(void)\n{\n  unsigned i;\n  static const struct {\n    const char *original_url;\n    const char *input;\n    bool escaped;\n    const char *expected_result;\n  } test_array[] = {\n    { \"http:\n  };\n  for (i = 0; i < countof(test_array); ++i)\n    {\n      struct growable dest;\n      const char *p = test_array[i].input;\n      memset (&dest, 0, sizeof (dest));\n      append_string (test_array[i].original_url, &dest);\n      append_uri_pathel (p, p + strlen(p), test_array[i].escaped, &dest);\n      mu_assert (\"test_append_uri_pathel: wrong result\",\n                 strcmp (dest.base, test_array[i].expected_result) == 0);\n      xfree (dest.base);\n    }\n  return NULL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":8701
  },
  {
    "code":"void *address_space_map(AddressSpace *as,\n                        hwaddr addr,\n                        hwaddr *plen,\n                        bool is_write)\n{\n    hwaddr len = *plen;\n    hwaddr done = 0;\n    hwaddr l, xlat, base;\n    MemoryRegion *mr, *this_mr;\n    ram_addr_t raddr;\n    if (len == 0) {\n        return NULL;\n    }\n    l = len;\n    mr = address_space_translate(as, addr, &xlat, &l, is_write);\n    if (!memory_access_is_direct(mr, is_write)) {\n        if (atomic_xchg(&bounce.in_use, true)) {\n            return NULL;\n        }\n        l = MIN(l, TARGET_PAGE_SIZE);\n        bounce.buffer = qemu_memalign(TARGET_PAGE_SIZE, l);\n        bounce.addr = addr;\n        bounce.len = l;\n        memory_region_ref(mr);\n        bounce.mr = mr;\n        if (!is_write) {\n            address_space_read(as, addr, bounce.buffer, l);\n        }\n        *plen = l;\n        return bounce.buffer;\n    }\n    base = xlat;\n    raddr = memory_region_get_ram_addr(mr);\n    for (;;) {\n        len -= l;\n        addr += l;\n        done += l;\n        if (len == 0) {\n            break;\n        }\n        l = len;\n        this_mr = address_space_translate(as, addr, &xlat, &l, is_write);\n        if (this_mr != mr || xlat != base + done) {\n            break;\n        }\n    }\n    memory_region_ref(mr);\n    *plen = done;\n    return qemu_ram_ptr_length(raddr + base, plen);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":14315
  },
  {
    "code":"void CCThreadProxy::setNeedsRedraw()\n{\n    ASSERT(isMainThread());\n    TRACE_EVENT(\"CCThreadProxy::setNeedsRedraw\", this, 0);\n    s_ccThread->postTask(createCCThreadTask(this, &CCThreadProxy::setNeedsRedrawOnCCThread));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":102727
  },
  {
    "code":"RenderThreadImpl::GetAssociatedInterfaceRegistry() {\n  return &associated_interfaces_;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":163322
  },
  {
    "code":"HistogramBase* SparseHistogram::FactoryGet(const std::string& name,\n                                           int32_t flags) {\n  HistogramBase* histogram = StatisticsRecorder::FindHistogram(name);\n  if (!histogram) {\n    PersistentMemoryAllocator::Reference histogram_ref = 0;\n    std::unique_ptr<HistogramBase> tentative_histogram;\n    PersistentHistogramAllocator* allocator = GlobalHistogramAllocator::Get();\n    if (allocator) {\n      tentative_histogram = allocator->AllocateHistogram(\n          SPARSE_HISTOGRAM, name, 0, 0, nullptr, flags, &histogram_ref);\n    }\n    if (!tentative_histogram) {\n      DCHECK(!histogram_ref);  \n      DCHECK(!allocator);      \n      flags &= ~HistogramBase::kIsPersistent;\n      tentative_histogram.reset(new SparseHistogram(name));\n      tentative_histogram->SetFlags(flags);\n    }\n    const void* tentative_histogram_ptr = tentative_histogram.get();\n    histogram = StatisticsRecorder::RegisterOrDeleteDuplicate(\n        tentative_histogram.release());\n    if (histogram_ref) {\n      allocator->FinalizeHistogram(histogram_ref,\n                                   histogram == tentative_histogram_ptr);\n    }\n    ReportHistogramActivity(*histogram, HISTOGRAM_CREATED);\n  } else {\n     ReportHistogramActivity(*histogram, HISTOGRAM_LOOKUP);\n   }\n  DCHECK_EQ(SPARSE_HISTOGRAM, histogram->GetHistogramType());\n   return histogram;\n }\n",
    "vul":1,
    "flaw_line_no":[
      30
    ],
    "bigvul_id":186462
  },
  {
    "code":"gfx::ImageSkia* PushMessagingServiceImpl::GetIcon() {\n  return nullptr;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":163498
  },
  {
    "code":"static int handle_oem_get_msg_cmd(struct ipmi_smi *intf,\n          struct ipmi_smi_msg *msg)\n{\n  struct cmd_rcvr       *rcvr;\n  int                   rv = 0;\n  unsigned char         netfn;\n  unsigned char         cmd;\n  unsigned char         chan;\n  struct ipmi_user *user = NULL;\n  struct ipmi_system_interface_addr *smi_addr;\n  struct ipmi_recv_msg  *recv_msg;\n  if (msg->rsp_size < 4) {\n    ipmi_inc_stat(intf, invalid_commands);\n    return 0;\n  }\n  if (msg->rsp[2] != 0) {\n    return 0;\n  }\n  netfn = msg->rsp[0] >> 2;\n  cmd = msg->rsp[1];\n  chan = msg->rsp[3] & 0xf;\n  rcu_read_lock();\n  rcvr = find_cmd_rcvr(intf, netfn, cmd, chan);\n  if (rcvr) {\n    user = rcvr->user;\n    kref_get(&user->refcount);\n  } else\n    user = NULL;\n  rcu_read_unlock();\n  if (user == NULL) {\n    ipmi_inc_stat(intf, unhandled_commands);\n    rv = 0;\n  } else {\n    recv_msg = ipmi_alloc_recv_msg();\n    if (!recv_msg) {\n      rv = 1;\n      kref_put(&user->refcount, free_user);\n    } else {\n      smi_addr = ((struct ipmi_system_interface_addr *)\n            &recv_msg->addr);\n      smi_addr->addr_type = IPMI_SYSTEM_INTERFACE_ADDR_TYPE;\n      smi_addr->channel = IPMI_BMC_CHANNEL;\n      smi_addr->lun = msg->rsp[0] & 3;\n      recv_msg->user = user;\n      recv_msg->user_msg_data = NULL;\n      recv_msg->recv_type = IPMI_OEM_RECV_TYPE;\n      recv_msg->msg.netfn = msg->rsp[0] >> 2;\n      recv_msg->msg.cmd = msg->rsp[1];\n      recv_msg->msg.data = recv_msg->msg_data;\n      recv_msg->msg.data_len = msg->rsp_size - 4;\n      memcpy(recv_msg->msg_data, &msg->rsp[4],\n             msg->rsp_size - 4);\n      if (deliver_response(intf, recv_msg))\n        ipmi_inc_stat(intf, unhandled_commands);\n      else\n        ipmi_inc_stat(intf, handled_commands);\n    }\n  }\n  return rv;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":91248
  },
  {
    "code":"ptaaInitFull(PTAA  *ptaa,\n             PTA   *pta)\n{\nl_int32  n, i;\nPTA     *ptat;\n    PROCNAME(\"ptaaInitFull\");\n    if (!ptaa)\n        return ERROR_INT(\"ptaa not defined\", procName, 1);\n    if (!pta)\n        return ERROR_INT(\"pta not defined\", procName, 1);\n    n = ptaa->nalloc;\n    ptaa->n = n;\n    for (i = 0; i < n; i++) {\n        ptat = ptaCopy(pta);\n        ptaaReplacePta(ptaa, i, ptat);\n    }\n    return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":84193
  },
  {
    "code":"static int tun_set_iff(struct net *net, struct file *file, struct ifreq *ifr)\n{\n  struct sock *sk;\n  struct tun_struct *tun;\n  struct net_device *dev;\n  int err;\n  dev = __dev_get_by_name(net, ifr->ifr_name);\n  if (dev) {\n    const struct cred *cred = current_cred();\n    if (ifr->ifr_flags & IFF_TUN_EXCL)\n      return -EBUSY;\n    if ((ifr->ifr_flags & IFF_TUN) && dev->netdev_ops == &tun_netdev_ops)\n      tun = netdev_priv(dev);\n    else if ((ifr->ifr_flags & IFF_TAP) && dev->netdev_ops == &tap_netdev_ops)\n      tun = netdev_priv(dev);\n    else\n      return -EINVAL;\n    if (((tun->owner != -1 && cred->euid != tun->owner) ||\n         (tun->group != -1 && !in_egroup_p(tun->group))) &&\n        !capable(CAP_NET_ADMIN))\n      return -EPERM;\n    err = security_tun_dev_attach(tun->socket.sk);\n    if (err < 0)\n      return err;\n    err = tun_attach(tun, file);\n    if (err < 0)\n      return err;\n  }\n  else {\n    char *name;\n    unsigned long flags = 0;\n    if (!capable(CAP_NET_ADMIN))\n      return -EPERM;\n    err = security_tun_dev_create();\n    if (err < 0)\n      return err;\n    if (ifr->ifr_flags & IFF_TUN) {\n      flags |= TUN_TUN_DEV;\n      name = \"tun%d\";\n    } else if (ifr->ifr_flags & IFF_TAP) {\n      flags |= TUN_TAP_DEV;\n      name = \"tap%d\";\n    } else\n      return -EINVAL;\n    if (*ifr->ifr_name)\n      name = ifr->ifr_name;\n    dev = alloc_netdev(sizeof(struct tun_struct), name,\n           tun_setup);\n    if (!dev)\n      return -ENOMEM;\n    dev_net_set(dev, net);\n    dev->rtnl_link_ops = &tun_link_ops;\n    tun = netdev_priv(dev);\n    tun->dev = dev;\n    tun->flags = flags;\n    tun->txflt.count = 0;\n    tun->vnet_hdr_sz = sizeof(struct virtio_net_hdr);\n    set_bit(SOCK_EXTERNALLY_ALLOCATED, &tun->socket.flags);\n    err = -ENOMEM;\n    sk = sk_alloc(&init_net, AF_UNSPEC, GFP_KERNEL, &tun_proto);\n    if (!sk)\n      goto err_free_dev;\n    sk_change_net(sk, net);\n    tun->socket.wq = &tun->wq;\n    init_waitqueue_head(&tun->wq.wait);\n    tun->socket.ops = &tun_socket_ops;\n    sock_init_data(&tun->socket, sk);\n    sk->sk_write_space = tun_sock_write_space;\n    sk->sk_sndbuf = INT_MAX;\n    sock_set_flag(sk, SOCK_ZEROCOPY);\n    tun_sk(sk)->tun = tun;\n    security_tun_dev_post_create(sk);\n    tun_net_init(dev);\n    dev->hw_features = NETIF_F_SG | NETIF_F_FRAGLIST |\n      TUN_USER_FEATURES;\n    dev->features = dev->hw_features;\n    err = register_netdevice(tun->dev);\n    if (err < 0)\n      goto err_free_sk;\n    if (device_create_file(&tun->dev->dev, &dev_attr_tun_flags) ||\n        device_create_file(&tun->dev->dev, &dev_attr_owner) ||\n        device_create_file(&tun->dev->dev, &dev_attr_group))\n      pr_err(\"Failed to create tun sysfs files\\n\");\n    sk->sk_destruct = tun_sock_destruct;\n    err = tun_attach(tun, file);\n    if (err < 0)\n      goto failed;\n  }\n  tun_debug(KERN_INFO, tun, \"tun_set_iff\\n\");\n  if (ifr->ifr_flags & IFF_NO_PI)\n    tun->flags |= TUN_NO_PI;\n  else\n    tun->flags &= ~TUN_NO_PI;\n  if (ifr->ifr_flags & IFF_ONE_QUEUE)\n    tun->flags |= TUN_ONE_QUEUE;\n  else\n    tun->flags &= ~TUN_ONE_QUEUE;\n  if (ifr->ifr_flags & IFF_VNET_HDR)\n    tun->flags |= TUN_VNET_HDR;\n  else\n    tun->flags &= ~TUN_VNET_HDR;\n  if (netif_running(tun->dev))\n    netif_wake_queue(tun->dev);\n  strcpy(ifr->ifr_name, tun->dev->name);\n  return 0;\n err_free_sk:\n  tun_free_netdev(dev);\n err_free_dev:\n  free_netdev(dev);\n failed:\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":34103
  },
  {
    "code":"xmlXPathPopNumber (xmlXPathParserContextPtr ctxt) {\n    xmlXPathObjectPtr obj;\n    double ret;\n    obj = valuePop(ctxt);\n    if (obj == NULL) {\n  xmlXPathSetError(ctxt, XPATH_INVALID_OPERAND);\n  return(0);\n    }\n    if (obj->type != XPATH_NUMBER)\n  ret = xmlXPathCastToNumber(obj);\n    else\n        ret = obj->floatval;\n    xmlXPathReleaseObject(ctxt->context, obj);\n    return(ret);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":97766
  },
  {
    "code":"  bool IsTimerRunning() {\n    return GetLongPressTimer()->IsRunning();\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":120332
  },
  {
    "code":"bool ExtensionHelper::OnMessageReceived(const IPC::Message& message) {\n  bool handled = true;\n  IPC_BEGIN_MESSAGE_MAP(ExtensionHelper, message)\n    IPC_MESSAGE_HANDLER(ExtensionMsg_Response, OnExtensionResponse)\n    IPC_MESSAGE_HANDLER(ExtensionMsg_MessageInvoke, OnExtensionMessageInvoke)\n    IPC_MESSAGE_HANDLER(ExtensionMsg_DeliverMessage, OnExtensionDeliverMessage)\n    IPC_MESSAGE_HANDLER(ExtensionMsg_ExecuteCode, OnExecuteCode)\n    IPC_MESSAGE_HANDLER(ExtensionMsg_GetApplicationInfo, OnGetApplicationInfo)\n    IPC_MESSAGE_HANDLER(ExtensionMsg_UpdateBrowserWindowId,\n                        OnUpdateBrowserWindowId)\n    IPC_MESSAGE_HANDLER(ExtensionMsg_NotifyRenderViewType,\n                        OnNotifyRendererViewType)\n    IPC_MESSAGE_HANDLER(ExtensionMsg_InlineWebstoreInstallResponse,\n                        OnInlineWebstoreInstallResponse)\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP()\n  return handled;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":102368
  },
  {
    "code":"static int hwsim_fops_group_write(void *dat, u64 val)\n{\n  struct mac80211_hwsim_data *data = dat;\n  data->group = val;\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":83794
  },
  {
    "code":"WebContents* TabStripModel::GetOpenerOfWebContentsAt(int index) {\n  DCHECK(ContainsIndex(index));\n  return contents_data_[index]->opener;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":126631
  },
  {
    "code":"void red_channel_client_pipe_remove_and_release(RedChannelClient *rcc,\n                                                PipeItem *item)\n{\n    red_channel_client_pipe_remove(rcc, item);\n    red_channel_client_release_item(rcc, item, FALSE);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":2121
  },
  {
    "code":"static inline void evmcs_touch_msr_bitmap(void)\n{\n  if (unlikely(!current_evmcs))\n    return;\n  if (current_evmcs->hv_enlightenments_control.msr_bitmap)\n    current_evmcs->hv_clean_fields &=\n      ~HV_VMX_ENLIGHTENED_CLEAN_FIELD_MSR_BITMAP;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":80936
  },
  {
    "code":"filesystem_create_wait_for_cleartext_device_hook (DBusGMethodInvocation *context,\n                                                  Device *device,\n                                                  gpointer user_data)\n{\n  MkfsLuksData *data = user_data;\n  if (device == NULL)\n    {\n    }\n  else\n    {\n      device_filesystem_create_internal (device,\n                                         data->fstype,\n                                         data->options,\n                                         data->mkfs_hook_func,\n                                         data->mkfs_hook_user_data,\n                                         data->context);\n      mkfse_data_unref (data);\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":11695
  },
  {
    "code":"void FrameLoader::loadItem(HistoryItem* item, FrameLoadType loadType)\n{\n    if (!m_frame->page())\n        return;\n    KURL itemURL = item->url();\n    KURL itemOriginalURL = item->originalURL();\n    KURL currentURL;\n    if (documentLoader())\n        currentURL = documentLoader()->url();\n    RefPtr<FormData> formData = item->formData();\n    bool shouldScroll = !formData && !(history()->currentItem() && history()->currentItem()->formData()) && history()->urlsMatchItem(item);\n#if ENABLE(WML)\n    if (frameContainsWMLContent(m_frame))\n        shouldScroll = false;\n#endif\n    if (shouldScroll) {\n        history()->saveScrollPositionAndViewStateToItem(history()->currentItem());\n        if (FrameView* view = m_frame->view())\n            view->setWasScrolledByUser(false);\n        history()->setCurrentItem(item);\n        scrollToAnchor(item->url());\n        history()->restoreScrollPositionAndViewState();\n        documentLoader()->replaceRequestURLForAnchorScroll(itemURL);\n        m_client->dispatchDidChangeLocationWithinPage();\n        m_client->didFinishLoad();\n    } else {\n        history()->setProvisionalItem(item);\n        bool inPageCache = false;\n        if (RefPtr<CachedPage> cachedPage = pageCache()->get(item)) {\n            double interval = currentTime() - cachedPage->timeStamp();\n            if (interval <= 1800) {\n                loadWithDocumentLoader(cachedPage->documentLoader(), loadType, 0);   \n                inPageCache = true;\n            } else {\n                LOG(PageCache, \"Not restoring page for %s from back\/forward cache because cache entry has expired\", history()->provisionalItem()->url().string().ascii().data());\n                pageCache()->remove(item);\n            }\n        }\n        if (!inPageCache) {\n            bool addedExtraFields = false;\n            ResourceRequest request(itemURL);\n            if (!item->referrer().isNull())\n                request.setHTTPReferrer(item->referrer());\n            NavigationAction action;\n            if (formData) {\n                formData->generateFiles(m_frame->page()->chrome()->client());\n                request.setHTTPMethod(\"POST\");\n                request.setHTTPBody(formData);\n                request.setHTTPContentType(item->formContentType());\n                RefPtr<SecurityOrigin> securityOrigin = SecurityOrigin::createFromString(item->referrer());\n                addHTTPOriginIfNeeded(request, securityOrigin->toString());\n                addExtraFieldsToRequest(request, m_loadType, true, formData);\n                addedExtraFields = true;\n                if (ResourceHandle::willLoadFromCache(request, m_frame))\n                    action = NavigationAction(itemURL, loadType, false);\n                else {\n                    request.setCachePolicy(ReloadIgnoringCacheData);\n                    action = NavigationAction(itemURL, NavigationTypeFormResubmitted);\n                }\n            } else {\n                switch (loadType) {\n                    case FrameLoadTypeReload:\n                    case FrameLoadTypeReloadFromOrigin:\n                        request.setCachePolicy(ReloadIgnoringCacheData);\n                        break;\n                    case FrameLoadTypeBack:\n                    case FrameLoadTypeBackWMLDeckNotAccessible:\n                    case FrameLoadTypeForward:\n                    case FrameLoadTypeIndexedBackForward:\n                        if (itemURL.protocol() != \"https\")\n                            request.setCachePolicy(ReturnCacheDataElseLoad);\n                        break;\n                    case FrameLoadTypeStandard:\n                    case FrameLoadTypeRedirectWithLockedBackForwardList:\n                        break;\n                    case FrameLoadTypeSame:\n                    default:\n                        ASSERT_NOT_REACHED();\n                }\n                action = NavigationAction(itemOriginalURL, loadType, false);\n            }\n            if (!addedExtraFields)\n                addExtraFieldsToRequest(request, m_loadType, true, formData);\n            loadWithNavigationAction(request, action, false, loadType, 0);\n        }\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":97438
  },
  {
    "code":"CC_ESC_WARN(ScanEnv* env, UChar *c)\n{\n  if (onig_warn == onig_null_warn) return ;\n  if (IS_SYNTAX_BV(env->syntax, ONIG_SYN_WARN_CC_OP_NOT_ESCAPED) &&\n      IS_SYNTAX_BV(env->syntax, ONIG_SYN_BACKSLASH_ESCAPE_IN_CC)) {\n    UChar buf[WARN_BUFSIZE];\n    onig_snprintf_with_pattern(buf, WARN_BUFSIZE, env->enc,\n                               env->pattern, env->pattern_end,\n                               (UChar* )\"character class has '%s' without escape\",\n                               c);\n    (*onig_warn)((char* )buf);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":87832
  },
  {
    "code":"static int snd_seq_ioctl_get_queue_client(struct snd_seq_client *client,\n            void *arg)\n{\n  struct snd_seq_queue_client *info = arg;\n  int used;\n  used = snd_seq_queue_is_used(info->queue, client->number);\n  if (used < 0)\n    return -EINVAL;\n  info->used = used;\n  info->client = client->number;\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":60591
  },
  {
    "code":"GF_Err npck_Write(GF_Box *s, GF_BitStream *bs)\n{\n  GF_Err e;\n  GF_NPCKBox *ptr = (GF_NPCKBox *)s;\n  if (ptr == NULL) return GF_BAD_PARAM;\n  e = gf_isom_box_write_header(s, bs);\n  if (e) return e;\n  gf_bs_write_u32(bs, ptr->nbPackets);\n  return GF_OK;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":80295
  },
  {
    "code":"static struct dentry *proc_pident_lookup(struct inode *dir, \n           struct dentry *dentry,\n           const struct pid_entry *ents,\n           unsigned int nents)\n{\n  int error;\n  struct task_struct *task = get_proc_task(dir);\n  const struct pid_entry *p, *last;\n  error = -ENOENT;\n  if (!task)\n    goto out_no_task;\n  last = &ents[nents - 1];\n  for (p = ents; p <= last; p++) {\n    if (p->len != dentry->d_name.len)\n      continue;\n    if (!memcmp(dentry->d_name.name, p->name, p->len))\n      break;\n  }\n  if (p > last)\n    goto out;\n  error = proc_pident_instantiate(dir, dentry, task, p);\nout:\n  put_task_struct(task);\nout_no_task:\n  return ERR_PTR(error);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":49444
  },
  {
    "code":" void SetupMacroblock(MACROBLOCKD *mbptr,\n                       MODE_INFO *miptr,\n uint8_t *data,\n int block_size,\n int stride,\n int num_planes) {\n    mbptr_ = mbptr;\n    miptr_ = miptr;\n    mbptr_->up_available = 1;\n    mbptr_->left_available = 1;\n    mbptr_->mode_info_context = miptr_;\n    stride_ = stride;\n    block_size_ = block_size;\n    num_planes_ = num_planes;\n for (int p = 0; p < num_planes; p++)\n      data_ptr_[p] = data + stride * (block_size + 1) * p +\n                     stride + block_size;\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":177649
  },
  {
    "code":"ChromeMetricsServiceClient::FilterBrowserMetricsFiles(\n    const base::FilePath& path) {\n  base::ProcessId pid;\n  if (!base::GlobalHistogramAllocator::ParseFilePath(path, nullptr, nullptr,\n                                                     &pid)) {\n    return metrics::FileMetricsProvider::FILTER_PROCESS_FILE;\n  }\n  if (pid == base::GetCurrentProcId())\n    return metrics::FileMetricsProvider::FILTER_ACTIVE_THIS_PID;\n  if (IsProcessRunning(pid))\n    return metrics::FileMetricsProvider::FILTER_TRY_LATER;\n  return metrics::FileMetricsProvider::FILTER_PROCESS_FILE;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":141778
  },
  {
    "code":"void UrlFetcher::SetRequestContext(\n    net::URLRequestContextGetter* request_context_getter) {\n  core_->SetRequestContext(request_context_getter);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":112253
  },
  {
    "code":"static void n_tty_receive_overrun(struct tty_struct *tty)\n{\n  struct n_tty_data *ldata = tty->disc_data;\n  char buf[64];\n  ldata->num_overrun++;\n  if (time_after(jiffies, ldata->overrun_time + HZ) ||\n      time_after(ldata->overrun_time, jiffies)) {\n    printk(KERN_WARNING \"%s: %d input overrun(s)\\n\",\n      tty_name(tty, buf),\n      ldata->num_overrun);\n    ldata->overrun_time = jiffies;\n    ldata->num_overrun = 0;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":39825
  },
  {
    "code":"netlink_kernel_create(struct net *net, int unit,\n          struct module *module,\n          struct netlink_kernel_cfg *cfg)\n{\n  struct socket *sock;\n  struct sock *sk;\n  struct netlink_sock *nlk;\n  struct listeners *listeners = NULL;\n  struct mutex *cb_mutex = cfg ? cfg->cb_mutex : NULL;\n  unsigned int groups;\n  BUG_ON(!nl_table);\n  if (unit < 0 || unit >= MAX_LINKS)\n    return NULL;\n  if (sock_create_lite(PF_NETLINK, SOCK_DGRAM, unit, &sock))\n    return NULL;\n  if (__netlink_create(&init_net, sock, cb_mutex, unit) < 0)\n    goto out_sock_release_nosk;\n  sk = sock->sk;\n  sk_change_net(sk, net);\n  if (!cfg || cfg->groups < 32)\n    groups = 32;\n  else\n    groups = cfg->groups;\n  listeners = kzalloc(sizeof(*listeners) + NLGRPSZ(groups), GFP_KERNEL);\n  if (!listeners)\n    goto out_sock_release;\n  sk->sk_data_ready = netlink_data_ready;\n  if (cfg && cfg->input)\n    nlk_sk(sk)->netlink_rcv = cfg->input;\n  if (netlink_insert(sk, net, 0))\n    goto out_sock_release;\n  nlk = nlk_sk(sk);\n  nlk->flags |= NETLINK_KERNEL_SOCKET;\n  netlink_table_grab();\n  if (!nl_table[unit].registered) {\n    nl_table[unit].groups = groups;\n    rcu_assign_pointer(nl_table[unit].listeners, listeners);\n    nl_table[unit].cb_mutex = cb_mutex;\n    nl_table[unit].module = module;\n    nl_table[unit].bind = cfg ? cfg->bind : NULL;\n    nl_table[unit].registered = 1;\n  } else {\n    kfree(listeners);\n    nl_table[unit].registered++;\n  }\n  netlink_table_ungrab();\n  return sk;\nout_sock_release:\n  kfree(listeners);\n  netlink_kernel_release(sk);\n  return NULL;\nout_sock_release_nosk:\n  sock_release(sock);\n  return NULL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":19239
  },
  {
    "code":"  void SetData(UINT uFormat, HANDLE hMem) {\n    if (!opened_) {\n      NOTREACHED();\n      return;\n    }\n    ::SetClipboardData(uFormat, hMem);\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":130225
  },
  {
    "code":"void OomInterventionTabHelper::AcceptIntervention() {\n  RecordInterventionUserDecision(true);\n  intervention_state_ = InterventionState::ACCEPTED;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":143560
  },
  {
    "code":"  tt_driver_done( FT_Module  ttdriver )     \n  {\n    FT_UNUSED( ttdriver );\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":7510
  },
  {
    "code":"void WebContentsImpl::OnRenderFrameProxyVisibilityChanged(bool visible) {\n  if (visible)\n    WasShown();\n  else\n    WasHidden();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":144615
  },
  {
    "code":"static int nfsd_get_default_max_blksize(void)\n{\n  struct sysinfo i;\n  unsigned long long target;\n  unsigned long ret;\n  si_meminfo(&i);\n  target = (i.totalram - i.totalhigh) << PAGE_SHIFT;\n  target >>= 12;\n  ret = NFSSVC_MAXBLKSIZE;\n  while (ret > target && ret >= 8*1024*2)\n    ret \/= 2;\n  return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":67135
  },
  {
    "code":"sp<IMediaRecorder> MediaPlayerService::createMediaRecorder(const String16 &opPackageName)\n{\n pid_t pid = IPCThreadState::self()->getCallingPid();\n    sp<MediaRecorderClient> recorder = new MediaRecorderClient(this, pid, opPackageName);\n    wp<MediaRecorderClient> w = recorder;\n Mutex::Autolock lock(mLock);\n    mMediaRecorderClients.add(w);\n    ALOGV(\"Create new media recorder client from pid %d\", pid);\n return recorder;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":171145
  },
  {
    "code":"static void kvm_write_wall_clock(struct kvm *kvm, gpa_t wall_clock)\n{\n  int version;\n  int r;\n  struct pvclock_wall_clock wc;\n  struct timespec boot;\n  if (!wall_clock)\n    return;\n  r = kvm_read_guest(kvm, wall_clock, &version, sizeof(version));\n  if (r)\n    return;\n  if (version & 1)\n    ++version;  \n  ++version;\n  kvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n  getboottime(&boot);\n  if (kvm->arch.kvmclock_offset) {\n    struct timespec ts = ns_to_timespec(kvm->arch.kvmclock_offset);\n    boot = timespec_sub(boot, ts);\n  }\n  wc.sec = boot.tv_sec;\n  wc.nsec = boot.tv_nsec;\n  wc.version = version;\n  kvm_write_guest(kvm, wall_clock, &wc, sizeof(wc));\n  version++;\n  kvm_write_guest(kvm, wall_clock, &version, sizeof(version));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":28910
  },
  {
    "code":"DECL_PIOCTL(PGetFID)\n{\n    AFS_STATCNT(PGetFID);\n    if (!avc)\n  return EINVAL;\n    if (afs_pd_putBytes(aout, &avc->f.fid, sizeof(struct VenusFid)) != 0)\n  return EINVAL;\n    return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":14435
  },
  {
    "code":"static void __net_exit tcpv6_net_exit_batch(struct list_head *net_exit_list)\n{\n  inet_twsk_purge(&tcp_hashinfo, AF_INET6);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":65155
  },
  {
    "code":"static int kvm_set_pte_rmapp(struct kvm *kvm, unsigned long *rmapp,\n           struct kvm_memory_slot *slot, unsigned long data)\n{\n  u64 *sptep;\n  struct rmap_iterator iter;\n  int need_flush = 0;\n  u64 new_spte;\n  pte_t *ptep = (pte_t *)data;\n  pfn_t new_pfn;\n  WARN_ON(pte_huge(*ptep));\n  new_pfn = pte_pfn(*ptep);\n  for (sptep = rmap_get_first(*rmapp, &iter); sptep;) {\n    BUG_ON(!is_shadow_present_pte(*sptep));\n    rmap_printk(\"kvm_set_pte_rmapp: spte %p %llx\\n\", sptep, *sptep);\n    need_flush = 1;\n    if (pte_write(*ptep)) {\n      drop_spte(kvm, sptep);\n      sptep = rmap_get_first(*rmapp, &iter);\n    } else {\n      new_spte = *sptep & ~PT64_BASE_ADDR_MASK;\n      new_spte |= (u64)new_pfn << PAGE_SHIFT;\n      new_spte &= ~PT_WRITABLE_MASK;\n      new_spte &= ~SPTE_HOST_WRITEABLE;\n      new_spte &= ~shadow_accessed_mask;\n      mmu_spte_clear_track_bits(sptep);\n      mmu_spte_set(sptep, new_spte);\n      sptep = rmap_get_next(&iter);\n    }\n  }\n  if (need_flush)\n    kvm_flush_remote_tlbs(kvm);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":37497
  },
  {
    "code":"void LayerTreeCoordinator::didUninstallPageOverlay()\n{\n    destroyPageOverlayLayer();\n    scheduleLayerFlush();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":102460
  },
  {
    "code":"  void ExecuteScript(const ToRenderFrameHost& adapter, const char* script) {\n    adapter.render_frame_host()->ExecuteJavaScriptForTests(\n        base::UTF8ToUTF16(script));\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":159664
  },
  {
    "code":"nautilus_file_set_permissions_recursive (const char         *directory,\n                                         guint32             file_permissions,\n                                         guint32             file_mask,\n                                         guint32             dir_permissions,\n                                         guint32             dir_mask,\n                                         NautilusOpCallback  callback,\n                                         gpointer            callback_data)\n{\n    GTask *task;\n    SetPermissionsJob *job;\n    job = op_job_new (SetPermissionsJob, NULL);\n    job->file = g_file_new_for_uri (directory);\n    job->file_permissions = file_permissions;\n    job->file_mask = file_mask;\n    job->dir_permissions = dir_permissions;\n    job->dir_mask = dir_mask;\n    job->done_callback = callback;\n    job->done_callback_data = callback_data;\n    if (!nautilus_file_undo_manager_is_operating ())\n    {\n        job->common.undo_info =\n            nautilus_file_undo_info_rec_permissions_new (job->file,\n                                                         file_permissions, file_mask,\n                                                         dir_permissions, dir_mask);\n    }\n    task = g_task_new (NULL, NULL, set_permissions_task_done, job);\n    g_task_set_task_data (task, job, NULL);\n    g_task_run_in_thread (task, set_permissions_thread_func);\n    g_object_unref (task);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":61119
  },
  {
    "code":"static int lua_ap_add_input_filter(lua_State *L)\n{\n    request_rec    *r;\n    const char     *filterName;\n    ap_filter_rec_t *filter;\n    luaL_checktype(L, 1, LUA_TUSERDATA);\n    luaL_checktype(L, 2, LUA_TSTRING);\n    r = ap_lua_check_request_rec(L, 1);\n    filterName = lua_tostring(L, 2);\n    filter = ap_get_input_filter_handle(filterName);\n    if (filter) {\n        ap_add_input_filter_handle(filter, NULL, r, r->connection);\n        lua_pushboolean(L, 1);\n    } else\n        lua_pushboolean(L, 0);\n    return 1;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":45050
  },
  {
    "code":"int i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, PKCS8_PRIV_KEY_INFO *p8inf)\n  {\n  return ASN1_i2d_bio_of(PKCS8_PRIV_KEY_INFO,i2d_PKCS8_PRIV_KEY_INFO,bp,\n             p8inf);\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":94676
  },
  {
    "code":"void PrintPreviewHandler::HandleManagePrinters(const ListValue* ) {\n  ++manage_printers_dialog_request_count_;\n  printing::PrinterManagerDialog::ShowPrinterManagerDialog();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":112754
  },
  {
    "code":"error::Error GLES2DecoderImpl::HandleGetShaderPrecisionFormat(\n    uint32 immediate_data_size, const gles2::GetShaderPrecisionFormat& c) {\n  GLenum shader_type = static_cast<GLenum>(c.shadertype);\n  GLenum precision_type = static_cast<GLenum>(c.precisiontype);\n  typedef gles2::GetShaderPrecisionFormat::Result Result;\n  Result* result = GetSharedMemoryAs<Result*>(\n      c.result_shm_id, c.result_shm_offset, sizeof(*result));\n  if (!result) {\n    return error::kOutOfBounds;\n  }\n  if (result->success != 0) {\n    return error::kInvalidArguments;\n  }\n  if (!validators_->shader_type.IsValid(shader_type)) {\n    SetGLErrorInvalidEnum(\n        \"glGetShaderPrecisionFormat\", shader_type, \"shader_type\");\n    return error::kNoError;\n  }\n  if (!validators_->shader_precision.IsValid(precision_type)) {\n    SetGLErrorInvalidEnum(\n        \"glGetShaderPrecisionFormat\", precision_type, \"precision_type\");\n    return error::kNoError;\n  }\n  result->success = 1;  \n  switch (precision_type) {\n    case GL_LOW_INT:\n    case GL_MEDIUM_INT:\n    case GL_HIGH_INT:\n      result->min_range = 31;\n      result->max_range = 30;\n      result->precision = 0;\n      break;\n    case GL_LOW_FLOAT:\n    case GL_MEDIUM_FLOAT:\n    case GL_HIGH_FLOAT:\n      result->min_range = 127;\n      result->max_range = 127;\n      result->precision = 23;\n      break;\n    default:\n      NOTREACHED();\n      break;\n  }\n  return error::kNoError;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":110590
  },
  {
    "code":"int ssl3_get_client_certificate(SSL *s)\n{\n    int i, ok, al, ret = -1;\n    X509 *x = NULL;\n    unsigned long l, nc, llen, n;\n    const unsigned char *p, *q;\n    unsigned char *d;\n    STACK_OF(X509) *sk = NULL;\n    n = s->method->ssl_get_message(s,\n                                   SSL3_ST_SR_CERT_A,\n                                   SSL3_ST_SR_CERT_B,\n                                   -1, s->max_cert_list, &ok);\n    if (!ok)\n        return ((int)n);\n    if (s->s3->tmp.message_type == SSL3_MT_CLIENT_KEY_EXCHANGE) {\n        if ((s->verify_mode & SSL_VERIFY_PEER) &&\n            (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,\n                   SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            goto f_err;\n        }\n        if ((s->version > SSL3_VERSION) && s->s3->tmp.cert_request) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,\n                   SSL_R_TLS_PEER_DID_NOT_RESPOND_WITH_CERTIFICATE_LIST);\n            al = SSL_AD_UNEXPECTED_MESSAGE;\n            goto f_err;\n        }\n        s->s3->tmp.reuse_message = 1;\n        return (1);\n    }\n    if (s->s3->tmp.message_type != SSL3_MT_CERTIFICATE) {\n        al = SSL_AD_UNEXPECTED_MESSAGE;\n        SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, SSL_R_WRONG_MESSAGE_TYPE);\n        goto f_err;\n    }\n    p = d = (unsigned char *)s->init_msg;\n    if ((sk = sk_X509_new_null()) == NULL) {\n        SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE);\n        goto err;\n    }\n    n2l3(p, llen);\n    if (llen + 3 != n) {\n        al = SSL_AD_DECODE_ERROR;\n        SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, SSL_R_LENGTH_MISMATCH);\n        goto f_err;\n    }\n    for (nc = 0; nc < llen;) {\n        n2l3(p, l);\n        if ((l + nc + 3) > llen) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,\n                   SSL_R_CERT_LENGTH_MISMATCH);\n            goto f_err;\n        }\n        q = p;\n        x = d2i_X509(NULL, &p, l);\n        if (x == NULL) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, ERR_R_ASN1_LIB);\n            goto err;\n        }\n        if (p != (q + l)) {\n            al = SSL_AD_DECODE_ERROR;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,\n                   SSL_R_CERT_LENGTH_MISMATCH);\n            goto f_err;\n        }\n        if (!sk_X509_push(sk, x)) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n        x = NULL;\n        nc += l + 3;\n    }\n    if (sk_X509_num(sk) <= 0) {\n        if (s->version == SSL3_VERSION) {\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,\n                   SSL_R_NO_CERTIFICATES_RETURNED);\n            goto f_err;\n        }\n        else if ((s->verify_mode & SSL_VERIFY_PEER) &&\n                 (s->verify_mode & SSL_VERIFY_FAIL_IF_NO_PEER_CERT)) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,\n                   SSL_R_PEER_DID_NOT_RETURN_A_CERTIFICATE);\n            al = SSL_AD_HANDSHAKE_FAILURE;\n            goto f_err;\n        }\n        if (s->s3->handshake_buffer && !ssl3_digest_cached_records(s)) {\n            al = SSL_AD_INTERNAL_ERROR;\n            goto f_err;\n        }\n    } else {\n        i = ssl_verify_cert_chain(s, sk);\n        if (i <= 0) {\n            al = ssl_verify_alarm_type(s->verify_result);\n            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE,\n                   SSL_R_CERTIFICATE_VERIFY_FAILED);\n            goto f_err;\n        }\n    }\n    if (s->session->peer != NULL) \n        X509_free(s->session->peer);\n    s->session->peer = sk_X509_shift(sk);\n    s->session->verify_result = s->verify_result;\n    if (s->session->sess_cert == NULL) {\n        s->session->sess_cert = ssl_sess_cert_new();\n        if (s->session->sess_cert == NULL) {\n            SSLerr(SSL_F_SSL3_GET_CLIENT_CERTIFICATE, ERR_R_MALLOC_FAILURE);\n            goto err;\n        }\n    }\n    if (s->session->sess_cert->cert_chain != NULL)\n        sk_X509_pop_free(s->session->sess_cert->cert_chain, X509_free);\n    s->session->sess_cert->cert_chain = sk;\n    sk = NULL;\n    ret = 1;\n    if (0) {\n f_err:\n        ssl3_send_alert(s, SSL3_AL_FATAL, al);\n    }\n err:\n    if (x != NULL)\n        X509_free(x);\n    if (sk != NULL)\n        sk_X509_pop_free(sk, X509_free);\n    return (ret);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":5054
  },
  {
    "code":"void NetworkActionPredictor::Observe(\n    int type,\n    const content::NotificationSource& source,\n    const content::NotificationDetails& details) {\n  switch (type) {\n    case chrome::NOTIFICATION_HISTORY_URLS_DELETED: {\n      DCHECK(initialized_);\n      const content::Details<const history::URLsDeletedDetails>\n          urls_deleted_details =\n              content::Details<const history::URLsDeletedDetails>(details);\n      if (urls_deleted_details->all_history)\n        DeleteAllRows();\n      else\n        DeleteRowsWithURLs(urls_deleted_details->urls);\n      break;\n    }\n    case chrome::NOTIFICATION_OMNIBOX_OPENED_URL: {\n      DCHECK(initialized_);\n      OnOmniboxOpenedUrl(*content::Details<AutocompleteLog>(details).ptr());\n      break;\n    }\n    case chrome::NOTIFICATION_HISTORY_LOADED: {\n      DCHECK(!initialized_);\n      TryDeleteOldEntries(content::Details<HistoryService>(details).ptr());\n      notification_registrar_.Remove(this,\n                                     chrome::NOTIFICATION_HISTORY_LOADED,\n                                     content::Source<Profile>(profile_));\n      break;\n    }\n    default:\n      NOTREACHED() << \"Unexpected notification observed.\";\n      break;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":114706
  },
  {
    "code":"void GLES2DecoderImpl::ClearUnclearedRenderbuffers(\n    FramebufferManager::FramebufferInfo* info) {\n  GLbitfield clear_bits = 0;\n  if (info->HasUnclearedAttachment(GL_COLOR_ATTACHMENT0)) {\n    glClearColor(0, 0, 0, 0);\n    glColorMask(true, true, true, true);\n    clear_bits |= GL_COLOR_BUFFER_BIT;\n  }\n  if (info->HasUnclearedAttachment(GL_STENCIL_ATTACHMENT) ||\n      info->HasUnclearedAttachment(GL_DEPTH_STENCIL_ATTACHMENT)) {\n    glClearStencil(0);\n    glStencilMask(-1);\n    clear_bits |= GL_STENCIL_BUFFER_BIT;\n  }\n  if (info->HasUnclearedAttachment(GL_DEPTH_ATTACHMENT) ||\n      info->HasUnclearedAttachment(GL_DEPTH_STENCIL_ATTACHMENT)) {\n    glClearDepth(1.0f);\n    glDepthMask(true);\n    clear_bits |= GL_DEPTH_BUFFER_BIT;\n  }\n  glDisable(GL_SCISSOR_TEST);\n  glClear(clear_bits);\n  info->MarkAttachedRenderbuffersAsCleared();\n  glClearColor(clear_red_, clear_green_, clear_blue_, clear_alpha_);\n  glColorMask(mask_red_, mask_green_, mask_blue_, mask_alpha_);\n  glClearStencil(clear_stencil_);\n  glStencilMaskSeparate(GL_FRONT, mask_stencil_front_);\n  glStencilMaskSeparate(GL_BACK, mask_stencil_back_);\n  glClearDepth(clear_depth_);\n  glDepthMask(mask_depth_);\n  if (enable_scissor_test_) {\n    glEnable(GL_SCISSOR_TEST);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":108042
  },
  {
    "code":"static void adts_error_check(adts_header *adts, bitfile *ld)\n{\n    if (adts->protection_absent == 0)\n    {\n        adts->crc_check = (uint16_t)faad_getbits(ld, 16\n            DEBUGVAR(1,134,\"adts_error_check(): crc_check\"));\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":88367
  },
  {
    "code":"static int __each_dev(struct device *dev, void *data)\n{\n  struct each_dev_arg *arg = (struct each_dev_arg *)data;\n  if (!is_usb_device(dev))\n    return 0;\n  return arg->fn(to_usb_device(dev), arg->data);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":75533
  },
  {
    "code":"void DevToolsWindow::HandleKeyboardEvent(\n    WebContents* source,\n    const content::NativeWebKeyboardEvent& event) {\n  if (event.windows_key_code == 0x08) {\n    return;\n  }\n  BrowserWindow* inspected_window = GetInspectedBrowserWindow();\n  if (inspected_window)\n    inspected_window->HandleKeyboardEvent(event);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":163873
  },
  {
    "code":"IntRect PaintLayerScrollableArea::ScrollableAreaBoundingBox() const {\n  if (LocalFrame* frame = GetLayoutBox()->GetFrame()) {\n    if (LocalFrameView* local_root = frame->LocalFrameRoot().View()) {\n      return local_root->RootFrameToDocument(frame->View()->ConvertToRootFrame(\n          GetLayoutBox()->AbsoluteBoundingBoxRect(0)));\n    }\n  }\n  return IntRect();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":141485
  },
  {
    "code":"static void mpol_rebind_preferred(struct mempolicy *pol,\n            const nodemask_t *nodes)\n{\n  nodemask_t tmp;\n  if (pol->flags & MPOL_F_STATIC_NODES) {\n    int node = first_node(pol->w.user_nodemask);\n    if (node_isset(node, *nodes)) {\n      pol->v.preferred_node = node;\n      pol->flags &= ~MPOL_F_LOCAL;\n    } else\n      pol->flags |= MPOL_F_LOCAL;\n  } else if (pol->flags & MPOL_F_RELATIVE_NODES) {\n    mpol_relative_nodemask(&tmp, &pol->w.user_nodemask, nodes);\n    pol->v.preferred_node = first_node(tmp);\n  } else if (!(pol->flags & MPOL_F_LOCAL)) {\n    pol->v.preferred_node = node_remap(pol->v.preferred_node,\n               pol->w.cpuset_mems_allowed,\n               *nodes);\n    pol->w.cpuset_mems_allowed = *nodes;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":83110
  },
  {
    "code":"static wifi_error wifi_start_rssi_monitoring(wifi_request_id id, wifi_interface_handle\n                        iface, s8 max_rssi, s8 min_rssi, wifi_rssi_event_handler eh)\n{\n    ALOGD(\"Start RSSI monitor %d\", id);\n    wifi_handle handle = getWifiHandle(iface);\n SetRSSIMonitorCommand *cmd = new SetRSSIMonitorCommand(id, iface, max_rssi, min_rssi, eh);\n    wifi_register_cmd(handle, id, cmd);\n    wifi_error result = (wifi_error)cmd->start();\n if (result != WIFI_SUCCESS) {\n        wifi_unregister_cmd(handle, id);\n }\n return result;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":175143
  },
  {
    "code":"static int set_efer(struct kvm_vcpu *vcpu, u64 efer)\n{\n  u64 old_efer = vcpu->arch.efer;\n  if (efer & efer_reserved_bits)\n    return 1;\n  if (is_paging(vcpu)\n      && (vcpu->arch.efer & EFER_LME) != (efer & EFER_LME))\n    return 1;\n  if (efer & EFER_FFXSR) {\n    struct kvm_cpuid_entry2 *feat;\n    feat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n    if (!feat || !(feat->edx & bit(X86_FEATURE_FXSR_OPT)))\n      return 1;\n  }\n  if (efer & EFER_SVME) {\n    struct kvm_cpuid_entry2 *feat;\n    feat = kvm_find_cpuid_entry(vcpu, 0x80000001, 0);\n    if (!feat || !(feat->ecx & bit(X86_FEATURE_SVM)))\n      return 1;\n  }\n  efer &= ~EFER_LMA;\n  efer |= vcpu->arch.efer & EFER_LMA;\n  kvm_x86_ops->set_efer(vcpu, efer);\n  vcpu->arch.mmu.base_role.nxe = (efer & EFER_NX) && !tdp_enabled;\n  if ((efer ^ old_efer) & EFER_NX)\n    kvm_mmu_reset_context(vcpu);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":20877
  },
  {
    "code":"bool WebGLRenderingContextBase::ValidateString(const char* function_name,\n                                               const String& string) {\n  for (size_t i = 0; i < string.length(); ++i) {\n    if (!ValidateCharacter(string[i])) {\n      SynthesizeGLError(GL_INVALID_VALUE, function_name, \"string not ASCII\");\n      return false;\n    }\n  }\n  return true;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":146422
  },
  {
    "code":"void GraphicsContext::platformDestroy()\n{\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":115617
  },
  {
    "code":"static __be32 nfsd4_check_seqid(struct nfsd4_compound_state *cstate, struct nfs4_stateowner *so, u32 seqid)\n{\n  if (nfsd4_has_session(cstate))\n    return nfs_ok;\n  if (seqid == so->so_seqid - 1)\n    return nfserr_replay_me;\n  if (seqid == so->so_seqid)\n    return nfs_ok;\n  return nfserr_bad_seqid;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":65568
  },
  {
    "code":"void BaseMultipleFieldsDateAndTimeInputType::blur()\n{\n    if (DateTimeEditElement* edit = dateTimeEditElement())\n        edit->blurByOwner();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":120706
  },
  {
    "code":"void Document::writeln(v8::Isolate* isolate,\n                       const Vector<String>& text,\n                       ExceptionState& exception_state) {\n  if (IsTrustedTypesEnabledForDoc()) {\n    DCHECK(origin_trials::TrustedDOMTypesEnabled(this));\n    exception_state.ThrowTypeError(\n        \"This document can only write `TrustedHTML` objects.\");\n    return;\n  }\n  if (!AllowedToUseDynamicMarkUpInsertion(\"writeln\", exception_state))\n    return;\n  StringBuilder builder;\n  for (const String& string : text)\n    builder.Append(string);\n  writeln(builder.ToString(), EnteredDOMWindow(isolate)->document(),\n          exception_state);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":141379
  },
  {
    "code":"WebResourceTimingInfo Performance::GenerateResourceTiming(\n    const SecurityOrigin& destination_origin,\n    const ResourceTimingInfo& info,\n    ExecutionContext& context_for_use_counter) {\n  const ResourceResponse& final_response = info.FinalResponse();\n  WebResourceTimingInfo result;\n  result.name = info.InitialURL().GetString();\n  result.start_time = info.InitialTime();\n  result.alpn_negotiated_protocol = final_response.AlpnNegotiatedProtocol();\n  result.connection_info = final_response.ConnectionInfoString();\n  result.timing = final_response.GetResourceLoadTiming();\n  result.finish_time = info.LoadFinishTime();\n  result.allow_timing_details = PassesTimingAllowCheck(\n      final_response, destination_origin, info.OriginalTimingAllowOrigin(),\n      &context_for_use_counter);\n  const Vector<ResourceResponse>& redirect_chain = info.RedirectChain();\n  if (!redirect_chain.IsEmpty()) {\n    result.allow_redirect_details =\n        AllowsTimingRedirect(redirect_chain, final_response, destination_origin,\n                             &context_for_use_counter);\n    if (ResourceLoadTiming* last_chained_timing =\n            redirect_chain.back().GetResourceLoadTiming()) {\n      result.last_redirect_end_time =\n          TimeTicksInSeconds(last_chained_timing->ReceiveHeadersEnd());\n    } else {\n      result.allow_redirect_details = false;\n      result.last_redirect_end_time = 0.0;\n    }\n    if (!result.allow_redirect_details) {\n      if (ResourceLoadTiming* final_timing =\n              final_response.GetResourceLoadTiming()) {\n        result.start_time = TimeTicksInSeconds(final_timing->RequestTime());\n      }\n    }\n  } else {\n    result.allow_redirect_details = false;\n    result.last_redirect_end_time = 0.0;\n  }\n  result.transfer_size = info.TransferSize();\n  result.encoded_body_size = final_response.EncodedBodyLength();\n  result.decoded_body_size = final_response.DecodedBodyLength();\n  result.did_reuse_connection = final_response.ConnectionReused();\n  result.allow_negative_values = info.NegativeAllowed();\n  if (result.allow_timing_details) {\n    result.server_timing = PerformanceServerTiming::ParseServerTiming(info);\n  }\n  if (!result.server_timing.empty()) {\n    UseCounter::Count(&context_for_use_counter,\n                      WebFeature::kPerformanceServerTiming);\n  }\n  return result;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":166886
  },
  {
    "code":"static void limitedWithEmptyMissingInvalidAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    String resultValue = imp->fastGetAttribute(HTMLNames::limitedwithemptymissinginvalidattributeAttr);\n    if (resultValue.isNull()) {\n        resultValue = \"missing\";\n    } else if (resultValue.isEmpty()) {\n        resultValue = \"empty\";\n    } else if (equalIgnoringCase(resultValue, \"empty\")) {\n        resultValue = \"empty\";\n    } else if (equalIgnoringCase(resultValue, \"missing\")) {\n        resultValue = \"missing\";\n    } else if (equalIgnoringCase(resultValue, \"invalid\")) {\n        resultValue = \"invalid\";\n    } else if (equalIgnoringCase(resultValue, \"a-normal\")) {\n        resultValue = \"a-normal\";\n    } else {\n        resultValue = \"invalid\";\n    }\n    v8SetReturnValueString(info, resultValue, info.GetIsolate());\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":130806
  },
  {
    "code":"RootWindow* RootWindow::GetRootWindow() {\n  return this;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":110880
  },
  {
    "code":"BGD_DECLARE(gdImagePtr) gdImageCreateFromWebp (FILE * inFile)\n{\n  gdImagePtr im;\n  gdIOCtx *in = gdNewFileCtx(inFile);\n  if (!in) {\n    return 0;\n  }\n  im = gdImageCreateFromWebpCtx(in);\n  in->gd_free(in);\n  return im;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":49723
  },
  {
    "code":"static int pharobj_cancompress(HashTable *manifest) \n{\n  int test;\n  test = 1;\n  zend_hash_apply_with_argument(manifest, phar_test_compression, &test);\n  return test;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":11193
  },
  {
    "code":"void ResourceFetcher::DidLoadResourceFromMemoryCache(\n    unsigned long identifier,\n    Resource* resource,\n    const ResourceRequest& original_resource_request) {\n  ResourceRequest resource_request(resource->Url());\n  resource_request.SetFrameType(original_resource_request.GetFrameType());\n  resource_request.SetRequestContext(\n       original_resource_request.GetRequestContext());\n   Context().DispatchDidLoadResourceFromMemoryCache(identifier, resource_request,\n                                                    resource->GetResponse());\n  Context().DispatchWillSendRequest(identifier, resource_request,\n                                    ResourceResponse() ,\n                                    resource->Options().initiator_info);\n   Context().DispatchDidReceiveResponse(\n       identifier, resource->GetResponse(), resource_request.GetFrameType(),\n       resource_request.GetRequestContext(), resource,\n      FetchContext::ResourceResponseType::kFromMemoryCache);\n  if (resource->EncodedSize() > 0)\n    Context().DispatchDidReceiveData(identifier, 0, resource->EncodedSize());\n  Context().DispatchDidFinishLoading(\n      identifier, 0, 0, resource->GetResponse().DecodedBodyLength());\n}\n",
    "vul":1,
    "flaw_line_no":[
      11,
      12,
      13
    ],
    "bigvul_id":186446
  },
  {
    "code":"void AllViewsStoppedLoadingObserver::Observe(\n    int type,\n    const content::NotificationSource& source,\n    const content::NotificationDetails& details) {\n  if (!automation_) {\n    delete this;\n    return;\n  }\n  if (type == content::NOTIFICATION_LOAD_STOP) {\n    CheckIfNoMorePendingLoads();\n  } else if (type == chrome::NOTIFICATION_APP_MODAL_DIALOG_SHOWN) {\n    AutomationJSONReply(automation_,\n                        reply_message_.release()).SendSuccess(NULL);\n    delete this;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":126001
  },
  {
    "code":"WebPage* WebFrame::page() const\n{ \n    if (!m_coreFrame)\n        return 0;\n    if (WebCore::Page* page = m_coreFrame->page())\n        return static_cast<WebChromeClient*>(page->chrome()->client())->page();\n    return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":98262
  },
  {
    "code":"  parse_blend_design_positions( T1_Face    face,\n                                T1_Loader  loader )\n  {\n    T1_TokenRec  design_tokens[T1_MAX_MM_DESIGNS];\n    FT_Int       num_designs;\n    FT_Int       num_axis;\n    T1_Parser    parser = &loader->parser;\n    FT_Error     error = FT_Err_Ok;\n    PS_Blend     blend;\n    T1_ToTokenArray( parser, design_tokens,\n                     T1_MAX_MM_DESIGNS, &num_designs );\n    if ( num_designs < 0 )\n    {\n      error = FT_ERR( Ignore );\n      goto Exit;\n    }\n    if ( num_designs == 0 || num_designs > T1_MAX_MM_DESIGNS )\n    {\n      FT_ERROR(( \"parse_blend_design_positions:\"\n                 \" incorrect number of designs: %d\\n\",\n                 num_designs ));\n      error = FT_THROW( Invalid_File_Format );\n      goto Exit;\n    }\n    {\n      FT_Byte*  old_cursor = parser->root.cursor;\n      FT_Byte*  old_limit  = parser->root.limit;\n      FT_Int    n;\n      blend    = face->blend;\n      num_axis = 0;  \n      for ( n = 0; n < num_designs; n++ )\n      {\n        T1_TokenRec  axis_tokens[T1_MAX_MM_AXIS];\n        T1_Token     token;\n        FT_Int       axis, n_axis;\n        token = design_tokens + n;\n        parser->root.cursor = token->start;\n        parser->root.limit  = token->limit;\n        T1_ToTokenArray( parser, axis_tokens, T1_MAX_MM_AXIS, &n_axis );\n        if ( n == 0 )\n        {\n          if ( n_axis <= 0 || n_axis > T1_MAX_MM_AXIS )\n          {\n            FT_ERROR(( \"parse_blend_design_positions:\"\n                       \" invalid number of axes: %d\\n\",\n                       n_axis ));\n            error = FT_THROW( Invalid_File_Format );\n            goto Exit;\n          }\n          num_axis = n_axis;\n          error = t1_allocate_blend( face, num_designs, num_axis );\n          if ( error )\n            goto Exit;\n          blend = face->blend;\n        }\n        else if ( n_axis != num_axis )\n        {\n          FT_ERROR(( \"parse_blend_design_positions: incorrect table\\n\" ));\n          error = FT_THROW( Invalid_File_Format );\n          goto Exit;\n        }\n        for ( axis = 0; axis < n_axis; axis++ )\n        {\n          T1_Token  token2 = axis_tokens + axis;\n          parser->root.cursor = token2->start;\n          parser->root.limit  = token2->limit;\n          blend->design_pos[n][axis] = T1_ToFixed( parser, 0 );\n        }\n      }\n      loader->parser.root.cursor = old_cursor;\n      loader->parser.root.limit  = old_limit;\n    }\n  Exit:\n    loader->parser.root.error = error;\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":6661
  },
  {
    "code":"static int kvm_guest_time_update(struct kvm_vcpu *v)\n{\n  unsigned long flags;\n  struct kvm_vcpu_arch *vcpu = &v->arch;\n  void *shared_kaddr;\n  unsigned long this_tsc_khz;\n  s64 kernel_ns, max_kernel_ns;\n  u64 tsc_timestamp;\n  local_irq_save(flags);\n  tsc_timestamp = kvm_x86_ops->read_l1_tsc(v);\n  kernel_ns = get_kernel_ns();\n  this_tsc_khz = vcpu_tsc_khz(v);\n  if (unlikely(this_tsc_khz == 0)) {\n    local_irq_restore(flags);\n    kvm_make_request(KVM_REQ_CLOCK_UPDATE, v);\n    return 1;\n  }\n  if (vcpu->tsc_catchup) {\n    u64 tsc = compute_guest_tsc(v, kernel_ns);\n    if (tsc > tsc_timestamp) {\n      kvm_x86_ops->adjust_tsc_offset(v, tsc - tsc_timestamp);\n      tsc_timestamp = tsc;\n    }\n  }\n  local_irq_restore(flags);\n  if (!vcpu->time_page)\n    return 0;\n  max_kernel_ns = 0;\n  if (vcpu->hv_clock.tsc_timestamp && vcpu->last_guest_tsc) {\n    max_kernel_ns = vcpu->last_guest_tsc -\n        vcpu->hv_clock.tsc_timestamp;\n    max_kernel_ns = pvclock_scale_delta(max_kernel_ns,\n            vcpu->hv_clock.tsc_to_system_mul,\n            vcpu->hv_clock.tsc_shift);\n    max_kernel_ns += vcpu->last_kernel_ns;\n  }\n  if (unlikely(vcpu->hw_tsc_khz != this_tsc_khz)) {\n    kvm_get_time_scale(NSEC_PER_SEC \/ 1000, this_tsc_khz,\n           &vcpu->hv_clock.tsc_shift,\n           &vcpu->hv_clock.tsc_to_system_mul);\n    vcpu->hw_tsc_khz = this_tsc_khz;\n  }\n  if (max_kernel_ns > kernel_ns)\n    kernel_ns = max_kernel_ns;\n  vcpu->hv_clock.tsc_timestamp = tsc_timestamp;\n  vcpu->hv_clock.system_time = kernel_ns + v->kvm->arch.kvmclock_offset;\n  vcpu->last_kernel_ns = kernel_ns;\n  vcpu->last_guest_tsc = tsc_timestamp;\n  vcpu->hv_clock.flags = 0;\n  vcpu->hv_clock.version += 2;\n  shared_kaddr = kmap_atomic(vcpu->time_page, KM_USER0);\n  memcpy(shared_kaddr + vcpu->time_offset, &vcpu->hv_clock,\n         sizeof(vcpu->hv_clock));\n  kunmap_atomic(shared_kaddr, KM_USER0);\n  mark_page_dirty(v->kvm, vcpu->time >> PAGE_SHIFT);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":20776
  },
  {
    "code":"MagickPrivate MagickBooleanType SyncImagePixelCache(Image *image,\n  ExceptionInfo *exception)\n{\n  CacheInfo\n    *restrict cache_info;\n  assert(image != (Image *) NULL);\n  assert(exception != (ExceptionInfo *) NULL);\n  cache_info=(CacheInfo *) GetImagePixelCache(image,MagickTrue,exception);\n  return(cache_info == (CacheInfo *) NULL ? MagickFalse : MagickTrue);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":73662
  },
  {
    "code":"static void ip_cmsg_recv_ttl(struct msghdr *msg, struct sk_buff *skb)\n{\n  int ttl = ip_hdr(skb)->ttl;\n  put_cmsg(msg, SOL_IP, IP_TTL, sizeof(int), &ttl);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":18931
  },
  {
    "code":"static BN_ULONG bn_get_bits(const BIGNUM *a, int bitpos)\n{\n    BN_ULONG ret = 0;\n    int wordpos;\n    wordpos = bitpos \/ BN_BITS2;\n    bitpos %= BN_BITS2;\n    if (wordpos >= 0 && wordpos < a->top) {\n        ret = a->d[wordpos] & BN_MASK2;\n        if (bitpos) {\n            ret >>= bitpos;\n            if (++wordpos < a->top)\n                ret |= a->d[wordpos] << (BN_BITS2 - bitpos);\n        }\n    }\n    return ret & BN_MASK2;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":13682
  },
  {
    "code":"void FrameLoader::StopAllLoaders() {\n  if (frame_->GetDocument()->PageDismissalEventBeingDispatched() !=\n      Document::kNoDismissal)\n    return;\n  if (in_stop_all_loaders_)\n    return;\n  AutoReset<bool> in_stop_all_loaders(&in_stop_all_loaders_, true);\n  for (Frame* child = frame_->Tree().FirstChild(); child;\n       child = child->Tree().NextSibling()) {\n    if (child->IsLocalFrame())\n      ToLocalFrame(child)->Loader().StopAllLoaders();\n  }\n  frame_->GetDocument()->CancelParsing();\n  if (document_loader_)\n    document_loader_->StopLoading();\n  if (!protect_provisional_loader_)\n    DetachDocumentLoader(provisional_document_loader_);\n  frame_->GetNavigationScheduler().Cancel();\n  DidFinishNavigation();\n  TakeObjectSnapshot();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":160922
  },
  {
    "code":"static int uio_mmap(struct file *filep, struct vm_area_struct *vma)\n{\n  struct uio_listener *listener = filep->private_data;\n  struct uio_device *idev = listener->dev;\n  int mi;\n  unsigned long requested_pages, actual_pages;\n  int ret = 0;\n  if (vma->vm_end < vma->vm_start)\n    return -EINVAL;\n  vma->vm_private_data = idev;\n  mi = uio_find_mem_index(vma);\n  if (mi < 0)\n    return -EINVAL;\n  requested_pages = vma_pages(vma);\n  actual_pages = ((idev->info->mem[mi].addr & ~PAGE_MASK)\n      + idev->info->mem[mi].size + PAGE_SIZE -1) >> PAGE_SHIFT;\n  if (requested_pages > actual_pages)\n    return -EINVAL;\n  if (idev->info->mmap) {\n    ret = idev->info->mmap(idev->info, vma);\n    return ret;\n  }\n  switch (idev->info->mem[mi].memtype) {\n    case UIO_MEM_PHYS:\n      return uio_mmap_physical(vma);\n    case UIO_MEM_LOGICAL:\n    case UIO_MEM_VIRTUAL:\n      return uio_mmap_logical(vma);\n    default:\n      return -EINVAL;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":28315
  },
  {
    "code":"static void cprng_exit(struct crypto_tfm *tfm)\n{\n  free_prng_context(crypto_tfm_ctx(tfm));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":47106
  },
  {
    "code":"double DefaultAudioDestinationHandler::SampleRate() const {\n  return platform_destination_ ? platform_destination_->SampleRate() : 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":143071
  },
  {
    "code":"TextureManager::TextureInfo* TextureManager::CreateTextureInfo(\n    GLuint client_id, GLuint service_id) {\n  DCHECK_NE(0u, service_id);\n  TextureInfo::Ref info(new TextureInfo(this, service_id));\n  std::pair<TextureInfoMap::iterator, bool> result =\n      texture_infos_.insert(std::make_pair(client_id, info));\n  DCHECK(result.second);\n  if (!info->CanRender(feature_info_)) {\n    ++num_unrenderable_textures_;\n  }\n  if (!info->SafeToRenderFrom()) {\n    ++num_unsafe_textures_;\n  }\n  num_uncleared_mips_ += info->num_uncleared_mips();\n  return info.get();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":110665
  },
  {
    "code":"static int __driver_rfc4106_encrypt(struct aead_request *req)\n{\n  u8 one_entry_in_sg = 0;\n  u8 *src, *dst, *assoc;\n  __be32 counter = cpu_to_be32(1);\n  struct crypto_aead *tfm = crypto_aead_reqtfm(req);\n  struct aesni_rfc4106_gcm_ctx *ctx = aesni_rfc4106_gcm_ctx_get(tfm);\n  void *aes_ctx = &(ctx->aes_key_expanded);\n  unsigned long auth_tag_len = crypto_aead_authsize(tfm);\n  u8 iv_tab[16+AESNI_ALIGN];\n  u8* iv = (u8 *) PTR_ALIGN((u8 *)iv_tab, AESNI_ALIGN);\n  struct scatter_walk src_sg_walk;\n  struct scatter_walk assoc_sg_walk;\n  struct scatter_walk dst_sg_walk;\n  unsigned int i;\n  if (unlikely(req->assoclen != 8 && req->assoclen != 12))\n    return -EINVAL;\n  for (i = 0; i < 4; i++)\n    *(iv+i) = ctx->nonce[i];\n  for (i = 0; i < 8; i++)\n    *(iv+4+i) = req->iv[i];\n  *((__be32 *)(iv+12)) = counter;\n  if ((sg_is_last(req->src)) && (sg_is_last(req->assoc))) {\n    one_entry_in_sg = 1;\n    scatterwalk_start(&src_sg_walk, req->src);\n    scatterwalk_start(&assoc_sg_walk, req->assoc);\n    src = scatterwalk_map(&src_sg_walk);\n    assoc = scatterwalk_map(&assoc_sg_walk);\n    dst = src;\n    if (unlikely(req->src != req->dst)) {\n      scatterwalk_start(&dst_sg_walk, req->dst);\n      dst = scatterwalk_map(&dst_sg_walk);\n    }\n  } else {\n    src = kmalloc(req->cryptlen + auth_tag_len + req->assoclen,\n      GFP_ATOMIC);\n    if (unlikely(!src))\n      return -ENOMEM;\n    assoc = (src + req->cryptlen + auth_tag_len);\n    scatterwalk_map_and_copy(src, req->src, 0, req->cryptlen, 0);\n    scatterwalk_map_and_copy(assoc, req->assoc, 0,\n          req->assoclen, 0);\n    dst = src;\n  }\n  aesni_gcm_enc_tfm(aes_ctx, dst, src, (unsigned long)req->cryptlen, iv,\n    ctx->hash_subkey, assoc, (unsigned long)req->assoclen, dst\n    + ((unsigned long)req->cryptlen), auth_tag_len);\n  if (one_entry_in_sg) {\n    if (unlikely(req->src != req->dst)) {\n      scatterwalk_unmap(dst);\n      scatterwalk_done(&dst_sg_walk, 0, 0);\n    }\n    scatterwalk_unmap(src);\n    scatterwalk_unmap(assoc);\n    scatterwalk_done(&src_sg_walk, 0, 0);\n    scatterwalk_done(&assoc_sg_walk, 0, 0);\n  } else {\n    scatterwalk_map_and_copy(dst, req->dst, 0,\n      req->cryptlen + auth_tag_len, 1);\n    kfree(src);\n  }\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":46820
  },
  {
    "code":"long long Chapters::Atom::GetStartTimecode() const\n{\n    return m_start_timecode;\n}\n",
    "vul":1,
    "flaw_line_no":[
      2,
      3,
      4
    ],
    "bigvul_id":188378
  },
  {
    "code":"static bool skb_flow_limit(struct sk_buff *skb, unsigned int qlen)\n{\n#ifdef CONFIG_NET_FLOW_LIMIT\n  struct sd_flow_limit *fl;\n  struct softnet_data *sd;\n  unsigned int old_flow, new_flow;\n  if (qlen < (netdev_max_backlog >> 1))\n    return false;\n  sd = this_cpu_ptr(&softnet_data);\n  rcu_read_lock();\n  fl = rcu_dereference(sd->flow_limit);\n  if (fl) {\n    new_flow = skb_get_hash(skb) & (fl->num_buckets - 1);\n    old_flow = fl->history[fl->history_head];\n    fl->history[fl->history_head] = new_flow;\n    fl->history_head++;\n    fl->history_head &= FLOW_LIMIT_HISTORY - 1;\n    if (likely(fl->buckets[old_flow]))\n      fl->buckets[old_flow]--;\n    if (++fl->buckets[new_flow] > (FLOW_LIMIT_HISTORY >> 1)) {\n      fl->count++;\n      rcu_read_unlock();\n      return true;\n    }\n  }\n  rcu_read_unlock();\n#endif\n  return false;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":48943
  },
  {
    "code":"void InputHandlerProxy::ReconcileElasticOverscrollAndRootScroll() {\n  if (scroll_elasticity_controller_)\n    scroll_elasticity_controller_->ReconcileStretchAndScroll();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":150656
  },
  {
    "code":"line_construct_pm(Point *pt, double m)\n{\n  LINE     *result = (LINE *) palloc(sizeof(LINE));\n  if (m == DBL_MAX)\n  {\n    result->A = -1;\n    result->B = 0;\n    result->C = pt->x;\n  }\n  else\n  {\n    result->A = m;\n    result->B = -1.0;\n    result->C = pt->y - m * pt->x;\n  }\n  return result;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":38895
  },
  {
    "code":"const AtomicString& Element::webkitRegionOverset() const\n{\n    document()->updateLayoutIgnorePendingStylesheets();\n    DEFINE_STATIC_LOCAL(AtomicString, undefinedState, (\"undefined\", AtomicString::ConstructFromLiteral));\n    if (!RuntimeEnabledFeatures::cssRegionsEnabled() || !renderRegion())\n        return undefinedState;\n    switch (renderRegion()->regionOversetState()) {\n    case RegionFit: {\n        DEFINE_STATIC_LOCAL(AtomicString, fitState, (\"fit\", AtomicString::ConstructFromLiteral));\n        return fitState;\n    }\n    case RegionEmpty: {\n        DEFINE_STATIC_LOCAL(AtomicString, emptyState, (\"empty\", AtomicString::ConstructFromLiteral));\n        return emptyState;\n    }\n    case RegionOverset: {\n        DEFINE_STATIC_LOCAL(AtomicString, overflowState, (\"overset\", AtomicString::ConstructFromLiteral));\n        return overflowState;\n    }\n    case RegionUndefined:\n        return undefinedState;\n    }\n    ASSERT_NOT_REACHED();\n    return undefinedState;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":120688
  },
  {
    "code":"ChunkedUploadDataStream::ChunkedUploadDataStream(int64_t identifier)\n    : UploadDataStream(true, identifier),\n      read_index_(0),\n      read_offset_(0),\n      all_data_appended_(false),\n      read_buffer_len_(0),\n      weak_factory_(this) {}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":169426
  },
  {
    "code":"void GDataFileSystem::OnGetFileCompleteForCopy(\n    const FilePath& remote_dest_file_path,\n    const FileOperationCallback& callback,\n    GDataFileError error,\n    const FilePath& local_file_path,\n    const std::string& unused_mime_type,\n    GDataFileType file_type) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(!callback.is_null());\n  if (error != GDATA_FILE_OK) {\n    callback.Run(error);\n    return;\n  }\n  DCHECK_EQ(REGULAR_FILE, file_type);\n  BrowserThread::PostTask(\n      BrowserThread::UI,\n      FROM_HERE,\n      base::Bind(&GDataFileSystem::TransferRegularFile,\n                 ui_weak_ptr_,\n                 local_file_path, remote_dest_file_path,\n                 base::Bind(OnTransferRegularFileCompleteForCopy,\n                            callback,\n                            base::MessageLoopProxy::current())));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":125410
  },
  {
    "code":"Status IndexedDBDatabase::OpenInternal() {\n  bool found = false;\n  Status s = metadata_coding_->ReadMetadataForDatabaseName(\n      backing_store_->db(), backing_store_->origin_identifier(), metadata_.name,\n      &metadata_, &found);\n  DCHECK(found == (metadata_.id != kInvalidId))\n      << \"found = \" << found << \" id = \" << metadata_.id;\n  if (!s.ok() || found)\n    return s;\n  return metadata_coding_->CreateDatabase(\n      backing_store_->db(), backing_store_->origin_identifier(), metadata_.name,\n      metadata_.version, &metadata_);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":164642
  },
  {
    "code":"bool HTMLInputElement::PatternMismatch() const {\n  return willValidate() && input_type_->PatternMismatch(value());\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":136940
  },
  {
    "code":"process_fw_state_change_wq(struct work_struct *work)\n{\n  struct megasas_instance *instance =\n    container_of(work, struct megasas_instance, work_init);\n  u32 wait;\n  unsigned long flags;\n    if (atomic_read(&instance->adprecovery) != MEGASAS_ADPRESET_SM_INFAULT) {\n    dev_notice(&instance->pdev->dev, \"error, recovery st %x\\n\",\n        atomic_read(&instance->adprecovery));\n    return ;\n  }\n  if (atomic_read(&instance->adprecovery) == MEGASAS_ADPRESET_SM_INFAULT) {\n    dev_notice(&instance->pdev->dev, \"FW detected to be in fault\"\n          \"state, restarting it...\\n\");\n    instance->instancet->disable_intr(instance);\n    atomic_set(&instance->fw_outstanding, 0);\n    atomic_set(&instance->fw_reset_no_pci_access, 1);\n    instance->instancet->adp_reset(instance, instance->reg_set);\n    atomic_set(&instance->fw_reset_no_pci_access, 0);\n    dev_notice(&instance->pdev->dev, \"FW restarted successfully,\"\n          \"initiating next stage...\\n\");\n    dev_notice(&instance->pdev->dev, \"HBA recovery state machine,\"\n          \"state 2 starting...\\n\");\n    for (wait = 0; wait < 30; wait++) {\n      msleep(1000);\n    }\n    if (megasas_transition_to_ready(instance, 1)) {\n      dev_notice(&instance->pdev->dev, \"adapter not ready\\n\");\n      atomic_set(&instance->fw_reset_no_pci_access, 1);\n      megaraid_sas_kill_hba(instance);\n      return ;\n    }\n    if ((instance->pdev->device == PCI_DEVICE_ID_LSI_SAS1064R) ||\n      (instance->pdev->device == PCI_DEVICE_ID_DELL_PERC5) ||\n      (instance->pdev->device == PCI_DEVICE_ID_LSI_VERDE_ZCR)\n      ) {\n      *instance->consumer = *instance->producer;\n    } else {\n      *instance->consumer = 0;\n      *instance->producer = 0;\n    }\n    megasas_issue_init_mfi(instance);\n    spin_lock_irqsave(&instance->hba_lock, flags);\n    atomic_set(&instance->adprecovery, MEGASAS_HBA_OPERATIONAL);\n    spin_unlock_irqrestore(&instance->hba_lock, flags);\n    instance->instancet->enable_intr(instance);\n    megasas_issue_pending_cmds_again(instance);\n    instance->issuepend_done = 1;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":90432
  },
  {
    "code":"static int __videobuf_copy_to_user ( struct videobuf_queue *q,\n        char __user *data, size_t count,\n        int nonblocking )\n{\n  struct videbuf_vmalloc_memory *mem=q->read_buf->priv;\n  BUG_ON (!mem);\n  MAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n  BUG_ON (!mem->vmalloc);\n  if (count > q->read_buf->size - q->read_off)\n    count = q->read_buf->size - q->read_off;\n  if (copy_to_user(data, mem->vmalloc+q->read_off, count))\n    return -EFAULT;\n  return count;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":74705
  },
  {
    "code":"void ChromotingInstance::OnConnectionReady(bool ready) {\n  scoped_ptr<base::DictionaryValue> data(new base::DictionaryValue());\n  data->SetBoolean(\"ready\", ready);\n  PostChromotingMessage(\"onConnectionReady\", data.Pass());\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":108709
  },
  {
    "code":"Eina_Bool ewk_view_zoom_animated_set(Evas_Object* ewkView, float zoom, float duration, Evas_Coord centerX, Evas_Coord centerY)\n{\n    double now;\n    EWK_VIEW_SD_GET_OR_RETURN(ewkView, smartData, false);\n    EWK_VIEW_PRIV_GET_OR_RETURN(smartData, priv, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api, false);\n    EINA_SAFETY_ON_NULL_RETURN_VAL(smartData->api->zoom_weak_set, false);\n    if (!priv->settings.zoomRange.userScalable) {\n        WRN(\"userScalable is false\");\n        return false;\n    }\n    if (zoom < priv->settings.zoomRange.minScale) {\n        WRN(\"zoom level is < %f : %f\", priv->settings.zoomRange.minScale, zoom);\n        return false;\n    }\n    if (zoom > priv->settings.zoomRange.maxScale) {\n        WRN(\"zoom level is > %f : %f\", priv->settings.zoomRange.maxScale, zoom);\n        return false;\n    }\n    if (priv->animatedZoom.animator)\n        priv->animatedZoom.zoom.start = _ewk_view_zoom_animated_current(priv);\n    else {\n        priv->animatedZoom.zoom.start = ewk_frame_page_zoom_get(smartData->main_frame);\n        _ewk_view_zoom_animation_start(smartData);\n    }\n    if (centerX < 0)\n        centerX = 0;\n    if (centerY < 0)\n        centerY = 0;\n    now = ecore_loop_time_get();\n    priv->animatedZoom.time.start = now;\n    priv->animatedZoom.time.end = now + duration;\n    priv->animatedZoom.time.duration = duration;\n    priv->animatedZoom.zoom.end = zoom;\n    priv->animatedZoom.zoom.range = (priv->animatedZoom.zoom.end - priv->animatedZoom.zoom.start);\n    priv->animatedZoom.center.x = centerX;\n    priv->animatedZoom.center.y = centerY;\n    smartData->animated_zoom.zoom.current = priv->animatedZoom.zoom.start;\n    smartData->animated_zoom.zoom.start = priv->animatedZoom.zoom.start;\n    smartData->animated_zoom.zoom.end = priv->animatedZoom.zoom.end;\n    return true;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":107691
  },
  {
    "code":"MemoryInstrumentation::MemoryInstrumentation(\n    service_manager::Connector* connector,\n    const std::string& service_name)\n    : connector_(connector),\n      connector_task_runner_(base::ThreadTaskRunnerHandle::Get()),\n      tls_coordinator_(&DestroyCoordinatorTLS),\n      service_name_(service_name) {\n  DCHECK(connector_task_runner_);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":162919
  },
  {
    "code":"static void run_user_tick_functions(int tick_count) \n{\n  TSRMLS_FETCH();\n  zend_llist_apply(BG(user_tick_functions), (llist_apply_func_t) user_tick_function_call TSRMLS_CC);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":4329
  },
  {
    "code":"sc_pkcs15emu_add_prkey(sc_pkcs15_card_t *p15card,\n                const sc_pkcs15_id_t *id,\n                const char *label,\n                int type, unsigned int modulus_length, int usage,\n                const sc_path_t *path, int ref,\n                const sc_pkcs15_id_t *auth_id, int obj_flags)\n{\n  sc_pkcs15_prkey_info_t *info;\n  info = calloc(1, sizeof(*info));\n  if (!info)\n  {\n    LOG_FUNC_RETURN(p15card->card->ctx, SC_ERROR_OUT_OF_MEMORY);\n  }\n  info->id                = *id;\n  info->modulus_length    = modulus_length;\n  info->usage             = usage;\n  info->native            = 1;\n  info->access_flags      = SC_PKCS15_PRKEY_ACCESS_SENSITIVE\n                                | SC_PKCS15_PRKEY_ACCESS_ALWAYSSENSITIVE\n                                | SC_PKCS15_PRKEY_ACCESS_NEVEREXTRACTABLE\n                                | SC_PKCS15_PRKEY_ACCESS_LOCAL;\n  info->key_reference     = ref;\n  if (path)\n    info->path = *path;\n  return sc_pkcs15emu_add_object(p15card, type, label,\n      info, auth_id, obj_flags);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":78800
  },
  {
    "code":"  TabManager* tab_manager() { return g_browser_process->GetTabManager(); }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":144828
  },
  {
    "code":"void RenderViewTest::SetFocused(const blink::WebNode& node) {\n  RenderViewImpl* impl = static_cast<RenderViewImpl*>(view_);\n  impl->focusedNodeChanged(blink::WebNode(), node);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":132164
  },
  {
    "code":"static __always_inline void vmcs_write64(unsigned long field, u64 value)\n{\n  vmcs_check64(field);\n  __vmcs_writel(field, value);\n#ifndef CONFIG_X86_64\n  asm volatile (\"\");\n  __vmcs_writel(field+1, value >> 32);\n#endif\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":48106
  },
  {
    "code":"v8::Persistent<v8::FunctionTemplate> V8TestActiveDOMObject::GetTemplate()\n{\n    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();\n    V8BindingPerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);\n    if (result != data->templateMap().end())\n        return result->second;\n    v8::HandleScope handleScope;\n    v8::Persistent<v8::FunctionTemplate> templ =\n        ConfigureV8TestActiveDOMObjectTemplate(GetRawTemplate());\n    data->templateMap().add(&info, templ);\n    return templ;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":117717
  },
  {
    "code":"void GpuProcessHost::DeleteImage(\n    int client_id,\n    int image_id,\n    int sync_point) {\n  TRACE_EVENT0(\"gpu\", \"GpuProcessHostUIShim::DeleteImage\");\n  DCHECK(CalledOnValidThread());\n  Send(new GpuMsg_DeleteImage(client_id, image_id, sync_point));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":122786
  },
  {
    "code":"MockCryptohomeLibrary* CrosMock::mock_cryptohome_library() {\n  return mock_cryptohome_library_;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":104512
  },
  {
    "code":"unsigned char *ssl_add_clienthello_tlsext(SSL *s, unsigned char *buf,\n                                          unsigned char *limit, int *al)\n{\n    int extdatalen = 0;\n    unsigned char *orig = buf;\n    unsigned char *ret = buf;\n# ifndef OPENSSL_NO_EC\n    int using_ecc = 0;\n    if (s->version >= TLS1_VERSION || SSL_IS_DTLS(s)) {\n        int i;\n        unsigned long alg_k, alg_a;\n        STACK_OF(SSL_CIPHER) *cipher_stack = SSL_get_ciphers(s);\n        for (i = 0; i < sk_SSL_CIPHER_num(cipher_stack); i++) {\n            SSL_CIPHER *c = sk_SSL_CIPHER_value(cipher_stack, i);\n            alg_k = c->algorithm_mkey;\n            alg_a = c->algorithm_auth;\n            if ((alg_k & (SSL_kEECDH | SSL_kECDHr | SSL_kECDHe)\n                 || (alg_a & SSL_aECDSA))) {\n                using_ecc = 1;\n                break;\n            }\n        }\n    }\n# endif\n    if (s->client_version == SSL3_VERSION && !s->s3->send_connection_binding)\n        return orig;\n    ret += 2;\n    if (ret >= limit)\n        return NULL;            \n    if (s->tlsext_hostname != NULL) {\n        unsigned long size_str;\n        long lenmax;\n        if ((lenmax = limit - ret - 9) < 0\n            || (size_str =\n                strlen(s->tlsext_hostname)) > (unsigned long)lenmax)\n            return NULL;\n        s2n(TLSEXT_TYPE_server_name, ret);\n        s2n(size_str + 5, ret);\n        s2n(size_str + 3, ret);\n        *(ret++) = (unsigned char)TLSEXT_NAMETYPE_host_name;\n        s2n(size_str, ret);\n        memcpy(ret, s->tlsext_hostname, size_str);\n        ret += size_str;\n    }\n    if (s->renegotiate) {\n        int el;\n        if (!ssl_add_clienthello_renegotiate_ext(s, 0, &el, 0)) {\n            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        if ((limit - ret - 4 - el) < 0)\n            return NULL;\n        s2n(TLSEXT_TYPE_renegotiate, ret);\n        s2n(el, ret);\n        if (!ssl_add_clienthello_renegotiate_ext(s, ret, &el, el)) {\n            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        ret += el;\n    }\n# ifndef OPENSSL_NO_SRP\n    if (s->srp_ctx.login != NULL) { \n        int login_len = strlen(s->srp_ctx.login);\n        if (login_len > 255 || login_len == 0) {\n            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        if ((limit - ret - 5 - login_len) < 0)\n            return NULL;\n        s2n(TLSEXT_TYPE_srp, ret);\n        s2n(login_len + 1, ret);\n        (*ret++) = (unsigned char)login_len;\n        memcpy(ret, s->srp_ctx.login, login_len);\n        ret += login_len;\n    }\n# endif\n# ifndef OPENSSL_NO_EC\n    if (using_ecc) {\n        long lenmax;\n        const unsigned char *pcurves, *pformats;\n        size_t num_curves, num_formats, curves_list_len;\n        tls1_get_formatlist(s, &pformats, &num_formats);\n        if ((lenmax = limit - ret - 5) < 0)\n            return NULL;\n        if (num_formats > (size_t)lenmax)\n            return NULL;\n        if (num_formats > 255) {\n            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        s2n(TLSEXT_TYPE_ec_point_formats, ret);\n        s2n(num_formats + 1, ret);\n        *(ret++) = (unsigned char)num_formats;\n        memcpy(ret, pformats, num_formats);\n        ret += num_formats;\n        pcurves = s->tlsext_ellipticcurvelist;\n        if (!tls1_get_curvelist(s, 0, &pcurves, &num_curves))\n            return NULL;\n        if ((lenmax = limit - ret - 6) < 0)\n            return NULL;\n        if (num_curves > (size_t)lenmax \/ 2)\n            return NULL;\n        if (num_curves > 65532 \/ 2) {\n            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        curves_list_len = 2 * num_curves;\n        s2n(TLSEXT_TYPE_elliptic_curves, ret);\n        s2n(curves_list_len + 2, ret);\n        s2n(curves_list_len, ret);\n        memcpy(ret, pcurves, curves_list_len);\n        ret += curves_list_len;\n    }\n# endif                         \n    if (!(SSL_get_options(s) & SSL_OP_NO_TICKET)) {\n        int ticklen;\n        if (!s->new_session && s->session && s->session->tlsext_tick)\n            ticklen = s->session->tlsext_ticklen;\n        else if (s->session && s->tlsext_session_ticket &&\n                 s->tlsext_session_ticket->data) {\n            ticklen = s->tlsext_session_ticket->length;\n            s->session->tlsext_tick = OPENSSL_malloc(ticklen);\n            if (!s->session->tlsext_tick)\n                return NULL;\n            memcpy(s->session->tlsext_tick,\n                   s->tlsext_session_ticket->data, ticklen);\n            s->session->tlsext_ticklen = ticklen;\n        } else\n            ticklen = 0;\n        if (ticklen == 0 && s->tlsext_session_ticket &&\n            s->tlsext_session_ticket->data == NULL)\n            goto skip_ext;\n        if ((long)(limit - ret - 4 - ticklen) < 0)\n            return NULL;\n        s2n(TLSEXT_TYPE_session_ticket, ret);\n        s2n(ticklen, ret);\n        if (ticklen) {\n            memcpy(ret, s->session->tlsext_tick, ticklen);\n            ret += ticklen;\n        }\n    }\n skip_ext:\n    if (SSL_USE_SIGALGS(s)) {\n        size_t salglen;\n        const unsigned char *salg;\n        salglen = tls12_get_psigalgs(s, &salg);\n        if ((size_t)(limit - ret) < salglen + 6)\n            return NULL;\n        s2n(TLSEXT_TYPE_signature_algorithms, ret);\n        s2n(salglen + 2, ret);\n        s2n(salglen, ret);\n        memcpy(ret, salg, salglen);\n        ret += salglen;\n    }\n# ifdef TLSEXT_TYPE_opaque_prf_input\n    if (s->s3->client_opaque_prf_input != NULL) {\n        size_t col = s->s3->client_opaque_prf_input_len;\n        if ((long)(limit - ret - 6 - col < 0))\n            return NULL;\n        if (col > 0xFFFD)       \n            return NULL;\n        s2n(TLSEXT_TYPE_opaque_prf_input, ret);\n        s2n(col + 2, ret);\n        s2n(col, ret);\n        memcpy(ret, s->s3->client_opaque_prf_input, col);\n        ret += col;\n    }\n# endif\n    if (s->tlsext_status_type == TLSEXT_STATUSTYPE_ocsp) {\n        int i;\n        long extlen, idlen, itmp;\n        OCSP_RESPID *id;\n        idlen = 0;\n        for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++) {\n            id = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);\n            itmp = i2d_OCSP_RESPID(id, NULL);\n            if (itmp <= 0)\n                return NULL;\n            idlen += itmp + 2;\n        }\n        if (s->tlsext_ocsp_exts) {\n            extlen = i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, NULL);\n            if (extlen < 0)\n                return NULL;\n        } else\n            extlen = 0;\n        if ((long)(limit - ret - 7 - extlen - idlen) < 0)\n            return NULL;\n        s2n(TLSEXT_TYPE_status_request, ret);\n        if (extlen + idlen > 0xFFF0)\n            return NULL;\n        s2n(extlen + idlen + 5, ret);\n        *(ret++) = TLSEXT_STATUSTYPE_ocsp;\n        s2n(idlen, ret);\n        for (i = 0; i < sk_OCSP_RESPID_num(s->tlsext_ocsp_ids); i++) {\n            unsigned char *q = ret;\n            id = sk_OCSP_RESPID_value(s->tlsext_ocsp_ids, i);\n            ret += 2;\n            itmp = i2d_OCSP_RESPID(id, &ret);\n            s2n(itmp, q);\n        }\n        s2n(extlen, ret);\n        if (extlen > 0)\n            i2d_X509_EXTENSIONS(s->tlsext_ocsp_exts, &ret);\n    }\n# ifndef OPENSSL_NO_HEARTBEATS\n    if ((limit - ret - 4 - 1) < 0)\n        return NULL;\n    s2n(TLSEXT_TYPE_heartbeat, ret);\n    s2n(1, ret);\n    if (s->tlsext_heartbeat & SSL_TLSEXT_HB_DONT_RECV_REQUESTS)\n        *(ret++) = SSL_TLSEXT_HB_DONT_SEND_REQUESTS;\n    else\n        *(ret++) = SSL_TLSEXT_HB_ENABLED;\n# endif\n# ifndef OPENSSL_NO_NEXTPROTONEG\n    if (s->ctx->next_proto_select_cb && !s->s3->tmp.finish_md_len) {\n        if (limit - ret - 4 < 0)\n            return NULL;\n        s2n(TLSEXT_TYPE_next_proto_neg, ret);\n        s2n(0, ret);\n    }\n# endif\n    if (s->alpn_client_proto_list && !s->s3->tmp.finish_md_len) {\n        if ((size_t)(limit - ret) < 6 + s->alpn_client_proto_list_len)\n            return NULL;\n        s2n(TLSEXT_TYPE_application_layer_protocol_negotiation, ret);\n        s2n(2 + s->alpn_client_proto_list_len, ret);\n        s2n(s->alpn_client_proto_list_len, ret);\n        memcpy(ret, s->alpn_client_proto_list, s->alpn_client_proto_list_len);\n        ret += s->alpn_client_proto_list_len;\n    }\n# ifndef OPENSSL_NO_SRTP\n    if (SSL_IS_DTLS(s) && SSL_get_srtp_profiles(s)) {\n        int el;\n        ssl_add_clienthello_use_srtp_ext(s, 0, &el, 0);\n        if ((limit - ret - 4 - el) < 0)\n            return NULL;\n        s2n(TLSEXT_TYPE_use_srtp, ret);\n        s2n(el, ret);\n        if (ssl_add_clienthello_use_srtp_ext(s, ret, &el, el)) {\n            SSLerr(SSL_F_SSL_ADD_CLIENTHELLO_TLSEXT, ERR_R_INTERNAL_ERROR);\n            return NULL;\n        }\n        ret += el;\n    }\n# endif\n    custom_ext_init(&s->cert->cli_ext);\n    if (!custom_ext_add(s, 0, &ret, limit, al))\n        return NULL;\n    if (s->options & SSL_OP_TLSEXT_PADDING) {\n        int hlen = ret - (unsigned char *)s->init_buf->data;\n        if (s->state == SSL23_ST_CW_CLNT_HELLO_A)\n            hlen -= 5;\n        if (hlen > 0xff && hlen < 0x200) {\n            hlen = 0x200 - hlen;\n            if (hlen >= 4)\n                hlen -= 4;\n            else\n                hlen = 0;\n            s2n(TLSEXT_TYPE_padding, ret);\n            s2n(hlen, ret);\n            memset(ret, 0, hlen);\n            ret += hlen;\n        }\n    }\n    if ((extdatalen = ret - orig - 2) == 0)\n        return orig;\n    s2n(extdatalen, orig);\n    return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":6135
  },
  {
    "code":"static void UTF8ToMacRoman ( const std::string & utf8, std::string * macRoman )\n{\n  macRoman->erase();\n  bool inNonMRSpan = false;\n  for ( const XMP_Uns8 * chPtr = (XMP_Uns8*)utf8.c_str(); *chPtr != 0; ++chPtr ) {  \n    if ( *chPtr < 0x80 ) {\n      (*macRoman) += (char)*chPtr;\n      inNonMRSpan = false;\n    } else {\n      XMP_Uns32 cp = GetCodePoint ( &chPtr );\n      --chPtr;  \n      XMP_Uns8  mr;\n      for ( mr = 0; (mr < 0x80) && (cp != kMacRomanCP[mr]); ++mr ) {};  \n      if ( mr < 0x80 ) {\n        (*macRoman) += (char)(mr+0x80);\n        inNonMRSpan = false;\n      } else if ( ! inNonMRSpan ) {\n        (*macRoman) += '?';\n        inNonMRSpan = true;\n      }\n    }\n  }\n}  \n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":15904
  },
  {
    "code":"void Document::didChangeVisibilityState()\n{\n    dispatchEvent(Event::create(EventTypeNames::visibilitychange));\n    dispatchEvent(Event::create(EventTypeNames::webkitvisibilitychange));\n    PageVisibilityState state = pageVisibilityState();\n    for (DocumentVisibilityObserver* observer : m_visibilityObservers)\n        observer->didChangeVisibilityState(state);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":138413
  },
  {
    "code":"static int rle4_compress_row(struct rle_context *rlectx)\n{\n  size_t i;\n  iw_byte dstbuf[2];\n  iw_byte next_pix;\n  int next_pix_is_trns;\n  int num_trns = 0; \n  int retval = 0;\n  iw_byte tmpb;\n  rlectx->pending_data_start=0;\n  rlectx->unc_len=0;\n  rlectx->run_len=0;\n  for(i=0;i<rlectx->img_width;i++) {\n    next_pix = rlectx->srcrow[i];\n    next_pix_is_trns = (rlectx->wctx->pal->entry[next_pix].a==0);\n    if(num_trns>0 && !next_pix_is_trns) {\n      rle_write_trns(rlectx,num_trns);\n      num_trns=0;\n    }\n    else if(next_pix_is_trns) {\n      if (rlectx->unc_len>0 || rlectx->run_len>0) {\n        rle4_write_unc_and_run(rlectx);\n      }\n      num_trns++;\n      continue;\n    }\n    if(rlectx->run_len==0) {\n      rlectx->run_len = 1;\n      rlectx->run_byte = next_pix<<4;\n    }\n    else if(rlectx->run_len==1) {\n      rlectx->run_byte |= next_pix;\n      rlectx->run_len++;\n    }\n    else if(rlectx->run_len>=2 && (rlectx->run_len&1)==0 && next_pix==(rlectx->run_byte>>4)) {\n      rlectx->run_len++;\n    }\n    else if(rlectx->run_len>=3 && (rlectx->run_len&1) && next_pix==(rlectx->run_byte&0x0f)) {\n      rlectx->run_len++;\n    }\n    else if(rlectx->unc_len==0 && rlectx->run_len==2) {\n      rlectx->unc_len+=rlectx->run_len;\n      rlectx->run_byte = next_pix<<4;\n      rlectx->run_len = 1;\n    }\n    else if(ok_to_move_to_unc(rlectx)) {\n      rlectx->unc_len += rlectx->run_len-1;\n      if((rlectx->run_len&1)==0)\n        rlectx->run_byte = (rlectx->run_byte&0x0f)<<4;\n      else\n        rlectx->run_byte = (rlectx->run_byte&0xf0);\n      rlectx->run_len = 2;\n      rlectx->run_byte |= next_pix;\n    }\n    else {\n      rle4_write_unc_and_run(rlectx);\n      rlectx->run_len = 1;\n      rlectx->run_byte = next_pix<<4;\n    }\n    while(rlectx->unc_len>0 && rlectx->run_len>0 && rle4_get_incr_unc_cost(rlectx)==0) {\n      rlectx->unc_len++;\n      rlectx->run_len--;\n      tmpb = rlectx->run_byte;\n      rlectx->run_byte = (tmpb>>4) | ((tmpb&0x0f)<<4);\n      if(rlectx->run_len==1) rlectx->run_byte &= 0xf0;\n    }\n    if(rlectx->run_len>=255) {\n      rle4_write_unc_and_run(rlectx);\n    }\n    if(rlectx->run_len>255) {\n      iw_set_error(rlectx->ctx,\"Internal: BMP RLE encode error 3\");\n      goto done;\n    }\n  }\n  rle4_write_unc_and_run(rlectx);\n  dstbuf[0]=0x00;\n  dstbuf[1]= (rlectx->cur_row==0)? 0x01 : 0x00;\n  iwbmp_write(rlectx->wctx,dstbuf,2);\n  rlectx->total_bytes_written+=2;\n  retval = 1;\ndone:\n  return retval;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":64884
  },
  {
    "code":"PHP_RSHUTDOWN_FUNCTION(gd)\n{\n#if HAVE_GD_FONTCACHESHUTDOWN\n  gdFontCacheShutdown();\n#else\n  gdFreeFontCache();\n#endif\n  return SUCCESS;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":15182
  },
  {
    "code":"void Browser::RendererResponsive(\n    WebContents* source,\n    content::RenderWidgetHost* render_widget_host) {\n  TabDialogs::FromWebContents(source)->HideHungRendererDialog(\n      render_widget_host);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":158849
  },
  {
    "code":"  void OnReceivedRoutingIDOnUI(int widget_routing_id) {\n    routing_id_ = widget_routing_id;\n    run_loop_.Quit();\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":156678
  },
  {
    "code":"void tty_free_file(struct file *file)\n{\n  struct tty_file_private *priv = file->private_data;\n  file->private_data = NULL;\n  kfree(priv);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":55917
  },
  {
    "code":"trad_enc_decypt_byte(struct trad_enc_ctx *ctx)\n{\n  unsigned temp = ctx->keys[2] | 2;\n  return (uint8_t)((temp * (temp ^ 1)) >> 8) & 0xff;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":55730
  },
  {
    "code":"static int dm_request_for_irq_injection(struct kvm_vcpu *vcpu)\n{\n  return (!irqchip_in_kernel(vcpu->kvm) && !kvm_cpu_has_interrupt(vcpu) &&\n    vcpu->run->request_interrupt_window &&\n    kvm_arch_interrupt_allowed(vcpu));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":20660
  },
  {
    "code":"static int decode_fctl_chunk(AVCodecContext *avctx, PNGDecContext *s,\n                             uint32_t length)\n{\n    uint32_t sequence_number;\n    int cur_w, cur_h, x_offset, y_offset, dispose_op, blend_op;\n    if (length != 26)\n        return AVERROR_INVALIDDATA;\n    if (!(s->state & PNG_IHDR)) {\n        av_log(avctx, AV_LOG_ERROR, \"fctl before IHDR\\n\");\n        return AVERROR_INVALIDDATA;\n    }\n    s->last_w = s->cur_w;\n    s->last_h = s->cur_h;\n    s->last_x_offset = s->x_offset;\n    s->last_y_offset = s->y_offset;\n    s->last_dispose_op = s->dispose_op;\n    sequence_number = bytestream2_get_be32(&s->gb);\n    cur_w           = bytestream2_get_be32(&s->gb);\n    cur_h           = bytestream2_get_be32(&s->gb);\n    x_offset        = bytestream2_get_be32(&s->gb);\n    y_offset        = bytestream2_get_be32(&s->gb);\n    bytestream2_skip(&s->gb, 4); \n    dispose_op      = bytestream2_get_byte(&s->gb);\n    blend_op        = bytestream2_get_byte(&s->gb);\n    bytestream2_skip(&s->gb, 4); \n    if (sequence_number == 0 &&\n        (cur_w != s->width ||\n         cur_h != s->height ||\n         x_offset != 0 ||\n         y_offset != 0) ||\n        cur_w <= 0 || cur_h <= 0 ||\n        x_offset < 0 || y_offset < 0 ||\n        cur_w > s->width - x_offset|| cur_h > s->height - y_offset)\n            return AVERROR_INVALIDDATA;\n    if (blend_op != APNG_BLEND_OP_OVER && blend_op != APNG_BLEND_OP_SOURCE) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid blend_op %d\\n\", blend_op);\n        return AVERROR_INVALIDDATA;\n    }\n    if ((sequence_number == 0 || !s->previous_picture.f->data[0]) &&\n        dispose_op == APNG_DISPOSE_OP_PREVIOUS) {\n        dispose_op = APNG_DISPOSE_OP_BACKGROUND;\n    }\n    if (blend_op == APNG_BLEND_OP_OVER && !s->has_trns && (\n            avctx->pix_fmt == AV_PIX_FMT_RGB24 ||\n            avctx->pix_fmt == AV_PIX_FMT_RGB48BE ||\n            avctx->pix_fmt == AV_PIX_FMT_PAL8 ||\n            avctx->pix_fmt == AV_PIX_FMT_GRAY8 ||\n            avctx->pix_fmt == AV_PIX_FMT_GRAY16BE ||\n            avctx->pix_fmt == AV_PIX_FMT_MONOBLACK\n        )) {\n        blend_op = APNG_BLEND_OP_SOURCE;\n    }\n    s->cur_w      = cur_w;\n    s->cur_h      = cur_h;\n    s->x_offset   = x_offset;\n    s->y_offset   = y_offset;\n    s->dispose_op = dispose_op;\n    s->blend_op   = blend_op;\n    return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":66921
  },
  {
    "code":"filter_list_free (GList *filters)\n{\n  g_list_free_full (filters, (GDestroyNotify)filter_free);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":84368
  },
  {
    "code":"void av_freep(void *arg)\n{\n    void **ptr = (void **)arg;\n    av_free(*ptr);\n    *ptr = NULL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":29700
  },
  {
    "code":"bool ChromeClientImpl::ShouldOpenModalDialogDuringPageDismissal(\n    LocalFrame& frame,\n    DialogType dialog_type,\n    const String& dialog_message,\n    Document::PageDismissalType dismissal_type) const {\n  String message = String(\"Blocked \") + DialogTypeToString(dialog_type) + \"('\" +\n                   dialog_message + \"') during \" +\n                   DismissalTypeToString(dismissal_type) + \".\";\n  WebLocalFrameImpl::FromFrame(frame)->AddMessageToConsole(\n      WebConsoleMessage(WebConsoleMessage::kLevelError, message));\n  return false;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":161009
  },
  {
    "code":"bool Smb4KGlobal::addWorkgroup( Smb4KWorkgroup *workgroup )\n{\n  Q_ASSERT( workgroup );\n  bool added = false;\n  mutex.lock();\n  if ( !findWorkgroup( workgroup->workgroupName() ) )\n  {\n    p->workgroupsList.append( workgroup );\n    added = true;\n  }\n  else\n  {\n  }\n  mutex.unlock();\n  return added;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":6555
  },
  {
    "code":"static void pmcraid_release_chrdev(struct pmcraid_instance *pinstance)\n{\n  pmcraid_release_minor(MINOR(pinstance->cdev.dev));\n  device_destroy(pmcraid_class,\n           MKDEV(pmcraid_major, MINOR(pinstance->cdev.dev)));\n  cdev_del(&pinstance->cdev);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":26492
  },
  {
    "code":"int BN_GF2m_arr2poly(const int p[], BIGNUM *a)\n{\n    int i;\n    bn_check_top(a);\n    BN_zero(a);\n    for (i = 0; p[i] != -1; i++) {\n        if (BN_set_bit(a, p[i]) == 0)\n            return 0;\n    }\n    bn_check_top(a);\n    return 1;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":44251
  },
  {
    "code":"static long hugepage_subpool_get_pages(struct hugepage_subpool *spool,\n              long delta)\n{\n  long ret = delta;\n  if (!spool)\n    return ret;\n  spin_lock(&spool->lock);\n  if (spool->max_hpages != -1) {    \n    if ((spool->used_hpages + delta) <= spool->max_hpages)\n      spool->used_hpages += delta;\n    else {\n      ret = -ENOMEM;\n      goto unlock_ret;\n    }\n  }\n  if (spool->min_hpages != -1 && spool->rsv_hpages) {\n    if (delta > spool->rsv_hpages) {\n      ret = delta - spool->rsv_hpages;\n      spool->rsv_hpages = 0;\n    } else {\n      ret = 0;  \n      spool->rsv_hpages -= delta;\n    }\n  }\nunlock_ret:\n  spin_unlock(&spool->lock);\n  return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":86367
  },
  {
    "code":"static iw_tmpsample get_raw_sample_flt32(struct iw_context *ctx,\n     int x, int y, int channel)\n{\n  size_t z;\n  z = y*ctx->img1.bpr + (ctx->img1_numchannels_physical*x + channel)*4;\n  return (iw_tmpsample)iw_get_float32(&ctx->img1.pixels[z]);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":64912
  },
  {
    "code":"  bool Connecting() const { return false; }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":100227
  },
  {
    "code":"void HTMLConstructionSite::insertHTMLBodyElement(AtomicHTMLToken& token)\n{\n    ASSERT(!shouldFosterParent());\n    m_openElements.pushHTMLBodyElement(attachToCurrent(createHTMLElement(token)));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":98927
  },
  {
    "code":"static int macvtap_receive(struct sk_buff *skb)\n{\n  skb_push(skb, ETH_HLEN);\n  return macvtap_forward(skb->dev, skb);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":34574
  },
  {
    "code":"GF_Err cat_multiple_files(GF_ISOFile *dest, char *fileName, u32 import_flags, Double force_fps, u32 frames_per_sample, char *tmp_dir, Bool force_cat, Bool align_timelines, Bool allow_add_in_command)\n{\n  CATEnum cat_enum;\n  char *sep;\n  cat_enum.dest = dest;\n  cat_enum.import_flags = import_flags;\n  cat_enum.force_fps = force_fps;\n  cat_enum.frames_per_sample = frames_per_sample;\n  cat_enum.tmp_dir = tmp_dir;\n  cat_enum.force_cat = force_cat;\n   cat_enum.align_timelines = align_timelines;\n   cat_enum.allow_add_in_command = allow_add_in_command;\n   strcpy(cat_enum.szPath, fileName);\n   sep = strrchr(cat_enum.szPath, GF_PATH_SEPARATOR);\n   if (!sep) sep = strrchr(cat_enum.szPath, '\/');\n   if (!sep) {\n     strcpy(cat_enum.szPath, \".\");\n     strcpy(cat_enum.szRad1, fileName);\n   } else {\n     strcpy(cat_enum.szRad1, sep+1);\n     sep[0] = 0;\n   }\n   sep = strchr(cat_enum.szRad1, '*');\n   strcpy(cat_enum.szRad2, sep+1);\n   sep[0] = 0;\n   sep = strchr(cat_enum.szRad2, '%');\n   if (!sep) sep = strchr(cat_enum.szRad2, '#');\n   if (!sep) sep = strchr(cat_enum.szRad2, ':');\n   strcpy(cat_enum.szOpt, \"\");\n   if (sep) {\n     strcpy(cat_enum.szOpt, sep);\n     sep[0] = 0;\n   }\n  return gf_enum_directory(cat_enum.szPath, 0, cat_enumerate, &cat_enum, NULL);\n}\n",
    "vul":1,
    "flaw_line_no":[
      13,
      14,
      15,
      16,
      17,
      18,
      20,
      21,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      34
    ],
    "bigvul_id":182960
  },
  {
    "code":"static void kvm_ioapic_send_eoi(struct kvm_lapic *apic, int vector)\n{\n  if (!(kvm_apic_get_reg(apic, APIC_SPIV) & APIC_SPIV_DIRECTED_EOI) &&\n      kvm_ioapic_handles_vector(apic->vcpu->kvm, vector)) {\n    int trigger_mode;\n    if (apic_test_vector(vector, apic->regs + APIC_TMR))\n      trigger_mode = IOAPIC_LEVEL_TRIG;\n    else\n      trigger_mode = IOAPIC_EDGE_TRIG;\n    kvm_ioapic_update_eoi(apic->vcpu, vector, trigger_mode);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":28773
  },
  {
    "code":"void SyncBackendHost::Core::DoRefreshNigori(\n    const base::Closure& done_callback) {\n  DCHECK_EQ(MessageLoop::current(), sync_loop_);\n  chrome::VersionInfo version_info;\n  sync_manager_->RefreshNigori(version_info.CreateVersionString(),\n                               done_callback);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":111782
  },
  {
    "code":"gfx::Rect TabStripGtk::GetIdealBounds(int index) {\n  DCHECK(index >= 0 && index < GetTabCount());\n  return tab_data_.at(index).ideal_bounds;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":126511
  },
  {
    "code":"static inline unsigned int fold_hash(unsigned long hash)\n{\n  hash += hash >> (8*sizeof(int));\n  return hash;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":36310
  },
  {
    "code":" std::string GenerateRandomID() {\n   uint64 msb = base::RandUint64();\n   uint64 lsb = base::RandUint64();\n  return base::StringPrintf(\"%016\" PRIx64 \"%016\" PRIx64, msb, lsb);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":105634
  },
  {
    "code":"void RenderFrameImpl::DidFinishDocumentLoad() {\n  TRACE_EVENT1(\"navigation,benchmark,rail\",\n               \"RenderFrameImpl::didFinishDocumentLoad\", \"id\", routing_id_);\n  Send(new FrameHostMsg_DidFinishDocumentLoad(routing_id_));\n  {\n    SCOPED_UMA_HISTOGRAM_TIMER(\"RenderFrameObservers.DidFinishDocumentLoad\");\n    for (auto& observer : observers_)\n      observer.DidFinishDocumentLoad();\n  }\n  UpdateEncoding(frame_, frame_->View()->PageEncoding().Utf8());\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":160586
  },
  {
    "code":"struct dentry *d_find_alias(struct inode *inode)\n{\n  struct dentry *de = NULL;\n  if (!hlist_empty(&inode->i_dentry)) {\n    spin_lock(&inode->i_lock);\n    de = __d_find_alias(inode);\n    spin_unlock(&inode->i_lock);\n  }\n  return de;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":67299
  },
  {
    "code":"bool f2fs_init_extent_tree(struct inode *inode, struct f2fs_extent *i_ext)\n {\n   struct f2fs_sb_info *sbi = F2FS_I_SB(inode);\n   struct extent_tree *et;\n  struct extent_node *en;\n  struct extent_info ei;\n  if (!f2fs_may_extent_tree(inode)) {\n    if (i_ext && i_ext->len) {\n      i_ext->len = 0;\n      return true;\n    }\n    return false;\n  }\n  et = __grab_extent_tree(inode);\n  if (!i_ext || !i_ext->len)\n    return false;\n  get_extent_info(&ei, i_ext);\n  write_lock(&et->lock);\n  if (atomic_read(&et->node_cnt))\n    goto out;\n  en = __init_extent_tree(sbi, et, &ei);\n  if (en) {\n    spin_lock(&sbi->extent_lock);\n    list_add_tail(&en->list, &sbi->extent_list);\n    spin_unlock(&sbi->extent_lock);\n  }\nout:\n  write_unlock(&et->lock);\n   return false;\n }\n",
    "vul":1,
    "flaw_line_no":[
      3,
      7,
      8,
      9,
      14,
      15,
      17,
      18,
      19,
      21,
      23,
      24,
      25,
      28
    ],
    "bigvul_id":182588
  },
  {
    "code":"static void log_backtrace(const request_rec *r)\n{\n    const request_rec *top = r;\n    ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00121)\n                  \"r->uri = %s\", r->uri ? r->uri : \"(unexpectedly NULL)\");\n    while (top && (top->prev || top->main)) {\n        if (top->prev) {\n            top = top->prev;\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00122)\n                          \"redirected from r->uri = %s\",\n                          top->uri ? top->uri : \"(unexpectedly NULL)\");\n        }\n        if (!top->prev && top->main) {\n            top = top->main;\n            ap_log_rerror(APLOG_MARK, APLOG_DEBUG, 0, r, APLOGNO(00123)\n                          \"subrequested from r->uri = %s\",\n                          top->uri ? top->uri : \"(unexpectedly NULL)\");\n        }\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":64248
  },
  {
    "code":"void Document::ApplyFeaturePolicy(const ParsedFeaturePolicy& declared_policy) {\n  FeaturePolicy* parent_feature_policy = nullptr;\n  ParsedFeaturePolicy container_policy;\n  if (frame_) {\n    if (!frame_->IsMainFrame()) {\n      parent_feature_policy =\n          frame_->Tree().Parent()->GetSecurityContext()->GetFeaturePolicy();\n    }\n    if (frame_->Owner())\n      container_policy = frame_->Owner()->ContainerPolicy();\n  }\n  InitializeFeaturePolicy(declared_policy, container_policy,\n                          parent_feature_policy);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":167873
  },
  {
    "code":"int deny_write_access(struct file * file)\n{\n  struct inode *inode = file->f_path.dentry->d_inode;\n  spin_lock(&inode->i_lock);\n  if (atomic_read(&inode->i_writecount) > 0) {\n    spin_unlock(&inode->i_lock);\n    return -ETXTBSY;\n  }\n  atomic_dec(&inode->i_writecount);\n  spin_unlock(&inode->i_lock);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":39671
  },
  {
    "code":"void FakeCentral::SetAdvertisingInterval(\n    const base::TimeDelta& min,\n    const base::TimeDelta& max,\n    const base::Closure& callback,\n    const AdvertisementErrorCallback& error_callback) {\n  NOTREACHED();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":150916
  },
  {
    "code":"static int _server_handle_qTfV(libgdbr_t *g, int (*cmd_cb) (void*, const char*, char*, size_t), void *core_ptr) {\n  if (send_ack (g) < 0) {\n    return -1;\n  }\n  return send_msg (g, \"\");\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":64146
  },
  {
    "code":"void virtqueue_map_sg(struct iovec *sg, hwaddr *addr,\n    size_t num_sg, int is_write)\n{\n    unsigned int i;\n    hwaddr len;\n    if (num_sg >= VIRTQUEUE_MAX_SIZE) {\n        error_report(\"virtio: map attempt out of bounds: %zd > %d\",\n                     num_sg, VIRTQUEUE_MAX_SIZE);\n        exit(1);\n    }\n    for (i = 0; i < num_sg; i++) {\n        len = sg[i].iov_len;\n        sg[i].iov_base = cpu_physical_memory_map(addr[i], &len, is_write);\n        if (sg[i].iov_base == NULL || len != sg[i].iov_len) {\n            error_report(\"virtio: trying to map MMIO memory\");\n            exit(1);\n        }\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":14476
  },
  {
    "code":"void r_pkcs7_free_attribute (RPKCS7Attribute* attribute) {\n  if (attribute) {\n    r_asn1_free_object (attribute->data);\n    r_asn1_free_string (attribute->oid);\n    free (attribute);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":67742
  },
  {
    "code":"TestDataReductionProxyConfig::GetInFlightWarmupProxyDetails() const {\n  if (in_flight_warmup_proxy_details_)\n    return in_flight_warmup_proxy_details_;\n  return DataReductionProxyConfig::GetInFlightWarmupProxyDetails();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":157524
  },
  {
    "code":"static void sock_spd_release(struct splice_pipe_desc *spd, unsigned int i)\n{\n  put_page(spd->pages[i]);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":39939
  },
  {
    "code":"void WebSettingsImpl::setLoadsImagesAutomatically(bool loadsImagesAutomatically)\n{\n    m_settings->setLoadsImagesAutomatically(loadsImagesAutomatically);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":100476
  },
  {
    "code":"finish_missing_required_preauth(void *arg)\n{\n    struct as_req_state *state = (struct as_req_state *)arg;\n    finish_process_as_req(state, state->preauth_err);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":63436
  },
  {
    "code":"LayoutUnit RenderFlexibleBox::childIntrinsicHeight(RenderBox* child) const\n{\n    if (child->isHorizontalWritingMode() && needToStretchChildLogicalHeight(child))\n        return constrainedChildIntrinsicContentLogicalHeight(child);\n    return child->height();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":124990
  },
  {
    "code":"void DiceTurnSyncOnHelper::AbortAndDelete() {\n   if (signin_aborted_mode_ == SigninAbortedMode::REMOVE_ACCOUNT) {\n    token_service_->RevokeCredentials(account_info_.account_id);\n   }\n   delete this;\n }\n",
    "vul":1,
    "flaw_line_no":[
      3
    ],
    "bigvul_id":186549
  },
  {
    "code":"static void nested_release_page_clean(struct page *page)\n{\n   kvm_release_page_clean(page);\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":37649
  },
  {
    "code":"static inline int ioc_batching(struct request_queue *q, struct io_context *ioc)\n{\n  if (!ioc)\n    return 0;\n  return ioc->nr_batch_requests == q->nr_batching ||\n    (ioc->nr_batch_requests > 0\n    && time_before(jiffies, ioc->last_waited + BLK_BATCH_TIME));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":92056
  },
  {
    "code":"void TabStrip::SetDropArrow(\n    const base::Optional<BrowserRootView::DropIndex>& index) {\n  if (!index) {\n    controller_->OnDropIndexUpdate(-1, false);\n    drop_arrow_.reset();\n    return;\n  }\n  controller_->OnDropIndexUpdate(index->value, index->drop_before);\n  if (drop_arrow_ && (index == drop_arrow_->index))\n    return;\n  bool is_beneath;\n  gfx::Rect drop_bounds =\n      GetDropBounds(index->value, index->drop_before, &is_beneath);\n  if (!drop_arrow_) {\n    drop_arrow_ = std::make_unique<DropArrow>(*index, !is_beneath, GetWidget());\n  } else {\n    drop_arrow_->index = *index;\n    if (is_beneath == drop_arrow_->point_down) {\n      drop_arrow_->point_down = !is_beneath;\n      drop_arrow_->arrow_view->SetImage(\n          GetDropArrowImage(drop_arrow_->point_down));\n    }\n  }\n  drop_arrow_->arrow_window->SetBounds(drop_bounds);\n  drop_arrow_->arrow_window->Show();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":153466
  },
  {
    "code":"void LoginDisplayHostWebUI::LoadURL(const GURL& url) {\n  InitLoginWindowAndView();\n  content::WebContentsObserver::Observe(login_view_->GetWebContents());\n  login_view_->LoadURL(url);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":144307
  },
  {
    "code":"int xdr_buf_read_netobj(struct xdr_buf *buf, struct xdr_netobj *obj, unsigned int offset)\n{\n  struct xdr_buf subbuf;\n  if (xdr_decode_word(buf, offset, &obj->len))\n    return -EFAULT;\n  if (xdr_buf_subsegment(buf, &subbuf, offset + 4, obj->len))\n    return -EFAULT;\n  obj->data = subbuf.head[0].iov_base;\n  if (subbuf.head[0].iov_len == obj->len)\n    return 0;\n  obj->data = subbuf.tail[0].iov_base;\n  if (subbuf.tail[0].iov_len == obj->len)\n    return 0;\n  if (obj->len > buf->buflen - buf->len)\n    return -ENOMEM;\n  if (buf->tail[0].iov_len != 0)\n    obj->data = buf->tail[0].iov_base + buf->tail[0].iov_len;\n  else\n    obj->data = buf->head[0].iov_base + buf->head[0].iov_len;\n  __read_bytes_from_xdr_buf(&subbuf, obj->data, obj->len);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":23513
  },
  {
    "code":"ip6_tnl_lookup(struct net *net, struct in6_addr *remote, struct in6_addr *local)\n{\n  unsigned h0 = HASH(remote);\n  unsigned h1 = HASH(local);\n  struct ip6_tnl *t;\n  struct ip6_tnl_net *ip6n = net_generic(net, ip6_tnl_net_id);\n  for_each_ip6_tunnel_rcu(ip6n->tnls_r_l[h0 ^ h1]) {\n    if (ipv6_addr_equal(local, &t->parms.laddr) &&\n        ipv6_addr_equal(remote, &t->parms.raddr) &&\n        (t->dev->flags & IFF_UP))\n      return t;\n  }\n  t = rcu_dereference(ip6n->tnls_wc[0]);\n  if (t && (t->dev->flags & IFF_UP))\n    return t;\n  return NULL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":27419
  },
  {
    "code":"int dns_packet_read_blob(DnsPacket *p, void *d, size_t sz, size_t *start) {\n        const void *q;\n        int r;\n        assert(p);\n        assert(d);\n        r = dns_packet_read(p, sz, &q, start);\n        if (r < 0)\n                return r;\n        memcpy(d, q, sz);\n        return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":64744
  },
  {
    "code":"  void SetExpectedCopyFromCompositingSurfaceResult(bool result,\n                                                   const SkBitmap& bitmap) {\n    expected_copy_from_compositing_surface_result_ = result;\n    expected_copy_from_compositing_surface_bitmap_ = bitmap;\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":134846
  },
  {
    "code":"void BrowserView::TabDeactivated(WebContents* contents) {\n  if (!contents->IsBeingDestroyed())\n    contents->StoreFocus();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":168371
  },
  {
    "code":"static int xts_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\n           struct scatterlist *src, unsigned int nbytes)\n{\n  struct camellia_xts_ctx *ctx = crypto_blkcipher_ctx(desc->tfm);\n  be128 buf[2 * 4];\n  struct xts_crypt_req req = {\n    .tbuf = buf,\n    .tbuflen = sizeof(buf),\n    .tweak_ctx = &ctx->tweak_ctx,\n    .tweak_fn = XTS_TWEAK_CAST(camellia_enc_blk),\n    .crypt_ctx = &ctx->crypt_ctx,\n    .crypt_fn = encrypt_callback,\n  };\n  return xts_crypt(desc, dst, src, nbytes, &req);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":46887
  },
  {
    "code":"WebPagePrivate::~WebPagePrivate()\n{\n    m_webPage->setVisible(false);\n    if (BackingStorePrivate::currentBackingStoreOwner() == m_webPage)\n        BackingStorePrivate::setCurrentBackingStoreOwner(0);\n    delete m_webSettings;\n    m_webSettings = 0;\n    delete m_cookieJar;\n    m_cookieJar = 0;\n    delete m_webkitThreadViewportAccessor;\n    m_webkitThreadViewportAccessor = 0;\n    delete m_backingStoreClient;\n    m_backingStoreClient = 0;\n    m_backingStore = 0;\n    delete m_page;\n    m_page = 0;\n    delete m_transformationMatrix;\n    m_transformationMatrix = 0;\n    delete m_inPageSearchManager;\n    m_inPageSearchManager = 0;\n    delete m_selectionHandler;\n    m_selectionHandler = 0;\n    delete m_inputHandler;\n    m_inputHandler = 0;\n    delete m_touchEventHandler;\n    m_touchEventHandler = 0;\n#if !defined(PUBLIC_BUILD) || !PUBLIC_BUILD\n    delete m_dumpRenderTree;\n    m_dumpRenderTree = 0;\n#endif\n    AuthenticationChallengeManager::instance()->pageDeleted(this);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":111436
  },
  {
    "code":"static int gf2m_Mxy(const EC_GROUP *group, const BIGNUM *x, const BIGNUM *y, BIGNUM *x1, \n  BIGNUM *z1, BIGNUM *x2, BIGNUM *z2, BN_CTX *ctx)\n  {\n  BIGNUM *t3, *t4, *t5;\n  int ret = 0;\n  if (BN_is_zero(z1))\n    {\n    BN_zero(x2);\n    BN_zero(z2);\n    return 1;\n    }\n  if (BN_is_zero(z2))\n    {\n    if (!BN_copy(x2, x)) return 0;\n    if (!BN_GF2m_add(z2, x, y)) return 0;\n    return 2;\n    }\n  BN_CTX_start(ctx);\n  t3 = BN_CTX_get(ctx);\n  t4 = BN_CTX_get(ctx);\n  t5 = BN_CTX_get(ctx);\n  if (t5 == NULL) goto err;\n  if (!BN_one(t5)) goto err;\n  if (!group->meth->field_mul(group, t3, z1, z2, ctx)) goto err;\n  if (!group->meth->field_mul(group, z1, z1, x, ctx)) goto err;\n  if (!BN_GF2m_add(z1, z1, x1)) goto err;\n  if (!group->meth->field_mul(group, z2, z2, x, ctx)) goto err;\n  if (!group->meth->field_mul(group, x1, z2, x1, ctx)) goto err;\n  if (!BN_GF2m_add(z2, z2, x2)) goto err;\n  if (!group->meth->field_mul(group, z2, z2, z1, ctx)) goto err;\n  if (!group->meth->field_sqr(group, t4, x, ctx)) goto err;\n  if (!BN_GF2m_add(t4, t4, y)) goto err;\n  if (!group->meth->field_mul(group, t4, t4, t3, ctx)) goto err;\n  if (!BN_GF2m_add(t4, t4, z2)) goto err;\n  if (!group->meth->field_mul(group, t3, t3, x, ctx)) goto err;\n  if (!group->meth->field_div(group, t3, t5, t3, ctx)) goto err;\n  if (!group->meth->field_mul(group, t4, t3, t4, ctx)) goto err;\n  if (!group->meth->field_mul(group, x2, x1, t3, ctx)) goto err;\n  if (!BN_GF2m_add(z2, x2, x)) goto err;\n  if (!group->meth->field_mul(group, z2, z2, t4, ctx)) goto err;\n  if (!BN_GF2m_add(z2, z2, y)) goto err;\n  ret = 2;\n err:\n  BN_CTX_end(ctx);\n        return ret;\n        }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":14568
  },
  {
    "code":"static time_t gf_mktime_utc(struct tm *tm)\n{\n  return timegm(tm);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":90816
  },
  {
    "code":"void ModuleSystem::NativeLazyFieldGetter(\n    v8::Local<v8::Name> property,\n    const v8::PropertyCallbackInfo<v8::Value>& info) {\n  LazyFieldGetterInner(property.As<v8::String>(), info,\n                       &ModuleSystem::RequireNativeFromString);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":145738
  },
  {
    "code":"static void slab_mem_offline_callback(void *arg)\n{\n  struct kmem_cache_node *n;\n  struct kmem_cache *s;\n  struct memory_notify *marg = arg;\n  int offline_node;\n  offline_node = marg->status_change_nid;\n  if (offline_node < 0)\n    return;\n  down_read(&slub_lock);\n  list_for_each_entry(s, &slab_caches, list) {\n    n = get_node(s, offline_node);\n    if (n) {\n      BUG_ON(slabs_node(s, offline_node));\n      s->node[offline_node] = NULL;\n      kmem_cache_free(kmalloc_caches, n);\n    }\n  }\n  up_read(&slub_lock);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":24911
  },
  {
    "code":"float AXNodeObject::maxValueForRange() const {\n  if (hasAttribute(aria_valuemaxAttr))\n    return getAttribute(aria_valuemaxAttr).toFloat();\n  if (isNativeSlider())\n    return toHTMLInputElement(*getNode()).maximum();\n  if (isHTMLMeterElement(getNode()))\n    return toHTMLMeterElement(*getNode()).max();\n  return 0.0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":138091
  },
  {
    "code":"static int cbc_decrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\n           struct scatterlist *src, unsigned int nbytes)\n{\n  bool fpu_enabled = false;\n  struct blkcipher_walk walk;\n  int err;\n  blkcipher_walk_init(&walk, dst, src, nbytes);\n  err = blkcipher_walk_virt(desc, &walk);\n  desc->flags &= ~CRYPTO_TFM_REQ_MAY_SLEEP;\n  while ((nbytes = walk.nbytes)) {\n    fpu_enabled = cast5_fpu_begin(fpu_enabled, nbytes);\n    nbytes = __cbc_decrypt(desc, &walk);\n    err = blkcipher_walk_done(desc, &walk, nbytes);\n  }\n  cast5_fpu_end(fpu_enabled);\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":46895
  },
  {
    "code":"xfs_vn_get_link_inline(\n  struct dentry    *dentry,\n  struct inode    *inode,\n  struct delayed_call  *done)\n{\n  char      *link;\n  ASSERT(XFS_I(inode)->i_df.if_flags & XFS_IFINLINE);\n  link = XFS_I(inode)->i_df.if_u1.if_data;\n  if (!link)\n    return ERR_PTR(-EFSCORRUPTED);\n  return link;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":88342
  },
  {
    "code":"void HTMLFormControlElement::dispatchBlurEvent(Element* newFocusedElement, WebFocusType type, InputDeviceCapabilities* sourceCapabilities)\n{\n    if (type != WebFocusTypePage)\n        m_wasFocusedByMouse = false;\n    HTMLElement::dispatchBlurEvent(newFocusedElement, type, sourceCapabilities);\n    hideVisibleValidationMessage();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":130348
  },
  {
    "code":"epass2003_gen_key(struct sc_card *card, sc_epass2003_gen_key_data * data)\n{\n  int r;\n  size_t len = data->key_length;\n  struct sc_apdu apdu;\n  u8 rbuf[SC_MAX_EXT_APDU_BUFFER_SIZE] = { 0 };\n  u8 sbuf[SC_MAX_EXT_APDU_BUFFER_SIZE] = { 0 };\n  LOG_FUNC_CALLED(card->ctx);\n  if(len == 256)\n  {\n    sbuf[0] = 0x02;\n  }\n  else\n  {\n    sbuf[0] = 0x01;\n  }\n  sbuf[1] = (u8) ((len >> 8) & 0xff);\n  sbuf[2] = (u8) (len & 0xff);\n  sbuf[3] = (u8) ((data->prkey_id >> 8) & 0xFF);\n  sbuf[4] = (u8) ((data->prkey_id) & 0xFF);\n  sbuf[5] = (u8) ((data->pukey_id >> 8) & 0xFF);\n  sbuf[6] = (u8) ((data->pukey_id) & 0xFF);\n  sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0x46, 0x00, 0x00);\n  apdu.lc = apdu.datalen = 7;\n  apdu.data = sbuf;\n  r = sc_transmit_apdu_t(card, &apdu);\n  LOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n  r = sc_check_sw(card, apdu.sw1, apdu.sw2);\n  LOG_TEST_RET(card->ctx, r, \"generate keypair failed\");\n  sc_format_apdu(card, &apdu, SC_APDU_CASE_3_SHORT, 0xb4, 0x02, 0x00);\n  if(len == 256)\n  {\n    apdu.p1 = 0x00;\n  }\n  apdu.cla = 0x80;\n  apdu.lc = apdu.datalen = 2;\n  apdu.data = &sbuf[5];\n  apdu.resp = rbuf;\n  apdu.resplen = sizeof(rbuf);\n  apdu.le = 0x00;\n  r = sc_transmit_apdu_t(card, &apdu);\n  LOG_TEST_RET(card->ctx, r, \"APDU transmit failed\");\n  r = sc_check_sw(card, apdu.sw1, apdu.sw2);\n  LOG_TEST_RET(card->ctx, r, \"get pukey failed\");\n  if (len < apdu.resplen)\n    LOG_FUNC_RETURN(card->ctx, SC_ERROR_INVALID_ARGUMENTS);\n  data->modulus = (u8 *) malloc(len);\n  if (!data->modulus)\n    LOG_FUNC_RETURN(card->ctx, SC_ERROR_OUT_OF_MEMORY);\n  memcpy(data->modulus, rbuf, len);\n  LOG_FUNC_RETURN(card->ctx, SC_SUCCESS);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":78388
  },
  {
    "code":"void DesktopWindowTreeHostX11::OnWMStateUpdated() {\n  std::vector<XAtom> atom_list;\n  if (ui::GetAtomArrayProperty(xwindow_, \"_NET_WM_STATE\", &atom_list) ||\n      window_mapped_in_client_) {\n    UpdateWindowProperties(\n        base::flat_set<XAtom>(std::begin(atom_list), std::end(atom_list)));\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":153267
  },
  {
    "code":"SetVendorRelease(int release)\n{\n    VendorRelease = release;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":15030
  },
  {
    "code":"static void add_message_grep(struct rev_info *revs, const char *pattern)\n{\n  add_grep(revs, pattern, GREP_PATTERN_BODY);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":54964
  },
  {
    "code":" static void DeleteImpl(Handle<JSObject> obj, uint32_t entry) {\n ElementsKind kind = KindTraits::Kind;\n if (IsFastPackedElementsKind(kind)) {\n JSObject::TransitionElementsKind(obj, GetHoleyElementsKind(kind));\n }\n if (IsFastSmiOrObjectElementsKind(KindTraits::Kind)) {\n JSObject::EnsureWritableFastElements(obj);\n }\n DeleteCommon(obj, entry, handle(obj->elements()));\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":176240
  },
  {
    "code":"static struct sock *sco_get_sock_listen(bdaddr_t *src)\n{\n  struct sock *sk = NULL, *sk1 = NULL;\n  struct hlist_node *node;\n  read_lock(&sco_sk_list.lock);\n  sk_for_each(sk, node, &sco_sk_list.head) {\n    if (sk->sk_state != BT_LISTEN)\n      continue;\n    if (!bacmp(&bt_sk(sk)->src, src))\n      break;\n    if (!bacmp(&bt_sk(sk)->src, BDADDR_ANY))\n      sk1 = sk;\n  }\n  read_unlock(&sco_sk_list.lock);\n  return node ? sk : sk1;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":27736
  },
  {
    "code":"void WebContentsImpl::ResizeDueToAutoResize(\n    RenderWidgetHostImpl* render_widget_host,\n    const gfx::Size& new_size) {\n  if (render_widget_host != GetRenderViewHost()->GetWidget())\n    return;\n  auto_resize_size_ = new_size;\n  for (FrameTreeNode* node : frame_tree_.Nodes()) {\n    if (node->current_frame_host()->is_local_root()) {\n      RenderWidgetHostImpl* host =\n          node->current_frame_host()->GetRenderWidgetHost();\n      if (host != render_widget_host)\n        host->WasResized();\n    }\n  }\n  if (delegate_)\n    delegate_->ResizeDueToAutoResize(this, new_size);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":148545
  },
  {
    "code":"static struct inode *hugetlbfs_alloc_inode(struct super_block *sb)\n{\n  struct hugetlbfs_sb_info *sbinfo = HUGETLBFS_SB(sb);\n  struct hugetlbfs_inode_info *p;\n  if (unlikely(!hugetlbfs_dec_free_inodes(sbinfo)))\n    return NULL;\n  p = kmem_cache_alloc(hugetlbfs_inode_cachep, GFP_KERNEL);\n  if (unlikely(!p)) {\n    hugetlbfs_inc_free_inodes(sbinfo);\n    return NULL;\n  }\n  return &p->vfs_inode;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":20217
  },
  {
    "code":"static int __allocate_data_block(struct dnode_of_data *dn)\n{\n  struct f2fs_sb_info *sbi = F2FS_I_SB(dn->inode);\n  struct f2fs_summary sum;\n  struct node_info ni;\n  pgoff_t fofs;\n  blkcnt_t count = 1;\n  if (unlikely(is_inode_flag_set(dn->inode, FI_NO_ALLOC)))\n    return -EPERM;\n  dn->data_blkaddr = datablock_addr(dn->node_page, dn->ofs_in_node);\n  if (dn->data_blkaddr == NEW_ADDR)\n    goto alloc;\n  if (unlikely(!inc_valid_block_count(sbi, dn->inode, &count)))\n    return -ENOSPC;\nalloc:\n  get_node_info(sbi, dn->nid, &ni);\n  set_summary(&sum, dn->nid, dn->ofs_in_node, ni.version);\n  allocate_data_block(sbi, NULL, dn->data_blkaddr, &dn->data_blkaddr,\n            &sum, CURSEG_WARM_DATA);\n  set_data_blkaddr(dn);\n  fofs = start_bidx_of_node(ofs_of_node(dn->node_page), dn->inode) +\n              dn->ofs_in_node;\n  if (i_size_read(dn->inode) < ((loff_t)(fofs + 1) << PAGE_SHIFT))\n    f2fs_i_size_write(dn->inode,\n        ((loff_t)(fofs + 1) << PAGE_SHIFT));\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":85150
  },
  {
    "code":"void ShelfLayoutManager::OnChildWindowVisibilityChanged(aura::Window* child,\n                                                        bool visible) {\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":113230
  },
  {
    "code":"void Browser::SetSuggestedText(const string16& text,\n                               InstantCompleteBehavior behavior) {\n  window()->GetLocationBar()->SetSuggestedText(text, behavior);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":103188
  },
  {
    "code":"bool BaseRenderingContext2D::IsPointInPathInternal(\n    const Path& path,\n    const double x,\n    const double y,\n    const String& winding_rule_string) {\n  PaintCanvas* c = DrawingCanvas();\n  if (!c)\n    return false;\n  if (!GetState().IsTransformInvertible())\n    return false;\n  FloatPoint point(x, y);\n  if (!std::isfinite(point.X()) || !std::isfinite(point.Y()))\n    return false;\n  AffineTransform ctm = GetState().Transform();\n  FloatPoint transformed_point = ctm.Inverse().MapPoint(point);\n  return path.Contains(transformed_point,\n                       SkFillTypeToWindRule(ParseWinding(winding_rule_string)));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":162695
  },
  {
    "code":"long dtls1_ctrl(SSL *s, int cmd, long larg, void *parg)\n  {\n  int ret=0;\n  switch (cmd)\n    {\n  case DTLS_CTRL_GET_TIMEOUT:\n    if (dtls1_get_timeout(s, (struct timeval*) parg) != NULL)\n      {\n      ret = 1;\n      }\n    break;\n  case DTLS_CTRL_HANDLE_TIMEOUT:\n    ret = dtls1_handle_timeout(s);\n    break;\n  case DTLS_CTRL_LISTEN:\n    ret = dtls1_listen(s, parg);\n    break;\n  default:\n    ret = ssl3_ctrl(s, cmd, larg, parg);\n    break;\n    }\n  return(ret);\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":46104
  },
  {
    "code":"static inline unsigned long buffer_offset(void *buf)\n{\n  return (unsigned long)buf & (ARCH_KMALLOC_MINALIGN - 1);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":59842
  },
  {
    "code":"static void FixLogical(unsigned char *Buff,int ldblk)\n{\nunsigned char mask=128;\nunsigned char *BuffL = Buff;\nunsigned char val = 0;\n  while(ldblk-->0)\n  {\n    if(*Buff++ != 0)\n      val |= mask;\n    mask >>= 1;\n    if(mask==0)\n    {\n      *BuffL++ = val;\n      val = 0;\n      mask = 128;\n    }\n  }\n  *BuffL = val;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":62084
  },
  {
    "code":"void ContentSecurityPolicy::UpgradeInsecureRequests() {\n  insecure_request_policy_ |= kUpgradeInsecureRequests;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":165565
  },
  {
    "code":"void RenderViewImpl::Close() {\n  WebView* doomed = webview();\n  RenderWidget::Close();\n  g_view_map.Get().erase(doomed);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":108837
  },
  {
    "code":"static int __sctp_setsockopt_connectx(struct sock *sk,\n              struct sockaddr __user *addrs,\n              int addrs_size,\n              sctp_assoc_t *assoc_id)\n{\n  struct sockaddr *kaddrs;\n  gfp_t gfp = GFP_KERNEL;\n  int err = 0;\n  pr_debug(\"%s: sk:%p addrs:%p addrs_size:%d\\n\",\n     __func__, sk, addrs, addrs_size);\n  if (unlikely(addrs_size <= 0))\n    return -EINVAL;\n  if (unlikely(!access_ok(VERIFY_READ, addrs, addrs_size)))\n    return -EFAULT;\n  if (sk->sk_socket->file)\n    gfp = GFP_USER | __GFP_NOWARN;\n  kaddrs = kmalloc(addrs_size, gfp);\n  if (unlikely(!kaddrs))\n    return -ENOMEM;\n  if (__copy_from_user(kaddrs, addrs, addrs_size)) {\n    err = -EFAULT;\n  } else {\n    err = __sctp_connect(sk, kaddrs, addrs_size, assoc_id);\n  }\n  kfree(kaddrs);\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":60645
  },
  {
    "code":"    OVS_REQUIRES(ofproto_mutex)\n    OVS_EXCLUDED(rule->mutex)\n{\n    if (!idle_timeout && !hard_timeout) {\n        return;\n    }\n    if (ovs_list_is_empty(&rule->expirable)) {\n        ovs_list_insert(&rule->ofproto->expirable, &rule->expirable);\n    }\n    ovs_mutex_lock(&rule->mutex);\n    reduce_timeout(idle_timeout, &rule->idle_timeout);\n    reduce_timeout(hard_timeout, &rule->hard_timeout);\n    ovs_mutex_unlock(&rule->mutex);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":77180
  },
  {
    "code":"bool MediaPlayer::isPlaying()\n{\n Mutex::Autolock _l(mLock);\n if (mPlayer != 0) {\n bool temp = false;\n        mPlayer->isPlaying(&temp);\n        ALOGV(\"isPlaying: %d\", temp);\n if ((mCurrentState & MEDIA_PLAYER_STARTED) && ! temp) {\n            ALOGE(\"internal\/external state mismatch corrected\");\n            mCurrentState = MEDIA_PLAYER_PAUSED;\n } else if ((mCurrentState & MEDIA_PLAYER_PAUSED) && temp) {\n            ALOGE(\"internal\/external state mismatch corrected\");\n            mCurrentState = MEDIA_PLAYER_STARTED;\n }\n return temp;\n }\n    ALOGV(\"isPlaying: no active player\");\n return false;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":172669
  },
  {
    "code":"void NavigationControllerImpl::RendererDidNavigateNewSubframe(\n    RenderFrameHostImpl* rfh,\n    const FrameHostMsg_DidCommitProvisionalLoad_Params& params,\n    bool is_same_document,\n    bool replace_entry) {\n  DCHECK(ui::PageTransitionCoreTypeIs(params.transition,\n                                      ui::PAGE_TRANSITION_MANUAL_SUBFRAME));\n  DCHECK(GetLastCommittedEntry()) << \"ClassifyNavigation should guarantee \"\n                                  << \"that a last committed entry exists.\";\n  scoped_refptr<FrameNavigationEntry> frame_entry(new FrameNavigationEntry(\n      params.frame_unique_name, params.item_sequence_number,\n      params.document_sequence_number, rfh->GetSiteInstance(), nullptr,\n      params.url, params.referrer, params.method, params.post_id));\n  std::unique_ptr<NavigationEntryImpl> new_entry =\n      GetLastCommittedEntry()->CloneAndReplace(\n          frame_entry.get(), is_same_document, rfh->frame_tree_node(),\n          delegate_->GetFrameTree()->root());\n  InsertOrReplaceEntry(std::move(new_entry), replace_entry);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":169416
  },
  {
    "code":"OMX_ERRORTYPE  omx_video::empty_this_buffer(OMX_IN OMX_HANDLETYPE         hComp,\n        OMX_IN OMX_BUFFERHEADERTYPE* buffer)\n{\n    OMX_ERRORTYPE ret1 = OMX_ErrorNone;\n unsigned int nBufferIndex ;\n    DEBUG_PRINT_LOW(\"ETB: buffer = %p, buffer->pBuffer[%p]\", buffer, buffer->pBuffer);\n if (m_state != OMX_StateExecuting &&\n            m_state != OMX_StatePause &&\n            m_state != OMX_StateIdle) {\n        DEBUG_PRINT_ERROR(\"ERROR: Empty this buffer in Invalid State\");\n return OMX_ErrorInvalidState;\n }\n if (buffer == NULL || (buffer->nSize != sizeof(OMX_BUFFERHEADERTYPE))) {\n        DEBUG_PRINT_ERROR(\"ERROR: omx_video::etb--> buffer is null or buffer size is invalid\");\n return OMX_ErrorBadParameter;\n }\n if (buffer->nVersion.nVersion != OMX_SPEC_VERSION) {\n        DEBUG_PRINT_ERROR(\"ERROR: omx_video::etb--> OMX Version Invalid\");\n return OMX_ErrorVersionMismatch;\n }\n if (buffer->nInputPortIndex != (OMX_U32)PORT_INDEX_IN) {\n        DEBUG_PRINT_ERROR(\"ERROR: Bad port index to call empty_this_buffer\");\n return OMX_ErrorBadPortIndex;\n }\n if (!m_sInPortDef.bEnabled) {\n        DEBUG_PRINT_ERROR(\"ERROR: Cannot call empty_this_buffer while I\/P port is disabled\");\n return OMX_ErrorIncorrectStateOperation;\n }\n    nBufferIndex = buffer - ((!meta_mode_enable)?m_inp_mem_ptr:meta_buffer_hdr);\n if (nBufferIndex > m_sInPortDef.nBufferCountActual ) {\n        DEBUG_PRINT_ERROR(\"ERROR: ETB: Invalid buffer index[%d]\", nBufferIndex);\n return OMX_ErrorBadParameter;\n }\n    m_etb_count++;\n    DEBUG_PRINT_LOW(\"DBG: i\/p nTimestamp = %u\", (unsigned)buffer->nTimeStamp);\n    post_event ((unsigned long)hComp,(unsigned long)buffer,m_input_msg_id);\n return OMX_ErrorNone;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":172334
  },
  {
    "code":"bool ChromeMockRenderThread::OnMessageReceived(const IPC::Message& msg) {\n  if (content::MockRenderThread::OnMessageReceived(msg))\n    return true;\n  bool handled = true;\n  bool msg_is_ok = true;\n  IPC_BEGIN_MESSAGE_MAP_EX(ChromeMockRenderThread, msg, msg_is_ok)\n    IPC_MESSAGE_HANDLER(ExtensionHostMsg_OpenChannelToExtension,\n                        OnMsgOpenChannelToExtension)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_GetDefaultPrintSettings,\n                        OnGetDefaultPrintSettings)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_ScriptedPrint, OnScriptedPrint)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_UpdatePrintSettings, OnUpdatePrintSettings)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPrintedPagesCount,\n                        OnDidGetPrintedPagesCount)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPrintPage, OnDidPrintPage)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_DidGetPreviewPageCount,\n                        OnDidGetPreviewPageCount)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_DidPreviewPage, OnDidPreviewPage)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_CheckForCancel, OnCheckForCancel)\n#if defined(OS_WIN)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_DuplicateSection, OnDuplicateSection)\n#endif\n#if defined(OS_CHROMEOS)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_AllocateTempFileForPrinting,\n                        OnAllocateTempFileForPrinting)\n    IPC_MESSAGE_HANDLER(PrintHostMsg_TempFileForPrintingWritten,\n                        OnTempFileForPrintingWritten)\n#endif\n    IPC_MESSAGE_UNHANDLED(handled = false)\n  IPC_END_MESSAGE_MAP_EX()\n  return handled;\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":112812
  },
  {
    "code":"void PrepContentsForBeforeUnloadTest(WebContents* web_contents) {\n  for (auto* frame : web_contents->GetAllFrames()) {\n    frame->ExecuteJavaScriptWithUserGestureForTests(base::string16());\n    frame->DisableBeforeUnloadHangMonitorForTesting();\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":169295
  },
  {
    "code":"static ext4_lblk_t ext4_ext_next_leaf_block(struct ext4_ext_path *path)\n{\n  int depth;\n  BUG_ON(path == NULL);\n  depth = path->p_depth;\n  if (depth == 0)\n    return EXT_MAX_BLOCKS;\n  depth--;\n  while (depth >= 0) {\n    if (path[depth].p_idx !=\n        EXT_LAST_INDEX(path[depth].p_hdr))\n      return (ext4_lblk_t)\n        le32_to_cpu(path[depth].p_idx[1].ei_block);\n    depth--;\n  }\n  return EXT_MAX_BLOCKS;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":18567
  },
  {
    "code":"void UserCloudPolicyManagerChromeOS::OnAccessTokenAvailable(\n    const std::string& access_token) {\n  access_token_ = access_token;\n  if (!wildcard_username_.empty()) {\n    wildcard_login_checker_.reset(new WildcardLoginChecker());\n    wildcard_login_checker_->StartWithAccessToken(\n        access_token,\n        base::Bind(&OnWildcardCheckCompleted, wildcard_username_));\n  }\n  if (service() && service()->IsInitializationComplete() &&\n      client() && !client()->is_registered()) {\n    OnOAuth2PolicyTokenFetched(\n        access_token, GoogleServiceAuthError(GoogleServiceAuthError::NONE));\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":118646
  },
  {
    "code":"SYSCALL_DEFINE6(mmap_pgoff, unsigned long, addr, unsigned long, len,\n    unsigned long, prot, unsigned long, flags,\n    unsigned long, fd, unsigned long, pgoff)\n{\n  return ksys_mmap_pgoff(addr, len, prot, flags, fd, pgoff);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":90526
  },
  {
    "code":"bool ParseDolbyVisionCodecId(const std::string& codec_id,\n                             VideoCodecProfile* profile,\n                             uint8_t* level_idc) {\n  if (!IsDolbyVisionAVCCodecId(codec_id) &&\n      !IsDolbyVisionHEVCCodecId(codec_id)) {\n    return false;\n  }\n  const int kMaxDvCodecIdLength = 5     \n                                  + 1   \n                                  + 2   \n                                  + 1   \n                                  + 2;  \n  if (codec_id.size() > kMaxDvCodecIdLength) {\n    DVLOG(4) << __func__ << \": Codec id is too long (\" << codec_id << \")\";\n    return false;\n  }\n  std::vector<std::string> elem = base::SplitString(\n      codec_id, \".\", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);\n  DCHECK(elem[0] == \"dvh1\" || elem[0] == \"dvhe\" || elem[0] == \"dva1\" ||\n         elem[0] == \"dvav\");\n  if (elem.size() != 3) {\n    DVLOG(4) << __func__ << \": invalid dolby vision codec id \" << codec_id;\n    return false;\n  }\n  unsigned profile_id = 0;\n  if (elem[1].size() != 2 || !base::StringToUint(elem[1], &profile_id) ||\n      profile_id > 7) {\n    DVLOG(4) << __func__ << \": invalid format or profile_id=\" << elem[1];\n    return false;\n  }\n  switch (profile_id) {\n    case 0:\n      if (!IsDolbyVisionAVCCodecId(codec_id)) {\n        DVLOG(4) << __func__\n                 << \": codec id is mismatched with profile_id=\" << profile_id;\n        return false;\n      }\n      *profile = DOLBYVISION_PROFILE0;\n      break;\n#if BUILDFLAG(ENABLE_HEVC_DEMUXING)\n    case 4:\n    case 5:\n    case 7:\n      if (!IsDolbyVisionHEVCCodecId(codec_id)) {\n        DVLOG(4) << __func__\n                 << \": codec id is mismatched with profile_id=\" << profile_id;\n        return false;\n      }\n      if (profile_id == 4)\n        *profile = DOLBYVISION_PROFILE4;\n      else if (profile_id == 5)\n        *profile = DOLBYVISION_PROFILE5;\n      else if (profile_id == 7)\n        *profile = DOLBYVISION_PROFILE7;\n      break;\n#endif\n    default:\n      DVLOG(4) << __func__\n               << \": depecrated and not supported profile_id=\" << profile_id;\n      return false;\n  }\n  unsigned level_id = 0;\n  if (elem[2].size() != 2 || !base::StringToUint(elem[2], &level_id) ||\n      level_id > 9 || level_id < 1) {\n    DVLOG(4) << __func__ << \": invalid format level_id=\" << elem[2];\n    return false;\n  }\n  *level_idc = level_id;\n  return true;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":139614
  },
  {
    "code":"static void arr_replace(uint16_t *arr, uint8_t max, x86_reg r1, x86_reg r2)\n{\n  uint8_t i;\n  for(i = 0; i < max; i++) {\n    if (arr[i] == r1) {\n      arr[i] = r2;\n      break;\n    }\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":94029
  },
  {
    "code":"void ChromeContentBrowserClient::RegisterUserPrefs(\n    PrefRegistrySyncable* registry) {\n  registry->RegisterBooleanPref(prefs::kDisable3DAPIs,\n                                false,\n                                PrefRegistrySyncable::UNSYNCABLE_PREF);\n  registry->RegisterBooleanPref(prefs::kEnableHyperlinkAuditing,\n                                true,\n                                PrefRegistrySyncable::UNSYNCABLE_PREF);\n  registry->RegisterBooleanPref(prefs::kEnableMemoryInfo,\n                                false,\n                                PrefRegistrySyncable::UNSYNCABLE_PREF);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":124121
  },
  {
    "code":"void Element::setBooleanAttribute(const QualifiedName& name, bool value)\n{\n    if (value)\n        setAttribute(name, emptyAtom);\n    else\n        removeAttribute(name);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":120631
  },
  {
    "code":"Function::Function() {\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":4159
  },
  {
    "code":"DevToolsToolboxDelegate::DevToolsToolboxDelegate(\n    WebContents* toolbox_contents,\n    DevToolsWindow::ObserverWithAccessor* web_contents_observer)\n    : WebContentsObserver(toolbox_contents),\n      inspected_contents_observer_(web_contents_observer) {\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":151062
  },
  {
    "code":"uint16_t AVRC_PassRsp(uint8_t handle, uint8_t label, tAVRC_MSG_PASS* p_msg) {\n  BT_HDR* p_buf;\n if (!p_msg) return AVRC_BAD_PARAM;\n  p_buf = avrc_pass_msg(p_msg);\n if (p_buf) return AVCT_MsgReq(handle, label, AVCT_RSP, p_buf);\n return AVRC_NO_RESOURCES;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":176048
  },
  {
    "code":"void task_times(struct task_struct *p, cputime_t *ut, cputime_t *st)\n{\n  *ut = p->utime;\n  *st = p->stime;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":22624
  },
  {
    "code":"void RenderFrameImpl::AbortClientNavigation() {\n  browser_side_navigation_pending_ = false;\n  Send(new FrameHostMsg_AbortNavigation(routing_id_));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":160539
  },
  {
    "code":"static debug_info_t *qeth_get_dbf_entry(char *name)\n{\n  struct qeth_dbf_entry *entry;\n  debug_info_t *rc = NULL;\n  mutex_lock(&qeth_dbf_list_mutex);\n  list_for_each_entry(entry, &qeth_dbf_list, dbf_list) {\n    if (strcmp(entry->dbf_name, name) == 0) {\n      rc = entry->dbf_info;\n      break;\n    }\n  }\n  mutex_unlock(&qeth_dbf_list_mutex);\n  return rc;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":28558
  },
  {
    "code":"void ACodec::LoadedState::onShutdown(bool keepComponentAllocated) {\n if (!keepComponentAllocated) {\n (void)mCodec->mOMX->freeNode(mCodec->mNode);\n        mCodec->changeState(mCodec->mUninitializedState);\n }\n if (mCodec->mExplicitShutdown) {\n        sp<AMessage> notify = mCodec->mNotify->dup();\n        notify->setInt32(\"what\", CodecBase::kWhatShutdownCompleted);\n        notify->post();\n        mCodec->mExplicitShutdown = false;\n }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":177286
  },
  {
    "code":"process_pa_data_to_key(krb5_context context,\n           krb5_get_init_creds_ctx *ctx,\n           krb5_creds *creds,\n           AS_REQ *a,\n           AS_REP *rep,\n           const krb5_krbhst_info *hi,\n           krb5_keyblock **key)\n{\n    struct pa_info_data paid, *ppaid = NULL;\n    krb5_error_code ret;\n    krb5_enctype etype;\n    PA_DATA *pa;\n    memset(&paid, 0, sizeof(paid));\n    etype = rep->enc_part.etype;\n    if (rep->padata) {\n  paid.etype = etype;\n  ppaid = process_pa_info(context, creds->client, a, &paid,\n        rep->padata);\n    }\n    if (ppaid == NULL)\n  ppaid = ctx->ppaid;\n    if (ppaid == NULL) {\n  ret = krb5_get_pw_salt (context, creds->client, &paid.salt);\n  if (ret)\n      return ret;\n  paid.etype = etype;\n  paid.s2kparams = NULL;\n  ppaid = &paid;\n    }\n    pa = NULL;\n    if (rep->padata) {\n  int idx = 0;\n  pa = krb5_find_padata(rep->padata->val,\n            rep->padata->len,\n            KRB5_PADATA_PK_AS_REP,\n            &idx);\n  if (pa == NULL) {\n      idx = 0;\n      pa = krb5_find_padata(rep->padata->val,\n          rep->padata->len,\n          KRB5_PADATA_PK_AS_REP_19,\n          &idx);\n  }\n    }\n    if (pa && ctx->pk_init_ctx) {\n#ifdef PKINIT\n  _krb5_debug(context, 5, \"krb5_get_init_creds: using PKINIT\");\n  ret = _krb5_pk_rd_pa_reply(context,\n           a->req_body.realm,\n           ctx->pk_init_ctx,\n           etype,\n           hi,\n           ctx->pk_nonce,\n           &ctx->req_buffer,\n           pa,\n           key);\n#else\n  ret = EINVAL;\n  krb5_set_error_message(context, ret, N_(\"no support for PKINIT compiled in\", \"\"));\n#endif\n    } else if (ctx->keyseed) {\n   _krb5_debug(context, 5, \"krb5_get_init_creds: using keyproc\");\n  ret = pa_data_to_key_plain(context, creds->client, ctx,\n           ppaid->salt, ppaid->s2kparams, etype, key);\n    } else {\n  ret = EINVAL;\n  krb5_set_error_message(context, ret, N_(\"No usable pa data type\", \"\"));\n    }\n    free_paid(context, &paid);\n    return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":89941
  },
  {
    "code":"bool PopupContainer::handleKeyEvent(const PlatformKeyboardEvent& event)\n{\n    UserGestureIndicator gestureIndicator(DefinitelyProcessingUserGesture);\n    return m_listBox->handleKeyEvent(event);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":116824
  },
  {
    "code":"static void v9fs_setattr(void *opaque)\n{\n    int err = 0;\n    int32_t fid;\n    V9fsFidState *fidp;\n    size_t offset = 7;\n    V9fsIattr v9iattr;\n    V9fsPDU *pdu = opaque;\n    err = pdu_unmarshal(pdu, offset, \"dI\", &fid, &v9iattr);\n    if (err < 0) {\n        goto out_nofid;\n    }\n    fidp = get_fid(pdu, fid);\n    if (fidp == NULL) {\n        err = -EINVAL;\n        goto out_nofid;\n    }\n    if (v9iattr.valid & P9_ATTR_MODE) {\n        err = v9fs_co_chmod(pdu, &fidp->path, v9iattr.mode);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9iattr.valid & (P9_ATTR_ATIME | P9_ATTR_MTIME)) {\n        struct timespec times[2];\n        if (v9iattr.valid & P9_ATTR_ATIME) {\n            if (v9iattr.valid & P9_ATTR_ATIME_SET) {\n                times[0].tv_sec = v9iattr.atime_sec;\n                times[0].tv_nsec = v9iattr.atime_nsec;\n            } else {\n                times[0].tv_nsec = UTIME_NOW;\n            }\n        } else {\n            times[0].tv_nsec = UTIME_OMIT;\n        }\n        if (v9iattr.valid & P9_ATTR_MTIME) {\n            if (v9iattr.valid & P9_ATTR_MTIME_SET) {\n                times[1].tv_sec = v9iattr.mtime_sec;\n                times[1].tv_nsec = v9iattr.mtime_nsec;\n            } else {\n                times[1].tv_nsec = UTIME_NOW;\n            }\n        } else {\n            times[1].tv_nsec = UTIME_OMIT;\n        }\n        err = v9fs_co_utimensat(pdu, &fidp->path, times);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if ((v9iattr.valid & (P9_ATTR_UID | P9_ATTR_GID)) ||\n        ((v9iattr.valid & P9_ATTR_CTIME)\n         && !((v9iattr.valid & P9_ATTR_MASK) & ~P9_ATTR_CTIME))) {\n        if (!(v9iattr.valid & P9_ATTR_UID)) {\n            v9iattr.uid = -1;\n        }\n        if (!(v9iattr.valid & P9_ATTR_GID)) {\n            v9iattr.gid = -1;\n        }\n        err = v9fs_co_chown(pdu, &fidp->path, v9iattr.uid,\n                            v9iattr.gid);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    if (v9iattr.valid & (P9_ATTR_SIZE)) {\n        err = v9fs_co_truncate(pdu, &fidp->path, v9iattr.size);\n        if (err < 0) {\n            goto out;\n        }\n    }\n    err = offset;\nout:\n    put_fid(pdu, fidp);\nout_nofid:\n    pdu_complete(pdu, err);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":8234
  },
  {
    "code":"MagickExport Image *StatisticImage(const Image *image,const StatisticType type,\n  const size_t width,const size_t height,ExceptionInfo *exception)\n{\n#define StatisticImageTag  \"Statistic\/Image\"\n  CacheView\n    *image_view,\n    *statistic_view;\n  Image\n    *statistic_image;\n  MagickBooleanType\n    status;\n  MagickOffsetType\n    progress;\n  PixelList\n    **magick_restrict pixel_list;\n  ssize_t\n    center,\n    y;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  statistic_image=CloneImage(image,0,0,MagickTrue,\n    exception);\n  if (statistic_image == (Image *) NULL)\n    return((Image *) NULL);\n  status=SetImageStorageClass(statistic_image,DirectClass,exception);\n  if (status == MagickFalse)\n    {\n      statistic_image=DestroyImage(statistic_image);\n      return((Image *) NULL);\n    }\n  pixel_list=AcquirePixelListThreadSet(MagickMax(width,1),MagickMax(height,1));\n  if (pixel_list == (PixelList **) NULL)\n    {\n      statistic_image=DestroyImage(statistic_image);\n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  center=(ssize_t) GetPixelChannels(image)*(image->columns+MagickMax(width,1))*\n    (MagickMax(height,1)\/2L)+GetPixelChannels(image)*(MagickMax(width,1)\/2L);\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  statistic_view=AcquireAuthenticCacheView(statistic_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(image,statistic_image,statistic_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) statistic_image->rows; y++)\n  {\n    const int\n      id = GetOpenMPThreadId();\n    register const Quantum\n      *magick_restrict p;\n    register Quantum\n      *magick_restrict q;\n    register ssize_t\n      x;\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-((ssize_t) MagickMax(width,1)\/2L),y-\n      (ssize_t) (MagickMax(height,1)\/2L),image->columns+MagickMax(width,1),\n      MagickMax(height,1),exception);\n    q=QueueCacheViewAuthenticPixels(statistic_view,0,y,statistic_image->columns,      1,exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) statistic_image->columns; x++)\n    {\n      register ssize_t\n        i;\n      for (i=0; i < (ssize_t) GetPixelChannels(image); i++)\n      {\n        Quantum\n          pixel;\n        register const Quantum\n          *magick_restrict pixels;\n        register ssize_t\n          u;\n        ssize_t\n          v;\n        PixelChannel channel = GetPixelChannelChannel(image,i);\n        PixelTrait traits = GetPixelChannelTraits(image,channel);\n        PixelTrait statistic_traits=GetPixelChannelTraits(statistic_image,\n          channel);\n        if ((traits == UndefinedPixelTrait) ||\n            (statistic_traits == UndefinedPixelTrait))\n          continue;\n        if (((statistic_traits & CopyPixelTrait) != 0) ||\n            (GetPixelWriteMask(image,p) <= (QuantumRange\/2)))\n          {\n            SetPixelChannel(statistic_image,channel,p[center+i],q);\n            continue;\n          }\n        if ((statistic_traits & UpdatePixelTrait) == 0)\n          continue;\n        pixels=p;\n        ResetPixelList(pixel_list[id]);\n        for (v=0; v < (ssize_t) MagickMax(height,1); v++)\n        {\n          for (u=0; u < (ssize_t) MagickMax(width,1); u++)\n          {\n            InsertPixelList(pixels[i],pixel_list[id]);\n            pixels+=GetPixelChannels(image);\n          }\n          pixels+=GetPixelChannels(image)*image->columns;\n        }\n        switch (type)\n        {\n          case GradientStatistic:\n          {\n            double\n              maximum,\n              minimum;\n            GetMinimumPixelList(pixel_list[id],&pixel);\n            minimum=(double) pixel;\n            GetMaximumPixelList(pixel_list[id],&pixel);\n            maximum=(double) pixel;\n            pixel=ClampToQuantum(MagickAbsoluteValue(maximum-minimum));\n            break;\n          }\n          case MaximumStatistic:\n          {\n            GetMaximumPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case MeanStatistic:\n          {\n            GetMeanPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case MedianStatistic:\n          default:\n          {\n            GetMedianPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case MinimumStatistic:\n          {\n            GetMinimumPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case ModeStatistic:\n          {\n            GetModePixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case NonpeakStatistic:\n          {\n            GetNonpeakPixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case RootMeanSquareStatistic:\n          {\n            GetRootMeanSquarePixelList(pixel_list[id],&pixel);\n            break;\n          }\n          case StandardDeviationStatistic:\n          {\n            GetStandardDeviationPixelList(pixel_list[id],&pixel);\n            break;\n          }\n        }\n        SetPixelChannel(statistic_image,channel,pixel,q);\n      }\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(statistic_image);\n    }\n    if (SyncCacheViewAuthenticPixels(statistic_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,StatisticImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  statistic_view=DestroyCacheView(statistic_view);\n  image_view=DestroyCacheView(image_view);\n  pixel_list=DestroyPixelListThreadSet(pixel_list);\n  if (status == MagickFalse)\n    statistic_image=DestroyImage(statistic_image);\n  return(statistic_image);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":96745
  },
  {
    "code":"static size_t FindStringEnd(const string& line, size_t start, char delim) {\n  DCHECK(start < line.length() && line[start] == delim &&\n         (delim == '\"' || delim == '\\''));\n  const char set[] = { delim, '\\\\', '\\0' };\n  for (;;) {\n    size_t end = line.find_first_of(set, start + 1);\n    if (end == string::npos)\n      return line.length();\n    if (line[end] == '\\\\') {\n      start = end + 1;\n      if (start == line.length())\n        return start;\n      continue;\n    }\n    return end;\n  }\n  NOTREACHED();\n  return line.length();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":100830
  },
  {
    "code":"int mwifiex_set_secure_params(struct mwifiex_private *priv,\n            struct mwifiex_uap_bss_param *bss_config,\n            struct cfg80211_ap_settings *params) {\n  int i;\n  struct mwifiex_wep_key wep_key;\n  if (!params->privacy) {\n    bss_config->protocol = PROTOCOL_NO_SECURITY;\n    bss_config->key_mgmt = KEY_MGMT_NONE;\n    bss_config->wpa_cfg.length = 0;\n    priv->sec_info.wep_enabled = 0;\n    priv->sec_info.wpa_enabled = 0;\n    priv->sec_info.wpa2_enabled = 0;\n    return 0;\n  }\n  switch (params->auth_type) {\n  case NL80211_AUTHTYPE_OPEN_SYSTEM:\n    bss_config->auth_mode = WLAN_AUTH_OPEN;\n    break;\n  case NL80211_AUTHTYPE_SHARED_KEY:\n    bss_config->auth_mode = WLAN_AUTH_SHARED_KEY;\n    break;\n  case NL80211_AUTHTYPE_NETWORK_EAP:\n    bss_config->auth_mode = WLAN_AUTH_LEAP;\n    break;\n  default:\n    bss_config->auth_mode = MWIFIEX_AUTH_MODE_AUTO;\n    break;\n  }\n  bss_config->key_mgmt_operation |= KEY_MGMT_ON_HOST;\n  for (i = 0; i < params->crypto.n_akm_suites; i++) {\n    switch (params->crypto.akm_suites[i]) {\n    case WLAN_AKM_SUITE_8021X:\n      if (params->crypto.wpa_versions &\n          NL80211_WPA_VERSION_1) {\n        bss_config->protocol = PROTOCOL_WPA;\n        bss_config->key_mgmt = KEY_MGMT_EAP;\n      }\n      if (params->crypto.wpa_versions &\n          NL80211_WPA_VERSION_2) {\n        bss_config->protocol |= PROTOCOL_WPA2;\n        bss_config->key_mgmt = KEY_MGMT_EAP;\n      }\n      break;\n    case WLAN_AKM_SUITE_PSK:\n      if (params->crypto.wpa_versions &\n          NL80211_WPA_VERSION_1) {\n        bss_config->protocol = PROTOCOL_WPA;\n        bss_config->key_mgmt = KEY_MGMT_PSK;\n      }\n      if (params->crypto.wpa_versions &\n          NL80211_WPA_VERSION_2) {\n        bss_config->protocol |= PROTOCOL_WPA2;\n        bss_config->key_mgmt = KEY_MGMT_PSK;\n      }\n      break;\n    default:\n      break;\n    }\n  }\n  for (i = 0; i < params->crypto.n_ciphers_pairwise; i++) {\n    switch (params->crypto.ciphers_pairwise[i]) {\n    case WLAN_CIPHER_SUITE_WEP40:\n    case WLAN_CIPHER_SUITE_WEP104:\n      break;\n    case WLAN_CIPHER_SUITE_TKIP:\n      if (params->crypto.wpa_versions & NL80211_WPA_VERSION_1)\n        bss_config->wpa_cfg.pairwise_cipher_wpa |=\n                CIPHER_TKIP;\n      if (params->crypto.wpa_versions & NL80211_WPA_VERSION_2)\n        bss_config->wpa_cfg.pairwise_cipher_wpa2 |=\n                CIPHER_TKIP;\n      break;\n    case WLAN_CIPHER_SUITE_CCMP:\n      if (params->crypto.wpa_versions & NL80211_WPA_VERSION_1)\n        bss_config->wpa_cfg.pairwise_cipher_wpa |=\n                CIPHER_AES_CCMP;\n      if (params->crypto.wpa_versions & NL80211_WPA_VERSION_2)\n        bss_config->wpa_cfg.pairwise_cipher_wpa2 |=\n                CIPHER_AES_CCMP;\n    default:\n      break;\n    }\n  }\n  switch (params->crypto.cipher_group) {\n  case WLAN_CIPHER_SUITE_WEP40:\n  case WLAN_CIPHER_SUITE_WEP104:\n    if (priv->sec_info.wep_enabled) {\n      bss_config->protocol = PROTOCOL_STATIC_WEP;\n      bss_config->key_mgmt = KEY_MGMT_NONE;\n      bss_config->wpa_cfg.length = 0;\n      for (i = 0; i < NUM_WEP_KEYS; i++) {\n        wep_key = priv->wep_key[i];\n        bss_config->wep_cfg[i].key_index = i;\n        if (priv->wep_key_curr_index == i)\n          bss_config->wep_cfg[i].is_default = 1;\n        else\n          bss_config->wep_cfg[i].is_default = 0;\n        bss_config->wep_cfg[i].length =\n                   wep_key.key_length;\n        memcpy(&bss_config->wep_cfg[i].key,\n               &wep_key.key_material,\n               wep_key.key_length);\n      }\n    }\n    break;\n  case WLAN_CIPHER_SUITE_TKIP:\n    bss_config->wpa_cfg.group_cipher = CIPHER_TKIP;\n    break;\n  case WLAN_CIPHER_SUITE_CCMP:\n    bss_config->wpa_cfg.group_cipher = CIPHER_AES_CCMP;\n    break;\n  default:\n    break;\n  }\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":88616
  },
  {
    "code":"static void virtcons_remove(struct virtio_device *vdev)\n{\n  struct ports_device *portdev;\n  struct port *port, *port2;\n  portdev = vdev->priv;\n  spin_lock_irq(&pdrvdata_lock);\n  list_del(&portdev->list);\n  spin_unlock_irq(&pdrvdata_lock);\n  vdev->config->reset(vdev);\n  if (use_multiport(portdev))\n    cancel_work_sync(&portdev->control_work);\n  else\n    cancel_work_sync(&portdev->config_work);\n  list_for_each_entry_safe(port, port2, &portdev->ports, list)\n    unplug_port(port);\n  unregister_chrdev(portdev->chr_major, \"virtio-portsdev\");\n  remove_controlq_data(portdev);\n  remove_vqs(portdev);\n  kfree(portdev);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":66625
  },
  {
    "code":"static void ahci_mem_write(void *opaque, hwaddr addr,\n                           uint64_t val, unsigned size)\n{\n    AHCIState *s = opaque;\n    DPRINTF(-1, \"addr=0x%\" HWADDR_PRIx \" val=0x%\" PRIx64 \", size=%d\\n\",\n            addr, val, size);\n    if (addr & 3) {\n        fprintf(stderr, \"ahci: Mis-aligned write to addr 0x\"\n                TARGET_FMT_plx \"\\n\", addr);\n        return;\n    }\n    if (addr < AHCI_GENERIC_HOST_CONTROL_REGS_MAX_ADDR) {\n        DPRINTF(-1, \"(addr 0x%08X), val 0x%08\"PRIX64\"\\n\", (unsigned) addr, val);\n        switch (addr) {\n            case HOST_CAP: \n                break;\n            case HOST_CTL: \n                if (val & HOST_CTL_RESET) {\n                    DPRINTF(-1, \"HBA Reset\\n\");\n                    ahci_reset(s);\n                } else {\n                    s->control_regs.ghc = (val & 0x3) | HOST_CTL_AHCI_EN;\n                    ahci_check_irq(s);\n                }\n                break;\n            case HOST_IRQ_STAT: \n                s->control_regs.irqstatus &= ~val;\n                ahci_check_irq(s);\n                break;\n            case HOST_PORTS_IMPL: \n                break;\n            case HOST_VERSION: \n                break;\n            default:\n                DPRINTF(-1, \"write to unknown register 0x%x\\n\", (unsigned)addr);\n        }\n    } else if ((addr >= AHCI_PORT_REGS_START_ADDR) &&\n               (addr < (AHCI_PORT_REGS_START_ADDR +\n                (s->ports * AHCI_PORT_ADDR_OFFSET_LEN)))) {\n        ahci_port_write(s, (addr - AHCI_PORT_REGS_START_ADDR) >> 7,\n                        addr & AHCI_PORT_ADDR_OFFSET_MASK, val);\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":5871
  },
  {
    "code":"void __tcp_v4_send_check(struct sk_buff *skb, __be32 saddr, __be32 daddr)\n{\n  struct tcphdr *th = tcp_hdr(skb);\n  if (skb->ip_summed == CHECKSUM_PARTIAL) {\n    th->check = ~tcp_v4_check(skb->len, saddr, daddr, 0);\n    skb->csum_start = skb_transport_header(skb) - skb->head;\n    skb->csum_offset = offsetof(struct tcphdr, check);\n  } else {\n    th->check = tcp_v4_check(skb->len, saddr, daddr,\n           csum_partial(th,\n                  th->doff << 2,\n                  skb->csum));\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":49229
  },
  {
    "code":"void LocalFrameClientImpl::DispatchDidFailLoad(\n    const ResourceError& error,\n    WebHistoryCommitType commit_type) {\n  web_frame_->DidFail(error, false, commit_type);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":158070
  },
  {
    "code":"sg_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n  Sg_fd *sfp;\n  unsigned long req_sz, len, sa;\n  Sg_scatter_hold *rsv_schp;\n  int k, length;\n  int ret = 0;\n  if ((!filp) || (!vma) || (!(sfp = (Sg_fd *) filp->private_data)))\n    return -ENXIO;\n  req_sz = vma->vm_end - vma->vm_start;\n  SCSI_LOG_TIMEOUT(3, sg_printk(KERN_INFO, sfp->parentdp,\n              \"sg_mmap starting, vm_start=%p, len=%d\\n\",\n              (void *) vma->vm_start, (int) req_sz));\n  if (vma->vm_pgoff)\n    return -EINVAL;  \n  rsv_schp = &sfp->reserve;\n  mutex_lock(&sfp->f_mutex);\n  if (req_sz > rsv_schp->bufflen) {\n    ret = -ENOMEM;  \n    goto out;\n  }\n  sa = vma->vm_start;\n  length = 1 << (PAGE_SHIFT + rsv_schp->page_order);\n  for (k = 0; k < rsv_schp->k_use_sg && sa < vma->vm_end; k++) {\n    len = vma->vm_end - sa;\n    len = (len < length) ? len : length;\n    sa += len;\n  }\n  sfp->mmap_called = 1;\n  vma->vm_flags |= VM_IO | VM_DONTEXPAND | VM_DONTDUMP;\n  vma->vm_private_data = sfp;\n  vma->vm_ops = &sg_mmap_vm_ops;\nout:\n  mutex_unlock(&sfp->f_mutex);\n  return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":60763
  },
  {
    "code":"xmlXPtrGetArity(xmlNodePtr cur) {\n    int i;\n    if (cur == NULL) \n  return(-1);\n    cur = cur->children;\n    for (i = 0;cur != NULL;cur = cur->next) {\n  if ((cur->type == XML_ELEMENT_NODE) ||\n      (cur->type == XML_DOCUMENT_NODE) ||\n      (cur->type == XML_HTML_DOCUMENT_NODE)) {\n      i++;\n  }\n    }\n    return(i);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":117308
  },
  {
    "code":"static int em_and(struct x86_emulate_ctxt *ctxt)\n{\n  emulate_2op_SrcV(ctxt, \"and\");\n  return X86EMUL_CONTINUE;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":21728
  },
  {
    "code":"  const Vp9Segmentation& GetSegmentation() const {\n    return vp9_parser_.GetSegmentation();\n  }\n",
    "vul":1,
    "flaw_line_no":[
      2,
      3
    ],
    "bigvul_id":183549
  },
  {
    "code":"static void __prog_put_common(struct rcu_head *rcu)\n{\n  struct bpf_prog_aux *aux = container_of(rcu, struct bpf_prog_aux, rcu);\n  free_used_maps(aux);\n  bpf_prog_uncharge_memlock(aux->prog);\n  bpf_prog_free(aux->prog);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":53047
  },
  {
    "code":"static struct bpf_prog *__bpf_prog_get(struct fd f)\n{\n  if (!f.file)\n    return ERR_PTR(-EBADF);\n  if (f.file->f_op != &bpf_prog_fops) {\n    fdput(f);\n    return ERR_PTR(-EINVAL);\n  }\n   return f.file->private_data;\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":53046
  },
  {
    "code":"xmlXPathEqualValues(xmlXPathParserContextPtr ctxt) {\n    xmlXPathObjectPtr arg1, arg2, argtmp;\n    int ret = 0;\n    if ((ctxt == NULL) || (ctxt->context == NULL)) return(0);\n    arg2 = valuePop(ctxt);\n    arg1 = valuePop(ctxt);\n    if ((arg1 == NULL) || (arg2 == NULL)) {\n  if (arg1 != NULL)\n      xmlXPathReleaseObject(ctxt->context, arg1);\n  else\n      xmlXPathReleaseObject(ctxt->context, arg2);\n  XP_ERROR0(XPATH_INVALID_OPERAND);\n    }\n    if (arg1 == arg2) {\n#ifdef DEBUG_EXPR\n        xmlGenericError(xmlGenericErrorContext,\n    \"Equal: by pointer\\n\");\n#endif\n  xmlXPathFreeObject(arg1);\n        return(1);\n    }\n    if ((arg2->type == XPATH_NODESET) || (arg2->type == XPATH_XSLT_TREE) ||\n      (arg1->type == XPATH_NODESET) || (arg1->type == XPATH_XSLT_TREE)) {\n  if ((arg1->type != XPATH_NODESET) && (arg1->type != XPATH_XSLT_TREE)) {\n    argtmp = arg2;\n    arg2 = arg1;\n    arg1 = argtmp;\n  }\n  switch (arg2->type) {\n      case XPATH_UNDEFINED:\n#ifdef DEBUG_EXPR\n    xmlGenericError(xmlGenericErrorContext,\n      \"Equal: undefined\\n\");\n#endif\n    break;\n      case XPATH_NODESET:\n      case XPATH_XSLT_TREE:\n    ret = xmlXPathEqualNodeSets(arg1, arg2, 0);\n    break;\n      case XPATH_BOOLEAN:\n    if ((arg1->nodesetval == NULL) ||\n      (arg1->nodesetval->nodeNr == 0)) ret = 0;\n    else\n        ret = 1;\n    ret = (ret == arg2->boolval);\n    break;\n      case XPATH_NUMBER:\n    ret = xmlXPathEqualNodeSetFloat(ctxt, arg1, arg2->floatval, 0);\n    break;\n      case XPATH_STRING:\n    ret = xmlXPathEqualNodeSetString(arg1, arg2->stringval, 0);\n    break;\n      case XPATH_USERS:\n      case XPATH_POINT:\n      case XPATH_RANGE:\n      case XPATH_LOCATIONSET:\n    TODO\n    break;\n  }\n  xmlXPathReleaseObject(ctxt->context, arg1);\n  xmlXPathReleaseObject(ctxt->context, arg2);\n  return(ret);\n    }\n    return (xmlXPathEqualValuesCommon(ctxt, arg1, arg2));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":97662
  },
  {
    "code":"void UsbChooserContext::DestroyDeviceManagerForTesting() {\n  device_manager_instance_.reset();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":170300
  },
  {
    "code":"static void napi_reuse_skb(struct napi_struct *napi, struct sk_buff *skb)\n{\n  __skb_pull(skb, skb_headlen(skb));\n  skb_reserve(skb, NET_IP_ALIGN - skb_headroom(skb));\n  skb->vlan_tci = 0;\n  skb->dev = napi->dev;\n  skb->skb_iif = 0;\n  napi->skb = skb;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":35270
  },
  {
    "code":"static void n_tty_receive_parity_error(struct tty_struct *tty, unsigned char c)\n{\n  struct n_tty_data *ldata = tty->disc_data;\n  if (I_IGNPAR(tty))\n    return;\n  if (I_PARMRK(tty)) {\n    put_tty_queue('\\377', ldata);\n    put_tty_queue('\\0', ldata);\n    put_tty_queue(c, ldata);\n  } else  if (I_INPCK(tty))\n    put_tty_queue('\\0', ldata);\n  else\n    put_tty_queue(c, ldata);\n  if (waitqueue_active(&tty->read_wait))\n    wake_up_interruptible(&tty->read_wait);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":39826
  },
  {
    "code":"struct net_device *__dev_get_by_name(struct net *net, const char *name)\n{\n  struct net_device *dev;\n  struct hlist_head *head = dev_name_hash(net, name);\n  hlist_for_each_entry(dev, head, name_hlist)\n    if (!strncmp(dev->name, name, IFNAMSIZ))\n      return dev;\n  return NULL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":48732
  },
  {
    "code":"Browser* InProcessBrowserTest::CreateBrowser(Profile* profile) {\n  Browser* browser = Browser::Create(profile);\n  AddBlankTabAndShow(browser);\n  return browser;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":117679
  },
  {
    "code":"char16_t* utf8_to_utf16_n(const uint8_t* src, size_t srcLen, char16_t* dst, size_t dstLen) {\n const uint8_t* const u8end = src + srcLen;\n const uint8_t* u8cur = src;\n const char16_t* const u16end = dst + dstLen;\n char16_t* u16cur = dst;\n while (u8cur < u8end && u16cur < u16end) {\n size_t u8len = utf8_codepoint_len(*u8cur);\n uint32_t codepoint = utf8_to_utf32_codepoint(u8cur, u8len);\n if (codepoint <= 0xFFFF) {\n *u16cur++ = (char16_t) codepoint;\n } else {\n            codepoint = codepoint - 0x10000;\n *u16cur++ = (char16_t) ((codepoint >> 10) + 0xD800);\n if (u16cur >= u16end) {\n return u16cur-1;\n }\n *u16cur++ = (char16_t) ((codepoint & 0x3FF) + 0xDC00);\n }\n        u8cur += u8len;\n }\n return u16cur;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":171616
  },
  {
    "code":"void GpuProcessHost::RouteOnUIThread(const IPC::Message& message) {\n  BrowserThread::PostTask(\n      BrowserThread::UI,\n      FROM_HERE,\n      base::Bind(&RouteToGpuProcessHostUIShimTask, host_id_, message));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":109918
  },
  {
    "code":"void blk_dump_rq_flags(struct request *rq, char *msg)\n{\n  printk(KERN_INFO \"%s: dev %s: flags=%llx\\n\", msg,\n    rq->rq_disk ? rq->rq_disk->disk_name : \"?\",\n    (unsigned long long) rq->cmd_flags);\n  printk(KERN_INFO \"  sector %llu, nr\/cnr %u\/%u\\n\",\n         (unsigned long long)blk_rq_pos(rq),\n         blk_rq_sectors(rq), blk_rq_cur_sectors(rq));\n  printk(KERN_INFO \"  bio %p, biotail %p, len %u\\n\",\n         rq->bio, rq->biotail, blk_rq_bytes(rq));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":91974
  },
  {
    "code":"static int compat_do_arpt_set_ctl(struct sock *sk, int cmd, void __user *user,\n          unsigned int len)\n{\n  int ret;\n  if (!ns_capable(sock_net(sk)->user_ns, CAP_NET_ADMIN))\n    return -EPERM;\n  switch (cmd) {\n  case ARPT_SO_SET_REPLACE:\n    ret = compat_do_replace(sock_net(sk), user, len);\n    break;\n  case ARPT_SO_SET_ADD_COUNTERS:\n    ret = do_add_counters(sock_net(sk), user, len, 1);\n    break;\n  default:\n    duprintf(\"do_arpt_set_ctl:  unknown request %i\\n\", cmd);\n    ret = -EINVAL;\n  }\n  return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":52245
  },
  {
    "code":"status_to_message(u_int32_t status)\n{\n  const char *status_messages[] = {\n    \"Success\",      \n    \"End of file\",      \n    \"No such file\",      \n    \"Permission denied\",    \n    \"Failure\",      \n    \"Bad message\",      \n    \"No connection\",    \n    \"Connection lost\",    \n    \"Operation unsupported\",  \n    \"Unknown error\"      \n  };\n  return (status_messages[MINIMUM(status,SSH2_FX_MAX)]);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":60385
  },
  {
    "code":"int SafeSock::attach_to_file_desc(int fd)\n{\n  if (_state != sock_virgin) return FALSE;\n  _sock = fd;\n  _state = sock_connect;\n  timeout(0); \n  return TRUE;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":16272
  },
  {
    "code":"int mbedtls_ecdsa_read_signature( mbedtls_ecdsa_context *ctx,\n                          const unsigned char *hash, size_t hlen,\n                          const unsigned char *sig, size_t slen )\n{\n    int ret;\n    unsigned char *p = (unsigned char *) sig;\n    const unsigned char *end = sig + slen;\n    size_t len;\n    mbedtls_mpi r, s;\n    mbedtls_mpi_init( &r );\n    mbedtls_mpi_init( &s );\n    if( ( ret = mbedtls_asn1_get_tag( &p, end, &len,\n                    MBEDTLS_ASN1_CONSTRUCTED | MBEDTLS_ASN1_SEQUENCE ) ) != 0 )\n    {\n        ret += MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n        goto cleanup;\n    }\n    if( p + len != end )\n    {\n        ret = MBEDTLS_ERR_ECP_BAD_INPUT_DATA +\n              MBEDTLS_ERR_ASN1_LENGTH_MISMATCH;\n        goto cleanup;\n    }\n    if( ( ret = mbedtls_asn1_get_mpi( &p, end, &r ) ) != 0 ||\n        ( ret = mbedtls_asn1_get_mpi( &p, end, &s ) ) != 0 )\n    {\n        ret += MBEDTLS_ERR_ECP_BAD_INPUT_DATA;\n        goto cleanup;\n    }\n    if( ( ret = mbedtls_ecdsa_verify( &ctx->grp, hash, hlen,\n                              &ctx->Q, &r, &s ) ) != 0 )\n        goto cleanup;\n    if( p != end )\n        ret = MBEDTLS_ERR_ECP_SIG_LEN_MISMATCH;\ncleanup:\n    mbedtls_mpi_free( &r );\n    mbedtls_mpi_free( &s );\n    return( ret );\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":96541
  },
  {
    "code":"  void OnResult(blink::ServiceWorkerStatusCode) {\n    DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":152155
  },
  {
    "code":"void ChromeContentBrowserClient::ShowClientCertificateRequestDialog(\n    int render_process_id,\n    int render_view_id,\n    SSLClientAuthHandler* handler) {\n  TabContents* tab = tab_util::GetTabContentsByID(\n      render_process_id, render_view_id);\n  if (!tab) {\n    NOTREACHED();\n    return;\n  }\n  TabContentsWrapper* wrapper =\n      TabContentsWrapper::GetCurrentWrapperForContents(tab);\n  wrapper->ssl_helper()->ShowClientCertificateRequestDialog(handler);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":103630
  },
  {
    "code":"ec_invm (gcry_mpi_t x, gcry_mpi_t a, mpi_ec_t ctx)\n{\n  if (!mpi_invm (x, a, ctx->p))\n    {\n      log_error (\"ec_invm: inverse does not exist:\\n\");\n      log_mpidump (\"  a\", a);\n      log_mpidump (\"  p\", ctx->p);\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":13063
  },
  {
    "code":"GF_Err stbl_Write(GF_Box *s, GF_BitStream *bs)\n{\n  GF_Err e;\n  GF_SampleTableBox *ptr = (GF_SampleTableBox *)s;\n  if (!s) return GF_BAD_PARAM;\n  e = gf_isom_box_write_header(s, bs);\n  if (e) return e;\n  if (ptr->SampleDescription) {\n    e = gf_isom_box_write((GF_Box *) ptr->SampleDescription, bs);\n    if (e) return e;\n  }\n  if (ptr->TimeToSample) {\n    e = gf_isom_box_write((GF_Box *) ptr->TimeToSample, bs);\n    if (e) return e;\n  }\n  if (ptr->CompositionOffset)  {\n    e = gf_isom_box_write((GF_Box *) ptr->CompositionOffset, bs);\n    if (e) return e;\n  }\n  if (ptr->CompositionToDecode)  {\n    e = gf_isom_box_write((GF_Box *) ptr->CompositionToDecode, bs);\n    if (e) return e;\n  }\n  if (ptr->SyncSample) {\n    e = gf_isom_box_write((GF_Box *) ptr->SyncSample, bs);\n    if (e) return e;\n  }\n  if (ptr->ShadowSync) {\n    e = gf_isom_box_write((GF_Box *) ptr->ShadowSync, bs);\n    if (e) return e;\n  }\n  if (ptr->SampleToChunk) {\n    e = gf_isom_box_write((GF_Box *) ptr->SampleToChunk, bs);\n    if (e) return e;\n  }\n  if (ptr->SampleSize) {\n    e = gf_isom_box_write((GF_Box *) ptr->SampleSize, bs);\n    if (e) return e;\n  }\n  if (ptr->ChunkOffset) {\n    e = gf_isom_box_write(ptr->ChunkOffset, bs);\n    if (e) return e;\n  }\n  if (ptr->DegradationPriority) {\n    e = gf_isom_box_write((GF_Box *) ptr->DegradationPriority, bs);\n    if (e) return e;\n  }\n  if (ptr->SampleDep && ptr->SampleDep->sampleCount) {\n    e = gf_isom_box_write((GF_Box *) ptr->SampleDep, bs);\n    if (e) return e;\n  }\n  if (ptr->PaddingBits) {\n    e = gf_isom_box_write((GF_Box *) ptr->PaddingBits, bs);\n    if (e) return e;\n  }\n  if (ptr->sub_samples) {\n    e = gf_isom_box_array_write(s, ptr->sub_samples, bs);\n    if (e) return e;\n  }\n  if (ptr->sampleGroupsDescription) {\n    e = gf_isom_box_array_write(s, ptr->sampleGroupsDescription, bs);\n    if (e) return e;\n  }\n  if (ptr->sampleGroups) {\n    e = gf_isom_box_array_write(s, ptr->sampleGroups, bs);\n    if (e) return e;\n  }\n  if (ptr->sai_sizes) {\n    e = gf_isom_box_array_write(s, ptr->sai_sizes, bs);\n    if (e) return e;\n  }\n  if (ptr->sai_offsets) {\n    e = gf_isom_box_array_write(s, ptr->sai_offsets, bs);\n    if (e) return e;\n  }\n  return GF_OK;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":91886
  },
  {
    "code":"static void save_to_event_log(struct analyze_event_data *evd, const char *str)\n{\n    static const char delim[] = {\n        [LOGSTATE_FIRSTLINE] = '>',\n        [LOGSTATE_BEGLINE] = ' ',\n        [LOGSTATE_ERRLINE] = '*',\n    };\n    while (str[0])\n    {\n        char *end = strchrnul(str, '\\n');\n        char end_char = *end;\n        if (end_char == '\\n')\n            end++;\n        switch (evd->event_log_state)\n        {\n            case LOGSTATE_FIRSTLINE:\n            case LOGSTATE_BEGLINE:\n            case LOGSTATE_ERRLINE:\n                if (str[0] == '\\n')\n                    goto next;\n                strbuf_append_strf(evd->event_log, \"%s%c %.*s\",\n                        iso_date_string(NULL),\n                        delim[evd->event_log_state],\n                        (int)(end - str), str\n                );\n                break;\n            case LOGSTATE_MIDLINE:\n                strbuf_append_strf(evd->event_log, \"%.*s\", (int)(end - str), str);\n                break;\n        }\n        evd->event_log_state = LOGSTATE_MIDLINE;\n        if (end_char != '\\n')\n            break;\n        evd->event_log_state = LOGSTATE_BEGLINE;\n next:\n        str = end;\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":42867
  },
  {
    "code":"static void detach_entity_load_avg(struct cfs_rq *cfs_rq, struct sched_entity *se)\n{\n  dequeue_load_avg(cfs_rq, se);\n  sub_positive(&cfs_rq->avg.util_avg, se->avg.util_avg);\n  sub_positive(&cfs_rq->avg.util_sum, se->avg.util_sum);\n  add_tg_cfs_propagate(cfs_rq, -se->avg.load_sum);\n  cfs_rq_util_change(cfs_rq, 0);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":92530
  },
  {
    "code":"static void usb_xhci_realize(struct PCIDevice *dev, Error **errp)\n{\n    int i, ret;\n    Error *err = NULL;\n    XHCIState *xhci = XHCI(dev);\n    dev->config[PCI_CLASS_PROG] = 0x30;    \n    dev->config[PCI_INTERRUPT_PIN] = 0x01; \n    dev->config[PCI_CACHE_LINE_SIZE] = 0x10;\n    dev->config[0x60] = 0x30; \n    usb_xhci_init(xhci);\n    if (xhci->msi != ON_OFF_AUTO_OFF) {\n        ret = msi_init(dev, 0x70, xhci->numintrs, true, false, &err);\n        assert(!ret || ret == -ENOTSUP);\n        if (ret && xhci->msi == ON_OFF_AUTO_ON) {\n            error_append_hint(&err, \"You have to use msi=auto (default) or \"\n                    \"msi=off with this machine type.\\n\");\n            error_propagate(errp, err);\n            return;\n        }\n        assert(!err || xhci->msi == ON_OFF_AUTO_AUTO);\n        error_free(err);\n    }\n    if (xhci->numintrs > MAXINTRS) {\n        xhci->numintrs = MAXINTRS;\n    }\n    while (xhci->numintrs & (xhci->numintrs - 1)) {   \n        xhci->numintrs++;\n    }\n    if (xhci->numintrs < 1) {\n        xhci->numintrs = 1;\n    }\n    if (xhci->numslots > MAXSLOTS) {\n        xhci->numslots = MAXSLOTS;\n    }\n    if (xhci->numslots < 1) {\n        xhci->numslots = 1;\n    }\n    if (xhci_get_flag(xhci, XHCI_FLAG_ENABLE_STREAMS)) {\n        xhci->max_pstreams_mask = 7; \n    } else {\n        xhci->max_pstreams_mask = 0;\n    }\n    xhci->mfwrap_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL, xhci_mfwrap_timer, xhci);\n    memory_region_init(&xhci->mem, OBJECT(xhci), \"xhci\", LEN_REGS);\n    memory_region_init_io(&xhci->mem_cap, OBJECT(xhci), &xhci_cap_ops, xhci,\n                          \"capabilities\", LEN_CAP);\n    memory_region_init_io(&xhci->mem_oper, OBJECT(xhci), &xhci_oper_ops, xhci,\n                          \"operational\", 0x400);\n    memory_region_init_io(&xhci->mem_runtime, OBJECT(xhci), &xhci_runtime_ops, xhci,\n                          \"runtime\", LEN_RUNTIME);\n    memory_region_init_io(&xhci->mem_doorbell, OBJECT(xhci), &xhci_doorbell_ops, xhci,\n                          \"doorbell\", LEN_DOORBELL);\n    memory_region_add_subregion(&xhci->mem, 0,            &xhci->mem_cap);\n    memory_region_add_subregion(&xhci->mem, OFF_OPER,     &xhci->mem_oper);\n    memory_region_add_subregion(&xhci->mem, OFF_RUNTIME,  &xhci->mem_runtime);\n    memory_region_add_subregion(&xhci->mem, OFF_DOORBELL, &xhci->mem_doorbell);\n    for (i = 0; i < xhci->numports; i++) {\n        XHCIPort *port = &xhci->ports[i];\n        uint32_t offset = OFF_OPER + 0x400 + 0x10 * i;\n        port->xhci = xhci;\n        memory_region_init_io(&port->mem, OBJECT(xhci), &xhci_port_ops, port,\n                              port->name, 0x10);\n        memory_region_add_subregion(&xhci->mem, offset, &port->mem);\n    }\n    pci_register_bar(dev, 0,\n                     PCI_BASE_ADDRESS_SPACE_MEMORY|PCI_BASE_ADDRESS_MEM_TYPE_64,\n                     &xhci->mem);\n    if (pci_bus_is_express(dev->bus) ||\n        xhci_get_flag(xhci, XHCI_FLAG_FORCE_PCIE_ENDCAP)) {\n        ret = pcie_endpoint_cap_init(dev, 0xa0);\n        assert(ret >= 0);\n    }\n    if (xhci->msix != ON_OFF_AUTO_OFF) {\n        msix_init(dev, xhci->numintrs,\n                  &xhci->mem, 0, OFF_MSIX_TABLE,\n                  &xhci->mem, 0, OFF_MSIX_PBA,\n                  0x90);\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":8329
  },
  {
    "code":"void simulateDoubleTap(WebViewImpl* webViewImpl, WebPoint& point, float& scale)\n{\n    webViewImpl->animateDoubleTapZoom(point);\n    EXPECT_TRUE(webViewImpl->fakeDoubleTapAnimationPendingForTesting());\n    simulatePageScale(webViewImpl, scale);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":119539
  },
  {
    "code":"gfx::Rect RenderWidgetHostImpl::GetRootWindowResizerRect() const {\n  return gfx::Rect();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":122973
  },
  {
    "code":"TextTrackCueList::TextTrackCueList() : first_invalid_index_(0) {}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":135916
  },
  {
    "code":"static int mov_flush_fragment_interleaving(AVFormatContext *s, MOVTrack *track)\n{\n    MOVMuxContext *mov = s->priv_data;\n    int ret, buf_size;\n    uint8_t *buf;\n    int i, offset;\n    if (!track->mdat_buf)\n        return 0;\n    if (!mov->mdat_buf) {\n        if ((ret = avio_open_dyn_buf(&mov->mdat_buf)) < 0)\n            return ret;\n    }\n    buf_size = avio_close_dyn_buf(track->mdat_buf, &buf);\n    track->mdat_buf = NULL;\n    offset = avio_tell(mov->mdat_buf);\n    avio_write(mov->mdat_buf, buf, buf_size);\n    av_free(buf);\n    for (i = track->entries_flushed; i < track->entry; i++)\n        track->cluster[i].pos += offset;\n    track->entries_flushed = track->entry;\n    return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":79309
  },
  {
    "code":"void Browser::RequestMediaAccessPermission(\n    content::WebContents* web_contents,\n    const content::MediaStreamRequest& request,\n    const content::MediaResponseCallback& callback) {\n  ::RequestMediaAccessPermission(web_contents, profile_, request, callback);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":151724
  },
  {
    "code":"static int vrend_decode_create_sub_ctx(struct vrend_decode_ctx *ctx, int length)\n{\n   if (length != 1)\n      return EINVAL;\n   uint32_t ctx_sub_id = get_buf_entry(ctx, 1);\n   vrend_renderer_create_sub_ctx(ctx->grctx, ctx_sub_id);\n   return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":9102
  },
  {
    "code":"static void inet6_ifa_notify(int event, struct inet6_ifaddr *ifa)\n{\n  struct sk_buff *skb;\n  struct net *net = dev_net(ifa->idev->dev);\n  int err = -ENOBUFS;\n  skb = nlmsg_new(inet6_ifaddr_msgsize(), GFP_ATOMIC);\n  if (skb == NULL)\n    goto errout;\n  err = inet6_fill_ifaddr(skb, ifa, 0, 0, event, 0);\n  if (err < 0) {\n    WARN_ON(err == -EMSGSIZE);\n    kfree_skb(skb);\n    goto errout;\n  }\n  rtnl_notify(skb, net, 0, RTNLGRP_IPV6_IFADDR, NULL, GFP_ATOMIC);\n  return;\nerrout:\n  if (err < 0)\n    rtnl_set_sk_err(net, RTNLGRP_IPV6_IFADDR, err);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":41840
  },
  {
    "code":"jbig2_parse_segment_header(Jbig2Ctx *ctx, uint8_t *buf, size_t buf_size, size_t *p_header_size)\n{\n    Jbig2Segment *result;\n     uint8_t rtscarf;\n     uint32_t rtscarf_long;\n     uint32_t *referred_to_segments;\n    int referred_to_segment_count;\n    int referred_to_segment_size;\n    int pa_size;\n    int offset;\n     if (buf_size < 11)\n        return NULL;\n    result = jbig2_new(ctx, Jbig2Segment, 1);\n    if (result == NULL) {\n        jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"failed to allocate segment in jbig2_parse_segment_header\");\n        return result;\n    }\n    result->number = jbig2_get_uint32(buf);\n    result->flags = buf[4];\n    rtscarf = buf[5];\n    if ((rtscarf & 0xe0) == 0xe0) {\n        rtscarf_long = jbig2_get_uint32(buf + 5);\n        referred_to_segment_count = rtscarf_long & 0x1fffffff;\n        offset = 5 + 4 + (referred_to_segment_count + 1) \/ 8;\n    } else {\n        referred_to_segment_count = (rtscarf >> 5);\n        offset = 5 + 1;\n    }\n    result->referred_to_segment_count = referred_to_segment_count;\n    referred_to_segment_size = result->number <= 256 ? 1 : result->number <= 65536 ? 2 : 4;     \n    pa_size = result->flags & 0x40 ? 4 : 1;     \n    if (offset + referred_to_segment_count * referred_to_segment_size + pa_size + 4 > buf_size) {\n        jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, result->number, \"jbig2_parse_segment_header() called with insufficient data\", -1);\n        jbig2_free(ctx->allocator, result);\n        return NULL;\n    }\n     if (referred_to_segment_count) {\n        int i;\n         referred_to_segments = jbig2_new(ctx, uint32_t, referred_to_segment_count * referred_to_segment_size);\n         if (referred_to_segments == NULL) {\n            jbig2_error(ctx, JBIG2_SEVERITY_FATAL, -1, \"could not allocate referred_to_segments \" \"in jbig2_parse_segment_header\");\n            return NULL;\n        }\n        for (i = 0; i < referred_to_segment_count; i++) {\n            referred_to_segments[i] =\n                (referred_to_segment_size == 1) ? buf[offset] :\n                (referred_to_segment_size == 2) ? jbig2_get_uint16(buf + offset) : jbig2_get_uint32(buf + offset);\n            offset += referred_to_segment_size;\n            jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, result->number, \"segment %d refers to segment %d\", result->number, referred_to_segments[i]);\n        }\n        result->referred_to_segments = referred_to_segments;\n    } else {                    \n        result->referred_to_segments = NULL;\n    }\n    if (result->flags & 0x40) {\n        result->page_association = jbig2_get_uint32(buf + offset);\n        offset += 4;\n    } else {\n        result->page_association = buf[offset++];\n    }\n    jbig2_error(ctx, JBIG2_SEVERITY_DEBUG, result->number, \"segment %d is associated with page %d\", result->number, result->page_association);\n    result->data_length = jbig2_get_uint32(buf + offset);\n    *p_header_size = offset + 4;\n    result->result = NULL;\n    return result;\n}\n",
    "vul":1,
    "flaw_line_no":[
      7,
      8,
      9,
      10,
      38
    ],
    "bigvul_id":178669
  },
  {
    "code":"parse_truncate_subfield(struct ofpact_output_trunc *output_trunc,\n                        const char *arg_)\n{\n    char *key, *value;\n    char *arg = CONST_CAST(char *, arg_);\n    while (ofputil_parse_key_value(&arg, &key, &value)) {\n        if (!strcmp(key, \"port\")) {\n            if (!ofputil_port_from_string(value, &output_trunc->port)) {\n                return xasprintf(\"output to unknown truncate port: %s\",\n                                  value);\n            }\n            if (ofp_to_u16(output_trunc->port) > ofp_to_u16(OFPP_MAX)) {\n                if (output_trunc->port != OFPP_LOCAL &&\n                    output_trunc->port != OFPP_IN_PORT)\n                return xasprintf(\"output to unsupported truncate port: %s\",\n                                 value);\n            }\n        } else if (!strcmp(key, \"max_len\")) {\n            char *err;\n            err = str_to_u32(value, &output_trunc->max_len);\n            if (err) {\n                return err;\n            }\n        } else {\n            return xasprintf(\"invalid key '%s' in output_trunc argument\",\n                                key);\n        }\n    }\n    return NULL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":77095
  },
  {
    "code":"cifs_match_super(struct super_block *sb, void *data)\n{\n  struct cifs_mnt_data *mnt_data = (struct cifs_mnt_data *)data;\n  struct smb_vol *volume_info;\n  struct cifs_sb_info *cifs_sb;\n  struct TCP_Server_Info *tcp_srv;\n  struct cifs_ses *ses;\n  struct cifs_tcon *tcon;\n  struct tcon_link *tlink;\n  int rc = 0;\n  spin_lock(&cifs_tcp_ses_lock);\n  cifs_sb = CIFS_SB(sb);\n  tlink = cifs_get_tlink(cifs_sb_master_tlink(cifs_sb));\n  if (IS_ERR(tlink)) {\n    spin_unlock(&cifs_tcp_ses_lock);\n    return rc;\n  }\n  tcon = tlink_tcon(tlink);\n  ses = tcon->ses;\n  tcp_srv = ses->server;\n  volume_info = mnt_data->vol;\n  if (!match_server(tcp_srv, volume_info) ||\n      !match_session(ses, volume_info) ||\n      !match_tcon(tcon, volume_info->UNC)) {\n    rc = 0;\n    goto out;\n  }\n  rc = compare_mount_options(sb, mnt_data);\nout:\n  spin_unlock(&cifs_tcp_ses_lock);\n  cifs_put_tlink(tlink);\n  return rc;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":29820
  },
  {
    "code":"IHEVCD_ERROR_T ihevcd_cabac_init(cab_ctxt_t *ps_cabac,\n bitstrm_t *ps_bitstrm,\n                                 WORD32 qp,\n                                 WORD32 cabac_init_idc,\n const UWORD8 *pu1_init_ctxt)\n{\n    ASSERT(ps_cabac != NULL);\n    ASSERT(ps_bitstrm != NULL);\n    ASSERT((qp >= 0) && (qp < 52));\n    ASSERT((cabac_init_idc >= 0) && (cabac_init_idc < 3));\n    UNUSED(qp);\n    UNUSED(cabac_init_idc);\n#if FULLRANGE\n    ps_cabac->u4_range = (UWORD32)510 << RANGE_SHIFT;\n    BITS_GET(ps_cabac->u4_ofst, ps_bitstrm->pu4_buf, ps_bitstrm->u4_bit_ofst,\n                    ps_bitstrm->u4_cur_word, ps_bitstrm->u4_nxt_word, (9 + RANGE_SHIFT));\n#else\n    ps_cabac->u4_range = (UWORD32)510;\n    BITS_GET(ps_cabac->u4_ofst, ps_bitstrm->pu4_buf, ps_bitstrm->u4_bit_ofst,\n                    ps_bitstrm->u4_cur_word, ps_bitstrm->u4_nxt_word, 9);\n#endif\n    memcpy(ps_cabac->au1_ctxt_models,\n           pu1_init_ctxt,\n           IHEVC_CAB_CTXT_END);\n    DEBUG_RANGE_OFST(\"init\", ps_cabac->u4_range, ps_cabac->u4_ofst);\n return ((IHEVCD_ERROR_T)IHEVCD_SUCCESS);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":175807
  },
  {
    "code":"void skb_queue_tail(struct sk_buff_head *list, struct sk_buff *newsk)\n{\n  unsigned long flags;\n  spin_lock_irqsave(&list->lock, flags);\n  __skb_queue_tail(list, newsk);\n  spin_unlock_irqrestore(&list->lock, flags);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":39914
  },
  {
    "code":"xmlParseExtParsedEnt(xmlParserCtxtPtr ctxt) {\n    xmlChar start[4];\n    xmlCharEncoding enc;\n    if ((ctxt == NULL) || (ctxt->input == NULL))\n        return(-1);\n    xmlDefaultSAXHandlerInit();\n    xmlDetectSAX2(ctxt);\n    GROW;\n    if ((ctxt->sax) && (ctxt->sax->setDocumentLocator))\n        ctxt->sax->setDocumentLocator(ctxt->userData, &xmlDefaultSAXLocator);\n    if ((ctxt->input->end - ctxt->input->cur) >= 4) {\n  start[0] = RAW;\n  start[1] = NXT(1);\n  start[2] = NXT(2);\n  start[3] = NXT(3);\n  enc = xmlDetectCharEncoding(start, 4);\n  if (enc != XML_CHAR_ENCODING_NONE) {\n      xmlSwitchEncoding(ctxt, enc);\n  }\n    }\n    if (CUR == 0) {\n  xmlFatalErr(ctxt, XML_ERR_DOCUMENT_EMPTY, NULL);\n    }\n    GROW;\n    if ((CMP5(CUR_PTR, '<', '?', 'x', 'm', 'l')) && (IS_BLANK_CH(NXT(5)))) {\n  xmlParseXMLDecl(ctxt);\n  if (ctxt->errNo == XML_ERR_UNSUPPORTED_ENCODING) {\n      return(-1);\n  }\n  SKIP_BLANKS;\n    } else {\n  ctxt->version = xmlCharStrdup(XML_DEFAULT_VERSION);\n    }\n    if ((ctxt->sax) && (ctxt->sax->startDocument) && (!ctxt->disableSAX))\n        ctxt->sax->startDocument(ctxt->userData);\n    ctxt->instate = XML_PARSER_CONTENT;\n    ctxt->validate = 0;\n    ctxt->loadsubset = 0;\n    ctxt->depth = 0;\n    xmlParseContent(ctxt);\n    if ((RAW == '<') && (NXT(1) == '\/')) {\n  xmlFatalErr(ctxt, XML_ERR_NOT_WELL_BALANCED, NULL);\n    } else if (RAW != 0) {\n  xmlFatalErr(ctxt, XML_ERR_EXTRA_CONTENT, NULL);\n    }\n    if ((ctxt->sax) && (ctxt->sax->endDocument != NULL))\n        ctxt->sax->endDocument(ctxt->userData);\n    if (! ctxt->wellFormed) return(-1);\n    return(0);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":100729
  },
  {
    "code":"void WebBluetoothServiceImpl::RemoteDescriptorReadValue(\n    const std::string& descriptor_instance_id,\n    RemoteDescriptorReadValueCallback callback) {\n  DCHECK_CURRENTLY_ON(BrowserThread::UI);\n  const CacheQueryResult query_result =\n      QueryCacheForDescriptor(descriptor_instance_id);\n  if (query_result.outcome == CacheQueryOutcome::BAD_RENDERER) {\n    return;\n  }\n  if (query_result.outcome != CacheQueryOutcome::SUCCESS) {\n    RecordDescriptorReadValueOutcome(query_result.outcome);\n    std::move(callback).Run(query_result.GetWebResult(),\n                            base::nullopt );\n    return;\n  }\n  if (BluetoothBlocklist::Get().IsExcludedFromReads(\n          query_result.descriptor->GetUUID())) {\n    RecordDescriptorReadValueOutcome(UMAGATTOperationOutcome::BLOCKLISTED);\n    std::move(callback).Run(blink::mojom::WebBluetoothResult::BLOCKLISTED_READ,\n                            base::nullopt );\n    return;\n  }\n  auto copyable_callback = base::AdaptCallbackForRepeating(std::move(callback));\n  query_result.descriptor->ReadRemoteDescriptor(\n      base::Bind(&WebBluetoothServiceImpl::OnDescriptorReadValueSuccess,\n                 weak_ptr_factory_.GetWeakPtr(), copyable_callback),\n      base::Bind(&WebBluetoothServiceImpl::OnDescriptorReadValueFailed,\n                 weak_ptr_factory_.GetWeakPtr(), copyable_callback));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":150819
  },
  {
    "code":"inline uint32_t ReadUInt32(uint8_t* mem_bytes, int offset) {\n  return\n      static_cast<uint32_t>(mem_bytes[offset]) |\n      (static_cast<uint32_t>(mem_bytes[offset + 1]) << 8) |\n      (static_cast<uint32_t>(mem_bytes[offset + 2]) << 16) |\n      (static_cast<uint32_t>(mem_bytes[offset + 3]) << 24);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":136191
  },
  {
    "code":"FindBarController::~FindBarController() {\n  DCHECK(!tab_contents_);\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":107369
  },
  {
    "code":"ModuleExport MagickBooleanType ReadPSDLayers(Image *image,\n  const ImageInfo *image_info,const PSDInfo *psd_info,\n  const MagickBooleanType skip_layers,ExceptionInfo *exception)\n{\n  char\n    type[4];\n  LayerInfo\n    *layer_info;\n  MagickSizeType\n    size;\n  MagickBooleanType\n    status;\n  register ssize_t\n    i;\n  ssize_t\n    count,\n    j,\n    number_layers;\n  size=GetPSDSize(psd_info,image);\n  if (size == 0)\n    {\n      (void) ReadBlobLong(image);\n      count=ReadBlob(image,4,(unsigned char *) type);\n      ReversePSDString(image,type,4);\n      status=MagickFalse;\n      if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n        return(MagickTrue);\n      else\n        {\n          count=ReadBlob(image,4,(unsigned char *) type);\n          ReversePSDString(image,type,4);\n          if ((count != 0) && (LocaleNCompare(type,\"Lr16\",4) == 0))\n            size=GetPSDSize(psd_info,image);\n          else\n            return(MagickTrue);\n        }\n    }\n  status=MagickTrue;\n  if (size != 0)\n    {\n      layer_info=(LayerInfo *) NULL;\n      number_layers=(short) ReadBlobShort(image);\n      if (number_layers < 0)\n        {\n          number_layers=MagickAbsoluteValue(number_layers);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  negative layer count corrected for\");\n          image->matte=MagickTrue;\n        }\n      if (skip_layers != MagickFalse)\n        return(MagickTrue);\n      if (image->debug != MagickFalse)\n        (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n          \"  image contains %.20g layers\",(double) number_layers);\n      if (number_layers == 0)\n        ThrowBinaryException(CorruptImageError,\"InvalidNumberOfLayers\",\n          image->filename);\n      layer_info=(LayerInfo *) AcquireQuantumMemory((size_t) number_layers,\n        sizeof(*layer_info));\n      if (layer_info == (LayerInfo *) NULL)\n        {\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"  allocation of LayerInfo failed\");\n          ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n            image->filename);\n        }\n      (void) ResetMagickMemory(layer_info,0,(size_t) number_layers*\n        sizeof(*layer_info));\n      for (i=0; i < number_layers; i++)\n      {\n        ssize_t\n          x,\n          y;\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"  reading layer #%.20g\",(double) i+1);\n        layer_info[i].page.y=(int) ReadBlobLong(image);\n        layer_info[i].page.x=(int) ReadBlobLong(image);\n        y=(int) ReadBlobLong(image);\n        x=(int) ReadBlobLong(image);\n        layer_info[i].page.width=(size_t) (x-layer_info[i].page.x);\n        layer_info[i].page.height=(size_t) (y-layer_info[i].page.y);\n        layer_info[i].channels=ReadBlobShort(image);\n        if (layer_info[i].channels > MaxPSDChannels)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"MaximumChannelsExceeded\",\n              image->filename);\n          }\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"    offset(%.20g,%.20g), size(%.20g,%.20g), channels=%.20g\",\n            (double) layer_info[i].page.x,(double) layer_info[i].page.y,\n            (double) layer_info[i].page.height,(double)\n            layer_info[i].page.width,(double) layer_info[i].channels);\n        for (j=0; j < (ssize_t) layer_info[i].channels; j++)\n        {\n          layer_info[i].channel_info[j].type=(short) ReadBlobShort(image);\n          layer_info[i].channel_info[j].size=(size_t) GetPSDSize(psd_info,\n            image);\n          if (image->debug != MagickFalse)\n            (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n              \"    channel[%.20g]: type=%.20g, size=%.20g\",(double) j,\n              (double) layer_info[i].channel_info[j].type,\n              (double) layer_info[i].channel_info[j].size);\n        }\n        count=ReadBlob(image,4,(unsigned char *) type);\n        ReversePSDString(image,type,4);\n        if ((count == 0) || (LocaleNCompare(type,\"8BIM\",4) != 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  layer type was %.4s instead of 8BIM\", type);\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            ThrowBinaryException(CorruptImageError,\"ImproperImageHeader\",\n              image->filename);\n          }\n        (void) ReadBlob(image,4,(unsigned char *) layer_info[i].blendkey);\n        ReversePSDString(image,layer_info[i].blendkey,4);\n        layer_info[i].opacity=(Quantum) (QuantumRange-ScaleCharToQuantum(\n          (unsigned char) ReadBlobByte(image)));\n        layer_info[i].clipping=(unsigned char) ReadBlobByte(image);\n        layer_info[i].flags=(unsigned char) ReadBlobByte(image);\n        layer_info[i].visible=!(layer_info[i].flags & 0x02);\n        if (image->debug != MagickFalse)\n          (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n            \"   blend=%.4s, opacity=%.20g, clipping=%s, flags=%d, visible=%s\",\n            layer_info[i].blendkey,(double) layer_info[i].opacity,\n            layer_info[i].clipping ? \"true\" : \"false\",layer_info[i].flags,\n            layer_info[i].visible ? \"true\" : \"false\");\n        (void) ReadBlobByte(image);  \n        size=ReadBlobLong(image);\n        if (size != 0)\n          {\n            MagickSizeType\n              combined_length,\n              length;\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"    layer contains additional info\");\n            length=ReadBlobLong(image);\n            combined_length=length+4;\n            if (length != 0)\n              {\n                layer_info[i].mask.page.y=(int) ReadBlobLong(image);\n                layer_info[i].mask.page.x=(int) ReadBlobLong(image);\n                layer_info[i].mask.page.height=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.y);\n                layer_info[i].mask.page.width=(size_t) (ReadBlobLong(image)-\n                  layer_info[i].mask.page.x);\n                layer_info[i].mask.background=(unsigned char) ReadBlobByte(\n                  image);\n                layer_info[i].mask.flags=(unsigned char) ReadBlobByte(image);\n                if (!(layer_info[i].mask.flags & 0x01))\n                  {\n                    layer_info[i].mask.page.y=layer_info[i].mask.page.y-\n                      layer_info[i].page.y;\n                    layer_info[i].mask.page.x=layer_info[i].mask.page.x-\n                      layer_info[i].page.x;\n                  }\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer mask: offset(%.20g,%.20g), size(%.20g,%.20g), length=%.20g\",\n                    (double) layer_info[i].mask.page.x,(double)\n                    layer_info[i].mask.page.y,(double) layer_info[i].mask.page.width,\n                    (double) layer_info[i].mask.page.height,(double)\n                    ((MagickOffsetType) length)-18);\n                if (DiscardBlobBytes(image,(MagickSizeType) (length-18)) == MagickFalse)\n                  {\n                    layer_info=DestroyLayerInfo(layer_info,number_layers);\n                    ThrowBinaryException(CorruptImageError,\"UnexpectedEndOfFile\",\n                      image->filename);\n                  }\n              }\n            length=ReadBlobLong(image);\n            combined_length+=length+4;\n            if (length != 0)\n              {\n                if (image->debug != MagickFalse)\n                  (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                    \"      layer blending ranges: length=%.20g\",(double)\n                    ((MagickOffsetType) length));\n                for (j=0; j < (ssize_t) (length); j+=8)\n                {\n                  size_t blend_source=ReadBlobLong(image);\n                  size_t blend_dest=ReadBlobLong(image);\n                  if (image->debug != MagickFalse)\n                    (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                      \"        source(%x), dest(%x)\",(unsigned int)\n                      blend_source,(unsigned int) blend_dest);\n                }\n              }\n            length=(size_t) ReadBlobByte(image);\n            combined_length+=length+1;\n            if (length > 0)\n              (void) ReadBlob(image,(size_t) length++,layer_info[i].name);\n            layer_info[i].name[length]='\\0';\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer name: %s\",layer_info[i].name);\n             if (image->debug != MagickFalse)\n               (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                 \"      unsupported data: length=%.20g\",(double)\n                 ((MagickOffsetType) (size-combined_length)));\n             if (DiscardBlobBytes(image,(MagickSizeType) (size-combined_length)) == MagickFalse)\n               {\n                 layer_info=DestroyLayerInfo(layer_info,number_layers);\n                 ThrowBinaryException(CorruptImageError,\n                   \"UnexpectedEndOfFile\",image->filename);\n               }\n          }\n      }\n      for (i=0; i < number_layers; i++)\n      {\n        if ((layer_info[i].page.width == 0) ||\n              (layer_info[i].page.height == 0))\n          {\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"      layer data is empty\");\n            continue;\n          }\n        layer_info[i].image=CloneImage(image,layer_info[i].page.width,\n          layer_info[i].page.height,MagickFalse,exception);\n        if (layer_info[i].image == (Image *) NULL)\n          {\n            layer_info=DestroyLayerInfo(layer_info,number_layers);\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  allocation of image for layer %.20g failed\",(double) i);\n            ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n              image->filename);\n          }\n      }\n      if (image_info->ping == MagickFalse)\n        {\n          for (i=0; i < number_layers; i++)\n          {\n            if (layer_info[i].image == (Image *) NULL)\n              {\n                for (j=0; j < layer_info[i].channels; j++)\n                {\n                  if (DiscardBlobBytes(image,(MagickSizeType)\n                      layer_info[i].channel_info[j].size) == MagickFalse)\n                    {\n                      layer_info=DestroyLayerInfo(layer_info,number_layers);\n                      ThrowBinaryException(CorruptImageError,\n                        \"UnexpectedEndOfFile\",image->filename);\n                    }\n                }\n                continue;\n              }\n            if (image->debug != MagickFalse)\n              (void) LogMagickEvent(CoderEvent,GetMagickModule(),\n                \"  reading data for layer %.20g\",(double) i);\n            status=ReadPSDLayer(image,psd_info,&layer_info[i],exception);\n            if (status == MagickFalse)\n              break;\n            status=SetImageProgress(image,LoadImagesTag,i,(MagickSizeType)\n              number_layers);\n            if (status == MagickFalse)\n              break;\n          }\n        }\n      if (status != MagickFalse)\n      {\n        for (i=0; i < number_layers; i++)\n        {\n          if (layer_info[i].image == (Image *) NULL)\n          {\n            for (j=i; j < number_layers - 1; j++)\n              layer_info[j] = layer_info[j+1];\n            number_layers--;\n            i--;\n          }\n        }\n        if (number_layers > 0)\n          {\n            for (i=0; i < number_layers; i++)\n            {\n              if (i > 0)\n                layer_info[i].image->previous=layer_info[i-1].image;\n              if (i < (number_layers-1))\n                layer_info[i].image->next=layer_info[i+1].image;\n              layer_info[i].image->page=layer_info[i].page;\n            }\n            image->next=layer_info[0].image;\n            layer_info[0].image->previous=image;\n          }\n        layer_info=(LayerInfo *) RelinquishMagickMemory(layer_info);\n      }\n      else\n        layer_info=DestroyLayerInfo(layer_info,number_layers);\n    }\n  return(status);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":73530
  },
  {
    "code":"void BrowserCommandController::UpdateCommandsForTabState() {\n  if (is_locked_fullscreen_)\n    return;\n  WebContents* current_web_contents =\n      browser_->tab_strip_model()->GetActiveWebContents();\n  if (!current_web_contents)  \n    return;\n  command_updater_.UpdateCommandEnabled(IDC_BACK, CanGoBack(browser_));\n  command_updater_.UpdateCommandEnabled(IDC_FORWARD, CanGoForward(browser_));\n  command_updater_.UpdateCommandEnabled(IDC_RELOAD, CanReload(browser_));\n  command_updater_.UpdateCommandEnabled(IDC_RELOAD_BYPASSING_CACHE,\n                                        CanReload(browser_));\n  command_updater_.UpdateCommandEnabled(IDC_RELOAD_CLEARING_CACHE,\n                                        CanReload(browser_));\n  command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB,\n      !browser_->is_app() && CanDuplicateTab(browser_));\n  command_updater_.UpdateCommandEnabled(IDC_WINDOW_MUTE_SITE,\n                                        !browser_->is_app());\n  command_updater_.UpdateCommandEnabled(IDC_WINDOW_PIN_TAB,\n                                        !browser_->is_app());\n  window()->SetStarredState(\n      BookmarkTabHelper::FromWebContents(current_web_contents)->is_starred());\n  window()->ZoomChangedForActiveTab(false);\n  command_updater_.UpdateCommandEnabled(IDC_VIEW_SOURCE,\n                                        CanViewSource(browser_));\n  command_updater_.UpdateCommandEnabled(IDC_EMAIL_PAGE_LOCATION,\n                                        CanEmailPageLocation(browser_));\n  if (browser_->is_devtools())\n    command_updater_.UpdateCommandEnabled(IDC_OPEN_FILE, false);\n  bool can_create_bookmark_app = CanCreateBookmarkApp(browser_);\n  command_updater_.UpdateCommandEnabled(IDC_INSTALL_PWA,\n                                        can_create_bookmark_app);\n  command_updater_.UpdateCommandEnabled(IDC_CREATE_SHORTCUT,\n                                        can_create_bookmark_app);\n  command_updater_.UpdateCommandEnabled(IDC_OPEN_IN_PWA_WINDOW,\n                                        can_create_bookmark_app);\n  command_updater_.UpdateCommandEnabled(\n      IDC_TOGGLE_REQUEST_TABLET_SITE,\n      CanRequestTabletSite(current_web_contents));\n  UpdateCommandsForContentRestrictionState();\n  UpdateCommandsForBookmarkEditing();\n  UpdateCommandsForFind();\n  UpdateCommandsForMediaRouter();\n  UpdateCommandsForZoomState();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":166570
  },
  {
    "code":"PassRefPtrWillBeRawPtr<Node> ContainerNode::replaceChild(PassRefPtrWillBeRawPtr<Node> newChild, PassRefPtrWillBeRawPtr<Node> oldChild, ExceptionState& exceptionState)\n{\n#if !ENABLE(OILPAN)\n    ASSERT(refCount() || parentOrShadowHostNode());\n#endif\n    RefPtrWillBeRawPtr<Node> protect(this);\n    if (oldChild == newChild) \n        return oldChild;\n    if (!oldChild) {\n        exceptionState.throwDOMException(NotFoundError, \"The node to be replaced is null.\");\n        return nullptr;\n    }\n    RefPtrWillBeRawPtr<Node> child = oldChild;\n    if (!checkAcceptChild(newChild.get(), child.get(), exceptionState)) {\n        if (exceptionState.hadException())\n            return nullptr;\n        return child;\n    }\n    if (child->parentNode() != this) {\n        exceptionState.throwDOMException(NotFoundError, \"The node to be replaced is not a child of this node.\");\n        return nullptr;\n    }\n    ChildListMutationScope mutation(*this);\n    RefPtrWillBeRawPtr<Node> next = child->nextSibling();\n    removeChild(child, exceptionState);\n    if (exceptionState.hadException())\n        return nullptr;\n    if (next && (next->previousSibling() == newChild || next == newChild)) \n        return child;\n    if (!checkAcceptChild(newChild.get(), child.get(), exceptionState)) {\n        if (exceptionState.hadException())\n            return nullptr;\n        return child;\n    }\n    NodeVector targets;\n    collectChildrenAndRemoveFromOldParent(*newChild, targets, exceptionState);\n    if (exceptionState.hadException())\n        return nullptr;\n    if (!checkAcceptChild(newChild.get(), child.get(), exceptionState)) {\n        if (exceptionState.hadException())\n            return nullptr;\n        return child;\n    }\n    InspectorInstrumentation::willInsertDOMNode(this);\n    for (const auto& targetNode : targets) {\n        ASSERT(targetNode);\n        Node& child = *targetNode;\n        if (next && next->parentNode() != this)\n            break;\n        if (child.parentNode())\n            break;\n        treeScope().adoptIfNeeded(child);\n        {\n            EventDispatchForbiddenScope assertNoEventDispatch;\n            if (next)\n                insertBeforeCommon(*next, child);\n            else\n                appendChildCommon(child);\n        }\n        updateTreeAfterInsertion(child);\n    }\n    dispatchSubtreeModifiedEvent();\n    return child;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":135969
  },
  {
    "code":"static void posix_acl_fix_xattr_userns(\n  struct user_namespace *to, struct user_namespace *from,\n  void *value, size_t size)\n{\n  posix_acl_xattr_header *header = (posix_acl_xattr_header *)value;\n  posix_acl_xattr_entry *entry = (posix_acl_xattr_entry *)(header+1), *end;\n  int count;\n  kuid_t uid;\n  kgid_t gid;\n  if (!value)\n    return;\n  if (size < sizeof(posix_acl_xattr_header))\n    return;\n  if (header->a_version != cpu_to_le32(POSIX_ACL_XATTR_VERSION))\n    return;\n  count = posix_acl_xattr_count(size);\n  if (count < 0)\n    return;\n  if (count == 0)\n    return;\n  for (end = entry + count; entry != end; entry++) {\n    switch(le16_to_cpu(entry->e_tag)) {\n    case ACL_USER:\n      uid = make_kuid(from, le32_to_cpu(entry->e_id));\n      entry->e_id = cpu_to_le32(from_kuid(to, uid));\n      break;\n    case ACL_GROUP:\n      gid = make_kgid(from, le32_to_cpu(entry->e_id));\n      entry->e_id = cpu_to_le32(from_kgid(to, gid));\n      break;\n    default:\n      break;\n    }\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":50384
  },
  {
    "code":"ofputil_decode_table_eviction(ovs_be32 config, enum ofp_version version)\n{\n    return (version < OFP14_VERSION ? OFPUTIL_TABLE_EVICTION_DEFAULT\n            : config & htonl(OFPTC14_EVICTION) ? OFPUTIL_TABLE_EVICTION_ON\n            : OFPUTIL_TABLE_EVICTION_OFF);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":77544
  },
  {
    "code":"void WebContentsImpl::ShowCreatedFullscreenWidget(int route_id) {\n  ShowCreatedWidget(route_id, true, gfx::Rect());\n  DCHECK_EQ(MSG_ROUTING_NONE, fullscreen_widget_routing_id_);\n  fullscreen_widget_routing_id_ = route_id;\n  FOR_EACH_OBSERVER(WebContentsObserver,\n                    observers_,\n                    DidShowFullscreenWidget(route_id));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":119856
  },
  {
    "code":"mrb_bob_init(mrb_state *mrb, mrb_value cv)\n{\n  return mrb_nil_value();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":82063
  },
  {
    "code":"    PrintHostMsg_RequestPrintPreview_Params()\n    : is_modifiable(false),\n      webnode_only(false),\n      has_selection(false),\n      selection_only(false) {\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":162603
  },
  {
    "code":"static int em_cmpxchg(struct x86_emulate_ctxt *ctxt)\n{\n  ctxt->dst.orig_val = ctxt->dst.val;\n  ctxt->dst.val = reg_read(ctxt, VCPU_REGS_RAX);\n  ctxt->src.orig_val = ctxt->src.val;\n  ctxt->src.val = ctxt->dst.orig_val;\n  fastop(ctxt, em_cmp);\n  if (ctxt->eflags & EFLG_ZF) {\n    ctxt->dst.val = ctxt->src.orig_val;\n  } else {\n    ctxt->dst.type = OP_REG;\n    ctxt->dst.addr.reg = reg_rmw(ctxt, VCPU_REGS_RAX);\n    ctxt->dst.val = ctxt->dst.orig_val;\n  }\n  return X86EMUL_CONTINUE;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":35520
  },
  {
    "code":"void WebPluginDelegateProxy::OnMessageReceived(const IPC::Message& msg) {\n  child_process_logging::SetActiveURL(page_url_);\n  IPC_BEGIN_MESSAGE_MAP(WebPluginDelegateProxy, msg)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_SetWindow, OnSetWindow)\n#if defined(OS_WIN)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_SetWindowlessPumpEvent,\n                        OnSetWindowlessPumpEvent)\n#endif\n    IPC_MESSAGE_HANDLER(PluginHostMsg_CancelResource, OnCancelResource)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_InvalidateRect, OnInvalidateRect)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_GetWindowScriptNPObject,\n                        OnGetWindowScriptNPObject)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_GetPluginElement,\n                        OnGetPluginElement)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_SetCookie, OnSetCookie)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_GetCookies, OnGetCookies)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_ShowModalHTMLDialog,\n                        OnShowModalHTMLDialog)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_GetDragData, OnGetDragData);\n    IPC_MESSAGE_HANDLER(PluginHostMsg_SetDropEffect, OnSetDropEffect);\n    IPC_MESSAGE_HANDLER(PluginHostMsg_MissingPluginStatus,\n                        OnMissingPluginStatus)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_URLRequest, OnHandleURLRequest)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_GetCPBrowsingContext,\n                        OnGetCPBrowsingContext)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_CancelDocumentLoad, OnCancelDocumentLoad)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_InitiateHTTPRangeRequest,\n                        OnInitiateHTTPRangeRequest)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_DeferResourceLoading,\n                        OnDeferResourceLoading)\n#if defined(OS_MACOSX)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_BindFakePluginWindowHandle,\n                        OnBindFakePluginWindowHandle);\n    IPC_MESSAGE_HANDLER(PluginHostMsg_UpdateGeometry_ACK,\n                        OnUpdateGeometry_ACK)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_AcceleratedSurfaceSetIOSurface,\n                        OnAcceleratedSurfaceSetIOSurface)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_AcceleratedSurfaceSetTransportDIB,\n                        OnAcceleratedSurfaceSetTransportDIB)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_AllocTransportDIB,\n                        OnAcceleratedSurfaceAllocTransportDIB)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_FreeTransportDIB,\n                        OnAcceleratedSurfaceFreeTransportDIB)\n    IPC_MESSAGE_HANDLER(PluginHostMsg_AcceleratedSurfaceBuffersSwapped,\n                        OnAcceleratedSurfaceBuffersSwapped)\n#endif\n    IPC_MESSAGE_UNHANDLED_ERROR()\n  IPC_END_MESSAGE_MAP()\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":98799
  },
  {
    "code":"static int __init chr_dev_init(void)\n{\n  int minor;\n  if (register_chrdev(MEM_MAJOR, \"mem\", &memory_fops))\n    printk(\"unable to get major %d for memory devs\\n\", MEM_MAJOR);\n  mem_class = class_create(THIS_MODULE, \"mem\");\n  if (IS_ERR(mem_class))\n    return PTR_ERR(mem_class);\n  mem_class->devnode = mem_devnode;\n  for (minor = 1; minor < ARRAY_SIZE(devlist); minor++) {\n    if (!devlist[minor].name)\n      continue;\n    if ((minor == DEVPORT_MINOR) && !arch_has_dev_port())\n      continue;\n    device_create(mem_class, NULL, MKDEV(MEM_MAJOR, minor),\n            NULL, devlist[minor].name);\n  }\n  return tty_init();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":66872
  },
  {
    "code":"static void nfc_llcp_recv_ui(struct nfc_llcp_local *local,\n           struct sk_buff *skb)\n{\n  struct nfc_llcp_sock *llcp_sock;\n  struct nfc_llcp_ui_cb *ui_cb;\n  u8 dsap, ssap;\n  dsap = nfc_llcp_dsap(skb);\n  ssap = nfc_llcp_ssap(skb);\n  ui_cb = nfc_llcp_ui_skb_cb(skb);\n  ui_cb->dsap = dsap;\n  ui_cb->ssap = ssap;\n  pr_debug(\"%d %d\\n\", dsap, ssap);\n  llcp_sock = nfc_llcp_sock_get(local, dsap, LLCP_SAP_SDP);\n  if (llcp_sock == NULL || llcp_sock->sk.sk_type != SOCK_DGRAM)\n    return;\n  skb_pull(skb, LLCP_HEADER_SIZE);\n  if (!sock_queue_rcv_skb(&llcp_sock->sk, skb)) {\n    skb_get(skb);\n  } else {\n    pr_err(\"Receive queue is full\\n\");\n  }\n  nfc_llcp_sock_put(llcp_sock);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":89713
  },
  {
    "code":"static int checkGamma(i_ctx_t * i_ctx_p, ref *CIEdict, int numvalues)\n{\n    int code = 0, i;\n    float value[3];\n    ref *tempref, valref;\n    code = dict_find_string(CIEdict, \"Gamma\", &tempref);\n    if (code > 0 && !r_has_type(tempref, t_null)) {\n        if (numvalues > 1) {\n            if (!r_is_array(tempref))\n                return_error(gs_error_typecheck);\n            if (r_size(tempref) != numvalues)\n                return_error(gs_error_rangecheck);\n            for (i=0;i<numvalues;i++) {\n                code = array_get(imemory, tempref, i, &valref);\n                if (code < 0)\n                    return code;\n                if (r_has_type(&valref, t_integer))\n                    value[i] = (float)valref.value.intval;\n                else if (r_has_type(&valref, t_real))\n                    value[i] = (float)valref.value.realval;\n                else\n                    return_error(gs_error_typecheck);\n                if (value[i] <= 0) return_error(gs_error_rangecheck);\n            }\n        } else {\n            if (r_has_type(tempref, t_real))\n                value[0] = (float)(tempref->value.realval);\n            else if (r_has_type(tempref, t_integer))\n                    value[0] = (float)(tempref->value.intval);\n            else\n                return_error(gs_error_typecheck);\n            if (value[0] <= 0) return_error(gs_error_rangecheck);\n        }\n    }\n    return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":3032
  },
  {
    "code":"WebContext::BrowserContextDelegate::BrowserContextDelegate(\n    const base::WeakPtr<WebContext> context)\n    : context_getter_(new WebContextGetter(context)) {}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":16950
  },
  {
    "code":"void HWNDMessageHandler::FlashFrame(bool flash) {\n  FLASHWINFO fwi;\n  fwi.cbSize = sizeof(fwi);\n  fwi.hwnd = hwnd();\n  if (flash) {\n    fwi.dwFlags = FLASHW_ALL;\n    fwi.uCount = 4;\n    fwi.dwTimeout = 0;\n  } else {\n    fwi.dwFlags = FLASHW_STOP;\n  }\n  FlashWindowEx(&fwi);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":133079
  },
  {
    "code":"void NuPlayer::NuPlayerStreamListener::issueCommand(\n Command cmd, bool synchronous, const sp<AMessage> &extra) {\n    CHECK(!synchronous);\n QueueEntry entry;\n    entry.mIsCommand = true;\n    entry.mCommand = cmd;\n    entry.mExtra = extra;\n Mutex::Autolock autoLock(mLock);\n    mQueue.push_back(entry);\n if (mSendDataNotification) {\n        mSendDataNotification = false;\n if (mTargetHandler != NULL) {\n (new AMessage(kWhatMoreDataQueued, mTargetHandler))->post();\n }\n }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":174300
  },
  {
    "code":"bool Extension::ProducePEM(const std::string& input, std::string* output) {\n  DCHECK(output);\n  return (input.length() == 0) ? false : base::Base64Encode(input, output);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":122710
  },
  {
    "code":"WebRTCSessionDescriptionDescriptor MockWebRTCPeerConnectionHandler::localDescription()\n{\n    return m_localDescription;\n}\n",
    "vul":1,
    "flaw_line_no":[
      2,
      3,
      4
    ],
    "bigvul_id":183817
  },
  {
    "code":"newShapeRecord(SWFShape shape, shapeRecordType type)\n{\n  if ( shape->nRecords % SHAPERECORD_INCREMENT == 0 )\n  {\n    shape->records = (ShapeRecord*) realloc(shape->records,\n           sizeof(ShapeRecord) *\n           (shape->nRecords + SHAPERECORD_INCREMENT));\n  }\n  switch ( type )\n  {\n    case SHAPERECORD_STATECHANGE:\n    {\n      StateChangeRecord change = (StateChangeRecord)calloc(1,sizeof(struct stateChangeRecord));\n      shape->records[shape->nRecords].record.stateChange = change;\n      break;\n    }\n    case SHAPERECORD_LINETO:\n    {\n      LineToRecord lineTo = (LineToRecord) calloc(1,sizeof(struct lineToRecord));\n      shape->records[shape->nRecords].record.lineTo = lineTo;\n      break;\n    }\n    case SHAPERECORD_CURVETO:\n    {\n      CurveToRecord curveTo = (CurveToRecord) calloc(1,sizeof(struct curveToRecord));\n      shape->records[shape->nRecords].record.curveTo = curveTo;\n      break;\n    }\n  }\n  shape->records[shape->nRecords].type = type;\n  shape->nRecords++;\n  return shape->records[shape->nRecords-1];\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":89539
  },
  {
    "code":"svcauth_gss_destroy(SVCAUTH *auth)\n{\n  struct svc_rpc_gss_data  *gd;\n  OM_uint32     min_stat;\n  log_debug(\"in svcauth_gss_destroy()\");\n  gd = SVCAUTH_PRIVATE(auth);\n  gss_delete_sec_context(&min_stat, &gd->ctx, GSS_C_NO_BUFFER);\n  gss_release_buffer(&min_stat, &gd->cname);\n  gss_release_buffer(&min_stat, &gd->checksum);\n  if (gd->client_name)\n    gss_release_name(&min_stat, &gd->client_name);\n  mem_free(gd, sizeof(*gd));\n  mem_free(auth, sizeof(*auth));\n  return (TRUE);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":46026
  },
  {
    "code":"build_qfs_info_req(struct kvec *iov, struct cifs_tcon *tcon, int level,\n       int outbuf_len, u64 persistent_fid, u64 volatile_fid)\n{\n  int rc;\n  struct smb2_query_info_req *req;\n  unsigned int total_len;\n  cifs_dbg(FYI, \"Query FSInfo level %d\\n\", level);\n  if ((tcon->ses == NULL) || (tcon->ses->server == NULL))\n    return -EIO;\n  rc = smb2_plain_req_init(SMB2_QUERY_INFO, tcon, (void **) &req,\n           &total_len);\n  if (rc)\n    return rc;\n  req->InfoType = SMB2_O_INFO_FILESYSTEM;\n  req->FileInfoClass = level;\n  req->PersistentFileId = persistent_fid;\n  req->VolatileFileId = volatile_fid;\n  req->InputBufferOffset =\n      cpu_to_le16(sizeof(struct smb2_query_info_req) - 1);\n  req->OutputBufferLength = cpu_to_le32(\n    outbuf_len + sizeof(struct smb2_query_info_rsp) - 1);\n  iov->iov_base = (char *)req;\n  iov->iov_len = total_len;\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":88117
  },
  {
    "code":"void HTMLSelectElement::menuListDefaultEventHandler(Event* event)\n{\n    RenderTheme& renderTheme = RenderTheme::theme();\n    if (event->type() == EventTypeNames::keydown) {\n        if (!renderer() || !event->isKeyboardEvent())\n            return;\n        if (platformHandleKeydownEvent(toKeyboardEvent(event)))\n            return;\n        if (isSpatialNavigationEnabled(document().frame())) {\n            if (!m_activeSelectionState)\n                return;\n        }\n        const String& keyIdentifier = toKeyboardEvent(event)->keyIdentifier();\n        bool handled = true;\n        const Vector<HTMLElement*>& listItems = this->listItems();\n        int listIndex = optionToListIndex(selectedIndex());\n        if (keyIdentifier == \"Down\" || keyIdentifier == \"Right\")\n            listIndex = nextValidIndex(listIndex, SkipForwards, 1);\n        else if (keyIdentifier == \"Up\" || keyIdentifier == \"Left\")\n            listIndex = nextValidIndex(listIndex, SkipBackwards, 1);\n        else if (keyIdentifier == \"PageDown\")\n            listIndex = nextValidIndex(listIndex, SkipForwards, 3);\n        else if (keyIdentifier == \"PageUp\")\n            listIndex = nextValidIndex(listIndex, SkipBackwards, 3);\n        else if (keyIdentifier == \"Home\")\n            listIndex = nextValidIndex(-1, SkipForwards, 1);\n        else if (keyIdentifier == \"End\")\n            listIndex = nextValidIndex(listItems.size(), SkipBackwards, 1);\n        else\n            handled = false;\n        if (handled && static_cast<size_t>(listIndex) < listItems.size())\n            selectOption(listToOptionIndex(listIndex), DeselectOtherOptions | DispatchChangeEvent | UserDriven);\n        if (handled)\n            event->setDefaultHandled();\n    }\n    if (event->type() == EventTypeNames::keypress) {\n        if (!renderer() || !event->isKeyboardEvent())\n            return;\n        int keyCode = toKeyboardEvent(event)->keyCode();\n        bool handled = false;\n        if (keyCode == ' ' && isSpatialNavigationEnabled(document().frame())) {\n            m_activeSelectionState = !m_activeSelectionState;\n            event->setDefaultHandled();\n            return;\n        }\n        if (renderTheme.popsMenuBySpaceOrReturn()) {\n            if (keyCode == ' ' || keyCode == '\\r') {\n                focus();\n                if (!renderer() || !renderer()->isMenuList())\n                    return;\n                saveLastSelection();\n                if (RenderMenuList* menuList = toRenderMenuList(renderer()))\n                    menuList->showPopup();\n                handled = true;\n            }\n        } else if (renderTheme.popsMenuByArrowKeys()) {\n            if (keyCode == ' ') {\n                focus();\n                if (!renderer() || !renderer()->isMenuList())\n                    return;\n                saveLastSelection();\n                if (RenderMenuList* menuList = toRenderMenuList(renderer()))\n                    menuList->showPopup();\n                handled = true;\n            } else if (keyCode == '\\r') {\n                if (form())\n                    form()->submitImplicitly(event, false);\n                dispatchChangeEventForMenuList();\n                handled = true;\n            }\n        }\n        if (handled)\n            event->setDefaultHandled();\n    }\n    if (event->type() == EventTypeNames::mousedown && event->isMouseEvent() && toMouseEvent(event)->button() == LeftButton) {\n        focus();\n        if (renderer() && renderer()->isMenuList()) {\n            if (RenderMenuList* menuList = toRenderMenuList(renderer())) {\n                if (menuList->popupIsVisible())\n                    menuList->hidePopup();\n                else {\n                    saveLastSelection();\n                    menuList->showPopup();\n                }\n            }\n        }\n        event->setDefaultHandled();\n    }\n    if (event->type() == EventTypeNames::blur) {\n        if (RenderMenuList* menuList = toRenderMenuList(renderer())) {\n            if (menuList->popupIsVisible())\n                menuList->hidePopup();\n        }\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":122402
  },
  {
    "code":"void RecordCacheFlags(HistogramCacheFlag flag) {\n  UMA_HISTOGRAM_ENUMERATION(\"Navigation.BackForward.CacheFlags\", flag,\n                            HISTOGRAM_CACHE_FLAG_MAX);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":164957
  },
  {
    "code":"ofputil_append_meter_stats(struct ovs_list *replies,\n                           const struct ofputil_meter_stats *ms)\n{\n    struct ofp13_meter_stats *reply;\n    uint16_t n = 0;\n    uint16_t len;\n    len = sizeof *reply + ms->n_bands * sizeof(struct ofp13_meter_band_stats);\n    reply = ofpmp_append(replies, len);\n    reply->meter_id = htonl(ms->meter_id);\n    reply->len = htons(len);\n    memset(reply->pad, 0, sizeof reply->pad);\n    reply->flow_count = htonl(ms->flow_count);\n    reply->packet_in_count = htonll(ms->packet_in_count);\n    reply->byte_in_count = htonll(ms->byte_in_count);\n    reply->duration_sec = htonl(ms->duration_sec);\n    reply->duration_nsec = htonl(ms->duration_nsec);\n    for (n = 0; n < ms->n_bands; ++n) {\n        const struct ofputil_meter_band_stats *src = &ms->bands[n];\n        struct ofp13_meter_band_stats *dst = &reply->band_stats[n];\n        dst->packet_band_count = htonll(src->packet_count);\n        dst->byte_band_count = htonll(src->byte_count);\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":77466
  },
  {
    "code":"static void vmx_recover_nmi_blocking(struct vcpu_vmx *vmx)\n{\n  u32 exit_intr_info;\n  bool unblock_nmi;\n  u8 vector;\n  bool idtv_info_valid;\n  idtv_info_valid = vmx->idt_vectoring_info & VECTORING_INFO_VALID_MASK;\n  if (enable_vnmi) {\n    if (vmx->loaded_vmcs->nmi_known_unmasked)\n      return;\n    exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);\n    unblock_nmi = (exit_intr_info & INTR_INFO_UNBLOCK_NMI) != 0;\n    vector = exit_intr_info & INTR_INFO_VECTOR_MASK;\n    if ((exit_intr_info & INTR_INFO_VALID_MASK) && unblock_nmi &&\n        vector != DF_VECTOR && !idtv_info_valid)\n      vmcs_set_bits(GUEST_INTERRUPTIBILITY_INFO,\n              GUEST_INTR_STATE_NMI);\n    else\n      vmx->loaded_vmcs->nmi_known_unmasked =\n        !(vmcs_read32(GUEST_INTERRUPTIBILITY_INFO)\n          & GUEST_INTR_STATE_NMI);\n  } else if (unlikely(vmx->loaded_vmcs->soft_vnmi_blocked))\n    vmx->loaded_vmcs->vnmi_blocked_time +=\n      ktime_to_ns(ktime_sub(ktime_get(),\n                vmx->loaded_vmcs->entry_time));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":81056
  },
  {
    "code":"const views::ImageView* MediaControlsHeaderView::app_icon_for_testing() const {\n   return app_icon_view_;\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":149208
  },
  {
    "code":"void GLES2DecoderImpl::DoFramebufferTextureMultiviewLayeredANGLE(\n    GLenum target,\n    GLenum attachment,\n    GLuint client_texture_id,\n    GLint level,\n    GLint base_view_index,\n    GLsizei num_views) {\n  NOTREACHED();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":158683
  },
  {
    "code":"static void copy_vmcs12_to_shadow(struct vcpu_vmx *vmx)\n{\n  const u16 *fields[] = {\n    shadow_read_write_fields,\n    shadow_read_only_fields\n  };\n  const int max_fields[] = {\n    max_shadow_read_write_fields,\n    max_shadow_read_only_fields\n  };\n  int i, q;\n  unsigned long field;\n  u64 field_value = 0;\n  struct vmcs *shadow_vmcs = vmx->vmcs01.shadow_vmcs;\n  vmcs_load(shadow_vmcs);\n  for (q = 0; q < ARRAY_SIZE(fields); q++) {\n    for (i = 0; i < max_fields[q]; i++) {\n      field = fields[q][i];\n      vmcs12_read_any(&vmx->vcpu, field, &field_value);\n      __vmcs_writel(field, field_value);\n    }\n  }\n  vmcs_clear(shadow_vmcs);\n  vmcs_load(vmx->loaded_vmcs->vmcs);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":80917
  },
  {
    "code":"void ScreenRecorder::DoRemoveClient(\n    scoped_refptr<ConnectionToClient> connection) {\n  DCHECK(network_loop_->BelongsToCurrentThread());\n  ConnectionToClientList::iterator it =\n      std::find(connections_.begin(), connections_.end(), connection);\n  if (it != connections_.end()) {\n    connections_.erase(it);\n  }\n}\n",
    "vul":1,
    "flaw_line_no":[
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9
    ],
    "bigvul_id":184651
  },
  {
    "code":"static void cryp_polling_mode(struct cryp_ctx *ctx,\n            struct cryp_device_data *device_data)\n{\n  int len = ctx->blocksize \/ BYTES_PER_WORD;\n  int remaining_length = ctx->datalen;\n  u32 *indata = (u32 *)ctx->indata;\n  u32 *outdata = (u32 *)ctx->outdata;\n  while (remaining_length > 0) {\n    writesl(&device_data->base->din, indata, len);\n    indata += len;\n    remaining_length -= (len * BYTES_PER_WORD);\n    cryp_wait_until_done(device_data);\n    readsl(&device_data->base->dout, outdata, len);\n    outdata += len;\n    cryp_wait_until_done(device_data);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":47499
  },
  {
    "code":"SPL_METHOD(SplDoublyLinkedList, isEmpty)\n{\n  zend_long count;\n  if (zend_parse_parameters_none() == FAILURE) {\n    return;\n  }\n  spl_dllist_object_count_elements(getThis(), &count);\n  RETURN_BOOL(count == 0);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":54284
  },
  {
    "code":"xfs_file_fallocate(\n  struct file    *file,\n  int      mode,\n  loff_t      offset,\n  loff_t      len)\n{\n  struct inode    *inode = file_inode(file);\n  struct xfs_inode  *ip = XFS_I(inode);\n  struct xfs_trans  *tp;\n  long      error;\n  loff_t      new_size = 0;\n  if (!S_ISREG(inode->i_mode))\n    return -EINVAL;\n  if (mode & ~(FALLOC_FL_KEEP_SIZE | FALLOC_FL_PUNCH_HOLE |\n         FALLOC_FL_COLLAPSE_RANGE | FALLOC_FL_ZERO_RANGE))\n    return -EOPNOTSUPP;\n  xfs_ilock(ip, XFS_IOLOCK_EXCL);\n  if (mode & FALLOC_FL_PUNCH_HOLE) {\n    error = xfs_free_file_space(ip, offset, len);\n    if (error)\n      goto out_unlock;\n  } else if (mode & FALLOC_FL_COLLAPSE_RANGE) {\n    unsigned blksize_mask = (1 << inode->i_blkbits) - 1;\n    if (offset & blksize_mask || len & blksize_mask) {\n      error = -EINVAL;\n      goto out_unlock;\n    }\n    if (offset + len >= i_size_read(inode)) {\n      error = -EINVAL;\n      goto out_unlock;\n    }\n    new_size = i_size_read(inode) - len;\n    error = xfs_collapse_file_space(ip, offset, len);\n    if (error)\n      goto out_unlock;\n  } else {\n    if (!(mode & FALLOC_FL_KEEP_SIZE) &&\n        offset + len > i_size_read(inode)) {\n      new_size = offset + len;\n      error = -inode_newsize_ok(inode, new_size);\n      if (error)\n        goto out_unlock;\n    }\n    if (mode & FALLOC_FL_ZERO_RANGE)\n      error = xfs_zero_file_space(ip, offset, len);\n    else\n      error = xfs_alloc_file_space(ip, offset, len,\n                 XFS_BMAPI_PREALLOC);\n    if (error)\n      goto out_unlock;\n  }\n  tp = xfs_trans_alloc(ip->i_mount, XFS_TRANS_WRITEID);\n  error = xfs_trans_reserve(tp, &M_RES(ip->i_mount)->tr_writeid, 0, 0);\n  if (error) {\n    xfs_trans_cancel(tp, 0);\n    goto out_unlock;\n  }\n  xfs_ilock(ip, XFS_ILOCK_EXCL);\n  xfs_trans_ijoin(tp, ip, XFS_ILOCK_EXCL);\n  ip->i_d.di_mode &= ~S_ISUID;\n  if (ip->i_d.di_mode & S_IXGRP)\n    ip->i_d.di_mode &= ~S_ISGID;\n  if (!(mode & (FALLOC_FL_PUNCH_HOLE | FALLOC_FL_COLLAPSE_RANGE)))\n    ip->i_d.di_flags |= XFS_DIFLAG_PREALLOC;\n  xfs_trans_ichgtime(tp, ip, XFS_ICHGTIME_MOD | XFS_ICHGTIME_CHG);\n  xfs_trans_log_inode(tp, ip, XFS_ILOG_CORE);\n  if (file->f_flags & O_DSYNC)\n    xfs_trans_set_sync(tp);\n  error = xfs_trans_commit(tp, 0);\n  if (error)\n    goto out_unlock;\n  if (new_size) {\n    struct iattr iattr;\n    iattr.ia_valid = ATTR_SIZE;\n    iattr.ia_size = new_size;\n    error = xfs_setattr_size(ip, &iattr);\n  }\nout_unlock:\n  xfs_iunlock(ip, XFS_IOLOCK_EXCL);\n  return -error;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":46437
  },
  {
    "code":"static void vmx_enable_log_dirty_pt_masked(struct kvm *kvm,\n             struct kvm_memory_slot *memslot,\n             gfn_t offset, unsigned long mask)\n{\n  kvm_mmu_clear_dirty_pt_masked(kvm, memslot, offset, mask);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":42743
  },
  {
    "code":"static void ip4ip6_dscp_ecn_decapsulate(struct ip6_tnl *t,\n          struct ipv6hdr *ipv6h,\n          struct sk_buff *skb)\n{\n  __u8 dsfield = ipv6_get_dsfield(ipv6h) & ~INET_ECN_MASK;\n  if (t->parms.flags & IP6_TNL_F_RCV_DSCP_COPY)\n    ipv4_change_dsfield(ip_hdr(skb), INET_ECN_MASK, dsfield);\n  if (INET_ECN_is_ce(dsfield))\n    IP_ECN_set_ce(ip_hdr(skb));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":27394
  },
  {
    "code":"static void longLongAttrAttrSetter(v8::Local<v8::String> name, v8::Local<v8::Value> value, const v8::AccessorInfo& info)\n{\n    INC_STATS(\"DOM.TestObj.longLongAttr._set\");\n    TestObj* imp = V8TestObj::toNative(info.Holder());\n    long long v = toInt64(value);\n    imp->setLongLongAttr(WTF::getPtr(v));\n    return;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":117826
  },
  {
    "code":"static void testInterfaceEmptyArrayAttributeAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    V8TRYCATCH_VOID(Vector<RefPtr<TestInterfaceEmpty> >, cppValue, (toRefPtrNativeArray<TestInterfaceEmpty, V8TestInterfaceEmpty>(jsValue, 0, info.GetIsolate())));\n    imp->setTestInterfaceEmptyArrayAttribute(cppValue);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":131776
  },
  {
    "code":"  bool has_web_ui_bindings() const {\n    return enabled_bindings_ & kWebUIBindingsPolicyMask;\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":156560
  },
  {
    "code":"CaptureGroupNameSocketPool<ParentPool>::CaptureGroupNameSocketPool(\n    HostResolver* host_resolver,\n    CertVerifier* )\n    : ParentPool(0, 0, NULL, host_resolver, NULL, NULL) {}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":140440
  },
  {
    "code":"static int kvm_read_hva(void *data, void __user *hva, int len)\n{\n  return __copy_from_user(data, hva, len);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":29093
  },
  {
    "code":"u32 h264bsdActivateParamSets(storage_t *pStorage, u32 ppsId, u32 isIdr)\n{\n    u32 tmp;\n    u32 flag;\n    ASSERT(pStorage);\n    ASSERT(ppsId < MAX_NUM_PIC_PARAM_SETS);\n if ( (pStorage->pps[ppsId] == NULL) ||\n (pStorage->sps[pStorage->pps[ppsId]->seqParameterSetId] == NULL) )\n {\n return(HANTRO_NOK);\n }\n    tmp = CheckPps(pStorage->pps[ppsId],\n                   pStorage->sps[pStorage->pps[ppsId]->seqParameterSetId]);\n if (tmp != HANTRO_OK)\n return(tmp);\n if (pStorage->activePpsId == MAX_NUM_PIC_PARAM_SETS)\n {\n        pStorage->activePpsId = ppsId;\n         pStorage->activePps = pStorage->pps[ppsId];\n         pStorage->activeSpsId = pStorage->activePps->seqParameterSetId;\n         pStorage->activeSps = pStorage->sps[pStorage->activeSpsId];\n        pStorage->picSizeInMbs =\n            pStorage->activeSps->picWidthInMbs *\n            pStorage->activeSps->picHeightInMbs;\n         pStorage->currImage->width = pStorage->activeSps->picWidthInMbs;\n         pStorage->currImage->height = pStorage->activeSps->picHeightInMbs;\n        pStorage->pendingActivation = HANTRO_TRUE;\n }\n else if (pStorage->pendingActivation)\n {\n        pStorage->pendingActivation = HANTRO_FALSE;\n        FREE(pStorage->mb);\n        FREE(pStorage->sliceGroupMap);\n        ALLOCATE(pStorage->mb, pStorage->picSizeInMbs, mbStorage_t);\n        ALLOCATE(pStorage->sliceGroupMap, pStorage->picSizeInMbs, u32);\n if (pStorage->mb == NULL || pStorage->sliceGroupMap == NULL)\n return(MEMORY_ALLOCATION_ERROR);\n        H264SwDecMemset(pStorage->mb, 0,\n            pStorage->picSizeInMbs * sizeof(mbStorage_t));\n        h264bsdInitMbNeighbours(pStorage->mb,\n            pStorage->activeSps->picWidthInMbs,\n            pStorage->picSizeInMbs);\n if ( pStorage->noReordering ||\n             pStorage->activeSps->picOrderCntType == 2 ||\n (pStorage->activeSps->vuiParametersPresentFlag &&\n              pStorage->activeSps->vuiParameters->bitstreamRestrictionFlag &&\n !pStorage->activeSps->vuiParameters->numReorderFrames) )\n            flag = HANTRO_TRUE;\n else\n            flag = HANTRO_FALSE;\n        tmp = h264bsdResetDpb(pStorage->dpb,\n            pStorage->activeSps->picWidthInMbs *\n            pStorage->activeSps->picHeightInMbs,\n            pStorage->activeSps->maxDpbSize,\n            pStorage->activeSps->numRefFrames,\n            pStorage->activeSps->maxFrameNum,\n            flag);\n if (tmp != HANTRO_OK)\n return(tmp);\n }\n else if (ppsId != pStorage->activePpsId)\n {\n if (pStorage->pps[ppsId]->seqParameterSetId != pStorage->activeSpsId)\n {\n            DEBUG((\"SEQ PARAM SET CHANGING...\\n\"));\n if (isIdr)\n {\n                pStorage->activePpsId = ppsId;\n                pStorage->activePps = pStorage->pps[ppsId];\n                pStorage->activeSpsId = pStorage->activePps->seqParameterSetId;\n                pStorage->activeSps = pStorage->sps[pStorage->activeSpsId];\n                pStorage->picSizeInMbs =\n                    pStorage->activeSps->picWidthInMbs *\n                    pStorage->activeSps->picHeightInMbs;\n                pStorage->currImage->width = pStorage->activeSps->picWidthInMbs;\n                pStorage->currImage->height =\n                    pStorage->activeSps->picHeightInMbs;\n                pStorage->pendingActivation = HANTRO_TRUE;\n }\n else\n {\n                DEBUG((\"TRYING TO CHANGE SPS IN NON-IDR SLICE\\n\"));\n return(HANTRO_NOK);\n }\n }\n else\n {\n            pStorage->activePpsId = ppsId;\n            pStorage->activePps = pStorage->pps[ppsId];\n }\n }\n return(HANTRO_OK);\n}\n",
    "vul":1,
    "flaw_line_no":[
      22,
      23,
      24
    ],
    "bigvul_id":187789
  },
  {
    "code":"void Element::setAttributeNS(const AtomicString& namespaceURI, const AtomicString& qualifiedName, const AtomicString& value, ExceptionCode& ec)\n{\n    QualifiedName parsedName = anyName;\n    if (!parseAttributeName(parsedName, namespaceURI, qualifiedName, ec))\n        return;\n    setAttribute(parsedName, value);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":120629
  },
  {
    "code":"ofpact_is_allowed_in_actions_set(const struct ofpact *a)\n{\n    switch (a->type) {\n    case OFPACT_DEC_MPLS_TTL:\n    case OFPACT_DEC_TTL:\n    case OFPACT_GROUP:\n    case OFPACT_OUTPUT:\n    case OFPACT_OUTPUT_TRUNC:\n    case OFPACT_POP_MPLS:\n    case OFPACT_PUSH_MPLS:\n    case OFPACT_PUSH_VLAN:\n    case OFPACT_REG_MOVE:\n    case OFPACT_SET_FIELD:\n    case OFPACT_SET_ETH_DST:\n    case OFPACT_SET_ETH_SRC:\n    case OFPACT_SET_IP_DSCP:\n    case OFPACT_SET_IP_ECN:\n    case OFPACT_SET_IP_TTL:\n    case OFPACT_SET_IPV4_DST:\n    case OFPACT_SET_IPV4_SRC:\n    case OFPACT_SET_L4_DST_PORT:\n    case OFPACT_SET_L4_SRC_PORT:\n    case OFPACT_SET_MPLS_LABEL:\n    case OFPACT_SET_MPLS_TC:\n    case OFPACT_SET_MPLS_TTL:\n    case OFPACT_SET_QUEUE:\n    case OFPACT_SET_TUNNEL:\n    case OFPACT_SET_VLAN_PCP:\n    case OFPACT_SET_VLAN_VID:\n    case OFPACT_STRIP_VLAN:\n        return true;\n    case OFPACT_BUNDLE:\n    case OFPACT_CLONE:\n    case OFPACT_CONTROLLER:\n    case OFPACT_CT:\n    case OFPACT_CT_CLEAR:\n    case OFPACT_NAT:\n    case OFPACT_ENQUEUE:\n    case OFPACT_EXIT:\n    case OFPACT_UNROLL_XLATE:\n    case OFPACT_FIN_TIMEOUT:\n    case OFPACT_LEARN:\n    case OFPACT_CONJUNCTION:\n    case OFPACT_MULTIPATH:\n    case OFPACT_NOTE:\n    case OFPACT_OUTPUT_REG:\n    case OFPACT_POP_QUEUE:\n    case OFPACT_RESUBMIT:\n    case OFPACT_SAMPLE:\n    case OFPACT_STACK_POP:\n    case OFPACT_STACK_PUSH:\n    case OFPACT_DEBUG_RECIRC:\n    case OFPACT_CLEAR_ACTIONS:\n    case OFPACT_GOTO_TABLE:\n    case OFPACT_METER:\n    case OFPACT_WRITE_ACTIONS:\n    case OFPACT_WRITE_METADATA:\n        return false;\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":76992
  },
  {
    "code":"u64 perf_event_read_local(struct perf_event *event)\n{\n  unsigned long flags;\n  u64 val;\n  local_irq_save(flags);\n  WARN_ON_ONCE((event->attach_state & PERF_ATTACH_TASK) &&\n         event->hw.target != current);\n  WARN_ON_ONCE(!(event->attach_state & PERF_ATTACH_TASK) &&\n         event->cpu != smp_processor_id());\n  WARN_ON_ONCE(event->attr.inherit);\n  WARN_ON_ONCE(event->pmu->count);\n  if (event->oncpu == smp_processor_id())\n    event->pmu->read(event);\n  val = local64_read(&event->count);\n  local_irq_restore(flags);\n  return val;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":56093
  },
  {
    "code":"void MediaControlsProgressView::SetProgressTime(const base::string16& time) {\n  progress_time_->SetText(time);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":149212
  },
  {
    "code":"static v8::Handle<v8::Value> overloadedMethodCallback(const v8::Arguments& args)\n{\n    INC_STATS(\"DOM.TestObj.overloadedMethod\");\n    if ((args.Length() == 2 && (args[0]->IsNull() || V8TestObj::HasInstance(args[0])) && (args[1]->IsNull() || args[1]->IsUndefined() || args[1]->IsString() || args[1]->IsObject())))\n        return overloadedMethod1Callback(args);\n    if ((args.Length() == 1 && (args[0]->IsNull() || V8TestObj::HasInstance(args[0]))) || (args.Length() == 2 && (args[0]->IsNull() || V8TestObj::HasInstance(args[0]))))\n        return overloadedMethod2Callback(args);\n    if ((args.Length() == 1 && (args[0]->IsNull() || args[0]->IsUndefined() || args[0]->IsString() || args[0]->IsObject())))\n        return overloadedMethod3Callback(args);\n    if (args.Length() == 1)\n        return overloadedMethod4Callback(args);\n    if ((args.Length() == 1 && (args[0]->IsNull() || args[0]->IsFunction())))\n        return overloadedMethod5Callback(args);\n    if ((args.Length() == 1 && (args[0]->IsNull() || V8DOMStringList::HasInstance(args[0]))))\n        return overloadedMethod6Callback(args);\n    if ((args.Length() == 1 && (args[0]->IsNull() || args[0]->IsArray())))\n        return overloadedMethod7Callback(args);\n    V8Proxy::throwTypeError();\n    return notHandledByInterceptor();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":117843
  },
  {
    "code":"  explicit DocumentOutliveTimeReporter(Document* document)\n      : BlinkGCObserver(ThreadState::Current()), document_(document) {}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":141037
  },
  {
    "code":"void *usb_alloc_coherent(struct usb_device *dev, size_t size, gfp_t mem_flags,\n       dma_addr_t *dma)\n{\n  if (!dev || !dev->bus)\n    return NULL;\n  return hcd_buffer_alloc(dev->bus, size, mem_flags, dma);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":75536
  },
  {
    "code":"custom_time_skip (va_list *va)\n{\n    (void) va_arg (*va, int);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":61039
  },
  {
    "code":"AcpiDsCreateOperand (\n    ACPI_WALK_STATE         *WalkState,\n    ACPI_PARSE_OBJECT       *Arg,\n    UINT32                  ArgIndex)\n{\n    ACPI_STATUS             Status = AE_OK;\n    char                    *NameString;\n    UINT32                  NameLength;\n    ACPI_OPERAND_OBJECT     *ObjDesc;\n    ACPI_PARSE_OBJECT       *ParentOp;\n    UINT16                  Opcode;\n    ACPI_INTERPRETER_MODE   InterpreterMode;\n    const ACPI_OPCODE_INFO  *OpInfo;\n    ACPI_FUNCTION_TRACE_PTR (DsCreateOperand, Arg);\n    if ((Arg->Common.AmlOpcode == AML_INT_NAMEPATH_OP) &&\n        (Arg->Common.Value.String) &&\n        !(Arg->Common.Flags & ACPI_PARSEOP_IN_STACK))\n    {\n        ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH, \"Getting a name: Arg=%p\\n\", Arg));\n        Status = AcpiExGetNameString (ACPI_TYPE_ANY,\n            Arg->Common.Value.Buffer, &NameString, &NameLength);\n        if (ACPI_FAILURE (Status))\n        {\n            return_ACPI_STATUS (Status);\n        }\n        if ((WalkState->DeferredNode) &&\n            (WalkState->DeferredNode->Type == ACPI_TYPE_BUFFER_FIELD) &&\n            (ArgIndex == (UINT32)\n                ((WalkState->Opcode == AML_CREATE_FIELD_OP) ? 3 : 2)))\n        {\n            ObjDesc = ACPI_CAST_PTR (\n                ACPI_OPERAND_OBJECT, WalkState->DeferredNode);\n            Status = AE_OK;\n        }\n        else    \n        {\n            ParentOp = Arg->Common.Parent;\n            OpInfo = AcpiPsGetOpcodeInfo (ParentOp->Common.AmlOpcode);\n            if ((OpInfo->Flags & AML_NSNODE) &&\n                (ParentOp->Common.AmlOpcode != AML_INT_METHODCALL_OP) &&\n                (ParentOp->Common.AmlOpcode != AML_REGION_OP) &&\n                (ParentOp->Common.AmlOpcode != AML_INT_NAMEPATH_OP))\n            {\n                InterpreterMode = ACPI_IMODE_LOAD_PASS2;\n            }\n            else\n            {\n                InterpreterMode = ACPI_IMODE_EXECUTE;\n            }\n            Status = AcpiNsLookup (WalkState->ScopeInfo, NameString,\n                ACPI_TYPE_ANY, InterpreterMode,\n                ACPI_NS_SEARCH_PARENT | ACPI_NS_DONT_OPEN_SCOPE, WalkState,\n                ACPI_CAST_INDIRECT_PTR (ACPI_NAMESPACE_NODE, &ObjDesc));\n            if (Status == AE_NOT_FOUND)\n            {\n                if (ParentOp->Common.AmlOpcode == AML_CONDITIONAL_REF_OF_OP)\n                {\n                    ObjDesc = ACPI_CAST_PTR (\n                        ACPI_OPERAND_OBJECT, AcpiGbl_RootNode);\n                    Status = AE_OK;\n                }\n                else if (ParentOp->Common.AmlOpcode == AML_EXTERNAL_OP)\n                {\n                    Status = AE_AML_BAD_OPCODE;\n                }\n                else\n                {\n                    Status = AE_AML_NAME_NOT_FOUND;\n                }\n            }\n            if (ACPI_FAILURE (Status))\n            {\n                ACPI_ERROR_NAMESPACE (NameString, Status);\n            }\n        }\n        ACPI_FREE (NameString);\n        if (ACPI_FAILURE (Status))\n        {\n            return_ACPI_STATUS (Status);\n        }\n        Status = AcpiDsObjStackPush (ObjDesc, WalkState);\n        if (ACPI_FAILURE (Status))\n        {\n            return_ACPI_STATUS (Status);\n        }\n        AcpiDbDisplayArgumentObject (ObjDesc, WalkState);\n    }\n    else\n    {\n        if ((Arg->Common.AmlOpcode == AML_INT_NAMEPATH_OP) &&\n            !(Arg->Common.Flags & ACPI_PARSEOP_IN_STACK))\n        {\n            Opcode = AML_ZERO_OP;       \n            ACPI_DEBUG_PRINT ((ACPI_DB_DISPATCH,\n                \"Null namepath: Arg=%p\\n\", Arg));\n        }\n        else\n        {\n            Opcode = Arg->Common.AmlOpcode;\n        }\n        OpInfo = AcpiPsGetOpcodeInfo (Opcode);\n        if (OpInfo->ObjectType == ACPI_TYPE_INVALID)\n        {\n            return_ACPI_STATUS (AE_NOT_IMPLEMENTED);\n        }\n        if ((OpInfo->Flags & AML_HAS_RETVAL) ||\n            (Arg->Common.Flags & ACPI_PARSEOP_IN_STACK))\n        {\n            Status = AcpiDsResultPop (&ObjDesc, WalkState);\n            if (ACPI_FAILURE (Status))\n            {\n                ACPI_EXCEPTION ((AE_INFO, Status,\n                    \"Missing or null operand\"));\n                return_ACPI_STATUS (Status);\n            }\n        }\n        else\n        {\n            ObjDesc = AcpiUtCreateInternalObject (OpInfo->ObjectType);\n            if (!ObjDesc)\n            {\n                return_ACPI_STATUS (AE_NO_MEMORY);\n            }\n            Status = AcpiDsInitObjectFromOp (\n                WalkState, Arg, Opcode, &ObjDesc);\n            if (ACPI_FAILURE (Status))\n            {\n                AcpiUtDeleteObjectDesc (ObjDesc);\n                return_ACPI_STATUS (Status);\n            }\n        }\n        Status = AcpiDsObjStackPush (ObjDesc, WalkState);\n        if (ACPI_FAILURE (Status))\n        {\n            return_ACPI_STATUS (Status);\n        }\n        AcpiDbDisplayArgumentObject (ObjDesc, WalkState);\n    }\n    return_ACPI_STATUS (AE_OK);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":61978
  },
  {
    "code":"void V8TestObject::VoidMethodFlexibleArrayBufferViewArgMethodCallback(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_voidMethodFlexibleArrayBufferViewArg\");\n  test_object_v8_internal::VoidMethodFlexibleArrayBufferViewArgMethod(info);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":148101
  },
  {
    "code":"box_wd(BOX *box)\n{\n  return box->high.x - box->low.x;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":38832
  },
  {
    "code":"brcmf_dongle_scantime(struct brcmf_if *ifp)\n{\n  s32 err = 0;\n  err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_CHANNEL_TIME,\n            BRCMF_SCAN_CHANNEL_TIME);\n  if (err) {\n    brcmf_err(\"Scan assoc time error (%d)\\n\", err);\n    goto dongle_scantime_out;\n  }\n  err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_UNASSOC_TIME,\n            BRCMF_SCAN_UNASSOC_TIME);\n  if (err) {\n    brcmf_err(\"Scan unassoc time error (%d)\\n\", err);\n    goto dongle_scantime_out;\n  }\n  err = brcmf_fil_cmd_int_set(ifp, BRCMF_C_SET_SCAN_PASSIVE_TIME,\n            BRCMF_SCAN_PASSIVE_TIME);\n  if (err) {\n    brcmf_err(\"Scan passive time error (%d)\\n\", err);\n    goto dongle_scantime_out;\n  }\ndongle_scantime_out:\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":49066
  },
  {
    "code":"void ChromeRenderMessageFilter::OnRendererHistograms(\n    int sequence_number,\n    const std::vector<std::string>& histograms) {\n  HistogramSynchronizer::DeserializeHistogramList(sequence_number, histograms);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":112277
  },
  {
    "code":"V4L2JpegEncodeAccelerator::JpegBufferRecord::~JpegBufferRecord() {}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":148754
  },
  {
    "code":"int vrend_create_shader(struct vrend_context *ctx,\n                        uint32_t handle,\n                        const struct pipe_stream_output_info *so_info,\n                        const char *shd_text, uint32_t offlen, uint32_t num_tokens,\n                        uint32_t type, uint32_t pkt_length)\n{\n   struct vrend_shader_selector *sel = NULL;\n   int ret_handle;\n   bool new_shader = true, long_shader = false;\n   bool finished = false;\n   int ret;\n   if (type > PIPE_SHADER_GEOMETRY)\n      return EINVAL;\n   if (offlen & VIRGL_OBJ_SHADER_OFFSET_CONT)\n      new_shader = false;\n   else if (((offlen + 3) \/ 4) > pkt_length)\n      long_shader = true;\n   if (ctx->sub->long_shader_in_progress_handle[type]) {\n      if (new_shader == true)\n         return EINVAL;\n      if (handle != ctx->sub->long_shader_in_progress_handle[type])\n         return EINVAL;\n   }\n   if (new_shader) {\n     sel = vrend_create_shader_state(ctx, so_info, type);\n     if (sel == NULL)\n       return ENOMEM;\n     if (long_shader) {\n        sel->buf_len = ((offlen + 3) \/ 4) * 4; \n        sel->tmp_buf = malloc(sel->buf_len);\n        if (!sel->tmp_buf) {\n           ret = ENOMEM;\n           goto error;\n        }\n        memcpy(sel->tmp_buf, shd_text, pkt_length * 4);\n        sel->buf_offset = pkt_length * 4;\n        ctx->sub->long_shader_in_progress_handle[type] = handle;\n     } else\n        finished = true;\n   } else {\n      sel = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_SHADER);\n      if (!sel) {\n         fprintf(stderr, \"got continuation without original shader %d\\n\", handle);\n         ret = EINVAL;\n         goto error;\n      }\n      offlen &= ~VIRGL_OBJ_SHADER_OFFSET_CONT;\n      if (offlen != sel->buf_offset) {\n         fprintf(stderr, \"Got mismatched shader continuation %d vs %d\\n\",\n                 offlen, sel->buf_offset);\n         ret = EINVAL;\n         goto error;\n      }\n      if (pkt_length * 4 < pkt_length ||\n          pkt_length * 4 + sel->buf_offset < pkt_length * 4 ||\n          pkt_length * 4 + sel->buf_offset < sel->buf_offset) {\n            ret = EINVAL;\n            goto error;\n          }\n      if ((pkt_length * 4 + sel->buf_offset) > sel->buf_len) {\n         fprintf(stderr, \"Got too large shader continuation %d vs %d\\n\",\n                 pkt_length * 4 + sel->buf_offset, sel->buf_len);\n         ret = EINVAL;\n         goto error;\n      }\n      memcpy(sel->tmp_buf + sel->buf_offset, shd_text, pkt_length * 4);\n      sel->buf_offset += pkt_length * 4;\n      if (sel->buf_offset >= sel->buf_len) {\n         finished = true;\n         shd_text = sel->tmp_buf;\n      }\n   }\n   if (finished) {\n      struct tgsi_token *tokens;\n      tokens = calloc(num_tokens + 10, sizeof(struct tgsi_token));\n      if (!tokens) {\n         ret = ENOMEM;\n         goto error;\n      }\n      if (vrend_dump_shaders)\n         fprintf(stderr,\"shader\\n%s\\n\", shd_text);\n      if (!tgsi_text_translate((const char *)shd_text, tokens, num_tokens + 10)) {\n         free(tokens);\n         ret = EINVAL;\n         goto error;\n      }\n      if (vrend_finish_shader(ctx, sel, tokens)) {\n         free(tokens);\n         ret = EINVAL;\n         goto error;\n      } else {\n         free(sel->tmp_buf);\n         sel->tmp_buf = NULL;\n      }\n      free(tokens);\n      ctx->sub->long_shader_in_progress_handle[type] = 0;\n   }\n   if (new_shader) {\n      ret_handle = vrend_renderer_object_insert(ctx, sel, sizeof(*sel), handle, VIRGL_OBJECT_SHADER);\n      if (ret_handle == 0) {\n         ret = ENOMEM;\n         goto error;\n      }\n   }\n   return 0;\nerror:\n   if (new_shader)\n      vrend_destroy_shader_selector(sel);\n   else\n      vrend_renderer_object_destroy(ctx, handle);\n   return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":8833
  },
  {
    "code":"void SyncBackendHost::Core::NotifyPassphraseAccepted(\n    const std::string& bootstrap_token) {\n  if (!host_ || !host_->frontend_)\n    return;\n  DCHECK_EQ(MessageLoop::current(), host_->frontend_loop_);\n  processing_passphrase_ = false;\n  host_->PersistEncryptionBootstrapToken(bootstrap_token);\n  host_->frontend_->OnPassphraseAccepted();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":106340
  },
  {
    "code":"MagickExport MagickBooleanType AutoThresholdImage(Image *image,\n  const AutoThresholdMethod method,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n  char\n    property[MagickPathExtent];\n  double\n    gamma,\n    *histogram,\n    sum,\n    threshold;\n  MagickBooleanType\n    status;\n  register ssize_t\n    i;\n  ssize_t\n    y;\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  histogram=(double *) AcquireQuantumMemory(MaxIntensity+1UL,\n    sizeof(*histogram));\n  if (histogram == (double *) NULL)\n    ThrowBinaryException(ResourceLimitError,\"MemoryAllocationFailed\",\n      image->filename);\n  status=MagickTrue;\n  (void) memset(histogram,0,(MaxIntensity+1UL)*sizeof(*histogram));\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const PixelPacket\n      *magick_restrict p;\n    register ssize_t\n      x;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (const PixelPacket *) NULL)\n      break;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      double intensity = GetPixelIntensity(image,p);\n      histogram[ScaleQuantumToChar(ClampToQuantum(intensity))]++;\n      p++;\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  sum=0.0;\n  for (i=0; i <= (ssize_t) MaxIntensity; i++)\n    sum+=histogram[i];\n  gamma=PerceptibleReciprocal(sum);\n  for (i=0; i <= (ssize_t) MaxIntensity; i++)\n    histogram[i]=gamma*histogram[i];\n  switch (method)\n  {\n    case KapurThresholdMethod:\n    {\n      threshold=KapurThreshold(image,histogram,exception);\n      break;\n    }\n    case OTSUThresholdMethod:\n    default:\n    {\n      threshold=OTSUThreshold(image,histogram,exception);\n      break;\n    }\n    case TriangleThresholdMethod:\n    {\n      threshold=TriangleThreshold(image,histogram);\n      break;\n    }\n  }\n  histogram=(double *) RelinquishMagickMemory(histogram);\n  if (threshold < 0.0)\n    status=MagickFalse;\n  if (status == MagickFalse)\n    return(MagickFalse);\n  (void) FormatLocaleString(property,MagickPathExtent,\"%g%%\",threshold);\n  (void) SetImageProperty(image,\"auto-threshold:threshold\",property);\n  return(BilevelImage(image,QuantumRange*threshold\/100.0));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":89011
  },
  {
    "code":"psf_fgets (char *buffer, sf_count_t bufsize, SF_PRIVATE *psf)\n{  sf_count_t  k = 0 ;\n  sf_count_t    count ;\n  while (k < bufsize - 1)\n  {  count = read (psf->file.filedes, &(buffer [k]), 1) ;\n    if (count == -1)\n    {  if (errno == EINTR)\n        continue ;\n      psf_log_syserr (psf, errno) ;\n      break ;\n      } ;\n    if (count == 0 || buffer [k++] == '\\n')\n      break ;\n    } ;\n  buffer [k] = 0 ;\n  return k ;\n} \n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":45210
  },
  {
    "code":"void OxideQQuickWebView::touchUngrabEvent() {\n  Q_D(OxideQQuickWebView);\n  QQuickItem::touchUngrabEvent();\n  d->contents_view_->handleTouchUngrabEvent();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":17183
  },
  {
    "code":"bool PepperDeviceEnumerationHostHelper::HandleResourceMessage(\n    const IPC::Message& msg,\n    HostMessageContext* context,\n    int32_t* result) {\n  bool return_value = false;\n  *result = InternalHandleResourceMessage(msg, context, &return_value);\n  return return_value;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":127784
  },
  {
    "code":"void FakeCrosDisksClient::NotifyRenameCompleted(\n    RenameError error_code,\n    const std::string& device_path) {\n  for (auto& observer : observer_list_)\n    observer.OnRenameCompleted(error_code, device_path);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":134975
  },
  {
    "code":"bool FrameFetchContext::UpdateTimingInfoForIFrameNavigation(\n    ResourceTimingInfo* info) {\n  if (IsDetached())\n    return false;\n  if (!GetFrame()->Owner())\n    return false;\n   if (!GetFrame()->should_send_resource_timing_info_to_parent())\n     return false;\n  if (MasterDocumentLoader()->LoadType() == WebFrameLoadType::kBackForward)\n     return false;\n   return true;\n }\n",
    "vul":1,
    "flaw_line_no":[
      9
    ],
    "bigvul_id":186634
  },
  {
    "code":"static ssize_t fuse_dev_do_read(struct fuse_conn *fc, struct file *file,\n        struct fuse_copy_state *cs, size_t nbytes)\n{\n  int err;\n  struct fuse_req *req;\n  struct fuse_in *in;\n  unsigned reqsize;\n restart:\n  spin_lock(&fc->lock);\n  err = -EAGAIN;\n  if ((file->f_flags & O_NONBLOCK) && fc->connected &&\n      !request_pending(fc))\n    goto err_unlock;\n  request_wait(fc);\n  err = -ENODEV;\n  if (!fc->connected)\n    goto err_unlock;\n  err = -ERESTARTSYS;\n  if (!request_pending(fc))\n    goto err_unlock;\n  if (!list_empty(&fc->interrupts)) {\n    req = list_entry(fc->interrupts.next, struct fuse_req,\n         intr_entry);\n    return fuse_read_interrupt(fc, cs, nbytes, req);\n  }\n  if (forget_pending(fc)) {\n    if (list_empty(&fc->pending) || fc->forget_batch-- > 0)\n      return fuse_read_forget(fc, cs, nbytes);\n    if (fc->forget_batch <= -8)\n      fc->forget_batch = 16;\n  }\n  req = list_entry(fc->pending.next, struct fuse_req, list);\n  req->state = FUSE_REQ_READING;\n  list_move(&req->list, &fc->io);\n  in = &req->in;\n  reqsize = in->h.len;\n  if (nbytes < reqsize) {\n    req->out.h.error = -EIO;\n    if (in->h.opcode == FUSE_SETXATTR)\n      req->out.h.error = -E2BIG;\n    request_end(fc, req);\n    goto restart;\n  }\n  spin_unlock(&fc->lock);\n  cs->req = req;\n  err = fuse_copy_one(cs, &in->h, sizeof(in->h));\n  if (!err)\n    err = fuse_copy_args(cs, in->numargs, in->argpages,\n             (struct fuse_arg *) in->args, 0);\n  fuse_copy_finish(cs);\n  spin_lock(&fc->lock);\n  req->locked = 0;\n  if (req->aborted) {\n    request_end(fc, req);\n    return -ENODEV;\n  }\n  if (err) {\n    req->out.h.error = -EIO;\n    request_end(fc, req);\n    return err;\n  }\n  if (!req->isreply)\n    request_end(fc, req);\n  else {\n    req->state = FUSE_REQ_SENT;\n    list_move_tail(&req->list, &fc->processing);\n    if (req->interrupted)\n      queue_interrupt(fc, req);\n    spin_unlock(&fc->lock);\n  }\n  return reqsize;\n err_unlock:\n  spin_unlock(&fc->lock);\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":24600
  },
  {
    "code":" alloc_limit_failure (char *fn_name, size_t size)\n {\n    fprintf (stderr, \n              \"%s: Maximum allocation size exceeded \"\n              \"(maxsize = %lu; size = %lu).\\n\",\n              fn_name,\n             (unsigned long)alloc_limit, \n              (unsigned long)size);\n }\n",
    "vul":1,
    "flaw_line_no":[
      3,
      7
    ],
    "bigvul_id":181527
  },
  {
    "code":"int nfs_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n  return nfs_commit_unstable_pages(inode, wbc);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":39204
  },
  {
    "code":"php_apache_sapi_header_handler(sapi_header_struct *sapi_header, sapi_header_op_enum op, sapi_headers_struct *sapi_headers TSRMLS_DC)\n{\n  php_struct *ctx;\n  char *val, *ptr;\n  ctx = SG(server_context);\n  switch (op) {\n    case SAPI_HEADER_DELETE:\n      apr_table_unset(ctx->r->headers_out, sapi_header->header);\n      return 0;\n    case SAPI_HEADER_DELETE_ALL:\n      apr_table_clear(ctx->r->headers_out);\n      return 0;\n    case SAPI_HEADER_ADD:\n    case SAPI_HEADER_REPLACE:\n      val = strchr(sapi_header->header, ':');\n      if (!val) {\n        return 0;\n      }\n      ptr = val;\n      *val = '\\0';\n      do {\n        val++;\n      } while (*val == ' ');\n      if (!strcasecmp(sapi_header->header, \"content-type\")) {\n        if (ctx->content_type) {\n          efree(ctx->content_type);\n        }\n        ctx->content_type = estrdup(val);\n      } else if (!strcasecmp(sapi_header->header, \"content-length\")) {\n        apr_off_t clen = 0;\n        if (APR_SUCCESS != apr_strtoff(&clen, val, (char **) NULL, 10)) {\n          clen = (apr_off_t) strtol(val, (char **) NULL, 10);\n        }\n        ap_set_content_length(ctx->r, clen);\n      } else if (op == SAPI_HEADER_REPLACE) {\n        apr_table_set(ctx->r->headers_out, sapi_header->header, val);\n      } else {\n        apr_table_add(ctx->r->headers_out, sapi_header->header, val);\n      }\n      *ptr = ':';\n      return SAPI_HEADER_ADD;\n    default:\n      return 0;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":77754
  },
  {
    "code":"bool hex2bin(unsigned char *p, const char *hexstr, size_t len)\n{\n  int nibble1, nibble2;\n  unsigned char idx;\n  bool ret = false;\n  while (*hexstr && len) {\n    if (unlikely(!hexstr[1])) {\n      applog(LOG_ERR, \"hex2bin str truncated\");\n      return ret;\n    }\n    idx = *hexstr++;\n    nibble1 = hex2bin_tbl[idx];\n    idx = *hexstr++;\n    nibble2 = hex2bin_tbl[idx];\n    if (unlikely((nibble1 < 0) || (nibble2 < 0))) {\n      applog(LOG_ERR, \"hex2bin scan failed\");\n      return ret;\n    }\n    *p++ = (((unsigned char)nibble1) << 4) | ((unsigned char)nibble2);\n    --len;\n  }\n  if (likely(len == 0 && *hexstr == 0))\n    ret = true;\n   return ret;\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":36662
  },
  {
    "code":"void OmniboxViewViews::OnNativeThemeChanged(const ui::NativeTheme* theme) {\n  views::Textfield::OnNativeThemeChanged(theme);\n  if (location_bar_view_) {\n    SetBackgroundColor(\n        location_bar_view_->GetColor(LocationBarView::BACKGROUND));\n  }\n  EmphasizeURLComponents();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":163451
  },
  {
    "code":"WebPageProxy* WebInspectorProxy::platformCreateInspectorPage()\n{\n    ASSERT(m_page);\n    ASSERT(!m_inspectorView);\n    m_inspectorView = GTK_WIDGET(webkitWebViewBaseCreate(page()->process()->context(), inspectorPageGroup()));\n    g_object_add_weak_pointer(G_OBJECT(m_inspectorView), reinterpret_cast<void**>(&m_inspectorView));\n    return webkitWebViewBaseGetPage(WEBKIT_WEB_VIEW_BASE(m_inspectorView));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":117191
  },
  {
    "code":"void BrowserEventRouter::PageActionExecuted(Profile* profile,\n                                            const ExtensionAction& page_action,\n                                            int tab_id,\n                                            const std::string& url,\n                                            int button) {\n  DispatchOldPageActionEvent(profile, page_action.extension_id(),\n                             page_action.id(), tab_id, url, button);\n  WebContents* web_contents = NULL;\n  if (!ExtensionTabUtil::GetTabById(tab_id, profile, profile->IsOffTheRecord(),\n                                    NULL, NULL, &web_contents, NULL)) {\n    return;\n  }\n  ExtensionActionExecuted(profile, page_action, web_contents);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":124367
  },
  {
    "code":"static int ubifs_writepage(struct page *page, struct writeback_control *wbc)\n{\n  struct inode *inode = page->mapping->host;\n  struct ubifs_inode *ui = ubifs_inode(inode);\n  loff_t i_size =  i_size_read(inode), synced_i_size;\n  pgoff_t end_index = i_size >> PAGE_CACHE_SHIFT;\n  int err, len = i_size & (PAGE_CACHE_SIZE - 1);\n  void *kaddr;\n  dbg_gen(\"ino %lu, pg %lu, pg flags %#lx\",\n    inode->i_ino, page->index, page->flags);\n  ubifs_assert(PagePrivate(page));\n  if (page->index > end_index || (page->index == end_index && !len)) {\n    err = 0;\n    goto out_unlock;\n  }\n  spin_lock(&ui->ui_lock);\n  synced_i_size = ui->synced_i_size;\n  spin_unlock(&ui->ui_lock);\n  if (page->index < end_index) {\n    if (page->index >= synced_i_size >> PAGE_CACHE_SHIFT) {\n      err = inode->i_sb->s_op->write_inode(inode, NULL);\n      if (err)\n        goto out_unlock;\n    }\n    return do_writepage(page, PAGE_CACHE_SIZE);\n  }\n  kaddr = kmap_atomic(page);\n  memset(kaddr + len, 0, PAGE_CACHE_SIZE - len);\n  flush_dcache_page(page);\n  kunmap_atomic(kaddr);\n  if (i_size > synced_i_size) {\n    err = inode->i_sb->s_op->write_inode(inode, NULL);\n    if (err)\n      goto out_unlock;\n  }\n  return do_writepage(page, len);\nout_unlock:\n  unlock_page(page);\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":46429
  },
  {
    "code":"std::string FormatLog(const char* fmt, va_list args) {\n  std::string msg = base::StringPrintV(fmt, args);\n  if (!msg.empty() && msg[msg.size() - 1] == '\\n')\n    msg.erase(msg.end() - 1, msg.end());\n  return msg;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":134784
  },
  {
    "code":"DaemonProcessTest::~DaemonProcessTest() {\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":127200
  },
  {
    "code":"void Browser::MoveTabNext() {\n  UserMetrics::RecordAction(UserMetricsAction(\"MoveTabNext\"), profile_);\n  tab_handler_->GetTabStripModel()->MoveTabNext();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":103129
  },
  {
    "code":"asmlinkage long sys_recv(int fd, void __user *ubuf, size_t size,\n       unsigned flags)\n{\n  return sys_recvfrom(fd, ubuf, size, flags, NULL, NULL);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":22738
  },
  {
    "code":"void WebContentsImpl::SetFocusedFrame(FrameTreeNode* node,\n                                      SiteInstance* source) {\n  SetAsFocusedWebContentsIfNecessary();\n  frame_tree_.SetFocusedFrame(node, source);\n  WebContentsImpl* inner_contents = node_.GetInnerWebContentsInFrame(node);\n  WebContentsImpl* contents_to_focus = inner_contents ? inner_contents : this;\n  contents_to_focus->SetAsFocusedWebContentsIfNecessary();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":163720
  },
  {
    "code":"xmlXPathRegisteredNsCleanup(xmlXPathContextPtr ctxt) {\n    if (ctxt == NULL)\n  return;\n    xmlHashFree(ctxt->nsHash, (xmlHashDeallocator)xmlFree);\n    ctxt->nsHash = NULL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":97778
  },
  {
    "code":"cupsdAcceptClient(cupsd_listener_t *lis)\n{\n  const char    *hostname;  \n  char      name[256];  \n  int      count;    \n  cupsd_client_t  *con,    \n      *tempcon;  \n  socklen_t    addrlen;  \n  http_addr_t    temp;    \n  static time_t    last_dos = 0;  \n#ifdef HAVE_TCPD_H\n  struct request_info  wrap_req;  \n#endif \n  cupsdLogMessage(CUPSD_LOG_DEBUG2, \"cupsdAcceptClient(lis=%p(%d)) Clients=%d\", lis, lis->fd, cupsArrayCount(Clients));\n  if (cupsArrayCount(Clients) == MaxClients)\n    return;\n  if (!Clients)\n    Clients = cupsArrayNew(NULL, NULL);\n  if (!Clients)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to allocate memory for clients array!\");\n    cupsdPauseListening();\n    return;\n  }\n  if (!ActiveClients)\n    ActiveClients = cupsArrayNew((cups_array_func_t)compare_clients, NULL);\n  if (!ActiveClients)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR,\n                    \"Unable to allocate memory for active clients array!\");\n    cupsdPauseListening();\n    return;\n  }\n  if ((con = calloc(1, sizeof(cupsd_client_t))) == NULL)\n  {\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"Unable to allocate memory for client!\");\n    cupsdPauseListening();\n    return;\n  }\n  con->number = ++ LastClientNumber;\n  con->file   = -1;\n  if ((con->http = httpAcceptConnection(lis->fd, 0)) == NULL)\n  {\n    if (errno == ENFILE || errno == EMFILE)\n      cupsdPauseListening();\n    cupsdLogMessage(CUPSD_LOG_ERROR, \"Unable to accept client connection - %s.\",\n                    strerror(errno));\n    free(con);\n    return;\n  }\n  addrlen = sizeof(con->clientaddr);\n  if (getsockname(httpGetFd(con->http), (struct sockaddr *)&con->clientaddr, &addrlen) || addrlen == 0)\n    con->clientaddr = lis->address;\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Server address is \\\"%s\\\".\", httpAddrString(&con->clientaddr, name, sizeof(name)));\n  for (count = 0, tempcon = (cupsd_client_t *)cupsArrayFirst(Clients);\n       tempcon;\n       tempcon = (cupsd_client_t *)cupsArrayNext(Clients))\n    if (httpAddrEqual(httpGetAddress(tempcon->http), httpGetAddress(con->http)))\n    {\n      count ++;\n      if (count >= MaxClientsPerHost)\n  break;\n    }\n  if (count >= MaxClientsPerHost)\n  {\n    if ((time(NULL) - last_dos) >= 60)\n    {\n      last_dos = time(NULL);\n      cupsdLogMessage(CUPSD_LOG_WARN,\n                      \"Possible DoS attack - more than %d clients connecting \"\n          \"from %s.\",\n                MaxClientsPerHost,\n          httpGetHostname(con->http, name, sizeof(name)));\n    }\n    httpClose(con->http);\n    free(con);\n    return;\n  }\n  if (HostNameLookups)\n    hostname = httpResolveHostname(con->http, NULL, 0);\n  else\n    hostname = httpGetHostname(con->http, NULL, 0);\n  if (hostname == NULL && HostNameLookups == 2)\n  {\n    httpClose(con->http);\n    cupsdLogClient(con, CUPSD_LOG_WARN,\n                    \"Name lookup failed - connection from %s closed!\",\n                    httpGetHostname(con->http, NULL, 0));\n    free(con);\n    return;\n  }\n  if (HostNameLookups == 2)\n  {\n    http_addrlist_t  *addrlist,  \n      *addr;    \n    if ((addrlist = httpAddrGetList(hostname, AF_UNSPEC, NULL)) != NULL)\n    {\n      for (addr = addrlist; addr; addr = addr->next)\n        if (httpAddrEqual(httpGetAddress(con->http), &(addr->addr)))\n          break;\n    }\n    else\n      addr = NULL;\n    httpAddrFreeList(addrlist);\n    if (!addr)\n    {\n      httpClose(con->http);\n      cupsdLogClient(con, CUPSD_LOG_WARN,\n                      \"IP lookup failed - connection from %s closed!\",\n                      httpGetHostname(con->http, NULL, 0));\n      free(con);\n      return;\n    }\n  }\n#ifdef HAVE_TCPD_H\n  request_init(&wrap_req, RQ_DAEMON, \"cupsd\", RQ_FILE, httpGetFd(con->http),\n               NULL);\n  fromhost(&wrap_req);\n  if (!hosts_access(&wrap_req))\n  {\n    httpClose(con->http);\n    cupsdLogClient(con, CUPSD_LOG_WARN,\n                    \"Connection from %s refused by \/etc\/hosts.allow and \"\n        \"\/etc\/hosts.deny rules.\", httpGetHostname(con->http, NULL, 0));\n    free(con);\n    return;\n  }\n#endif \n#ifdef AF_LOCAL\n  if (httpAddrFamily(httpGetAddress(con->http)) == AF_LOCAL)\n  {\n#  ifdef __APPLE__\n    socklen_t  peersize;    \n    pid_t  peerpid;    \n    char  peername[256];    \n    peersize = sizeof(peerpid);\n    if (!getsockopt(httpGetFd(con->http), SOL_LOCAL, LOCAL_PEERPID, &peerpid,\n                    &peersize))\n    {\n      if (!proc_name((int)peerpid, peername, sizeof(peername)))\n  cupsdLogClient(con, CUPSD_LOG_DEBUG,\n                 \"Accepted from %s (Domain ???[%d])\",\n                       httpGetHostname(con->http, NULL, 0), (int)peerpid);\n      else\n  cupsdLogClient(con, CUPSD_LOG_DEBUG,\n                       \"Accepted from %s (Domain %s[%d])\",\n                       httpGetHostname(con->http, NULL, 0), peername, (int)peerpid);\n    }\n    else\n#  endif \n    cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Accepted from %s (Domain)\",\n                   httpGetHostname(con->http, NULL, 0));\n  }\n  else\n#endif \n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Accepted from %s:%d (IPv%d)\",\n                 httpGetHostname(con->http, NULL, 0),\n     httpAddrPort(httpGetAddress(con->http)),\n     httpAddrFamily(httpGetAddress(con->http)) == AF_INET ? 4 : 6);\n  addrlen = sizeof(temp);\n  if (getsockname(httpGetFd(con->http), (struct sockaddr *)&temp, &addrlen))\n  {\n    cupsdLogClient(con, CUPSD_LOG_ERROR, \"Unable to get local address - %s\",\n                   strerror(errno));\n    strlcpy(con->servername, \"localhost\", sizeof(con->servername));\n    con->serverport = LocalPort;\n  }\n#ifdef AF_LOCAL\n  else if (httpAddrFamily(&temp) == AF_LOCAL)\n  {\n    strlcpy(con->servername, \"localhost\", sizeof(con->servername));\n    con->serverport = LocalPort;\n  }\n#endif \n  else\n  {\n    if (httpAddrLocalhost(&temp))\n      strlcpy(con->servername, \"localhost\", sizeof(con->servername));\n    else if (HostNameLookups)\n      httpAddrLookup(&temp, con->servername, sizeof(con->servername));\n    else\n      httpAddrString(&temp, con->servername, sizeof(con->servername));\n    con->serverport = httpAddrPort(&(lis->address));\n  }\n  cupsArrayAdd(Clients, con);\n  cupsdAddSelect(httpGetFd(con->http), (cupsd_selfunc_t)cupsdReadClient, NULL,\n                 con);\n  cupsdLogClient(con, CUPSD_LOG_DEBUG, \"Waiting for request.\");\n  if (cupsArrayCount(Clients) == MaxClients)\n    cupsdPauseListening();\n#ifdef HAVE_SSL\n  if (lis->encryption == HTTP_ENCRYPTION_ALWAYS)\n  {\n    if (cupsd_start_tls(con, HTTP_ENCRYPTION_ALWAYS))\n      cupsdCloseClient(con);\n  }\n  else\n    con->auto_ssl = 1;\n#endif \n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":86097
  },
  {
    "code":"bool GLES2DecoderImpl::PrepForSetUniformByLocation(\n    GLint fake_location,\n    const char* function_name,\n    Program::UniformApiType api_type,\n    GLint* real_location,\n    GLenum* type,\n    GLsizei* count) {\n  DCHECK(type);\n  DCHECK(count);\n  DCHECK(real_location);\n  if (!CheckCurrentProgramForUniform(fake_location, function_name)) {\n    return false;\n  }\n  GLint array_index = -1;\n  const Program::UniformInfo* info =\n      state_.current_program->GetUniformInfoByFakeLocation(\n          fake_location, real_location, &array_index);\n  if (!info) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION, function_name, \"unknown location\");\n    return false;\n  }\n  if (!CheckUniformForApiType(info, function_name, api_type)) {\n    return false;\n  }\n  if (*count > 1 && !info->is_array) {\n    LOCAL_SET_GL_ERROR(\n        GL_INVALID_OPERATION, function_name, \"count > 1 for non-array\");\n    return false;\n  }\n  *count = std::min(info->size - array_index, *count);\n  if (*count <= 0) {\n    return false;\n  }\n  *type = info->type;\n  return true;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":140847
  },
  {
    "code":"static int _nfs4_do_fsinfo(struct nfs_server *server, struct nfs_fh *fhandle,\n    struct nfs_fsinfo *fsinfo)\n{\n  struct nfs4_fsinfo_arg args = {\n    .fh = fhandle,\n    .bitmask = server->attr_bitmask,\n  };\n  struct rpc_message msg = {\n    .rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_FSINFO],\n    .rpc_argp = &args,\n    .rpc_resp = fsinfo,\n  };\n  return rpc_call_sync(server->client, &msg, 0);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":22833
  },
  {
    "code":"bool ResourceDispatcherHostImpl::IsRequestIDInUse(\n    const GlobalRequestID& id) const {\n  if (pending_loaders_.find(id) != pending_loaders_.end())\n    return true;\n  for (const auto& blocked_loaders : blocked_loaders_map_) {\n    for (const auto& loader : *blocked_loaders.second.get()) {\n      ResourceRequestInfoImpl* info = loader->GetRequestInfo();\n      if (info->GetGlobalRequestID() == id)\n        return true;\n    }\n  }\n  return false;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":164940
  },
  {
    "code":"bool PlatformSensorAmbientLightMac::ReadAndUpdate() {\n  uint32_t scalar_output_count = 2;\n  uint64_t lux_values[2];\n  kern_return_t kr = IOConnectCallMethod(\n      light_sensor_object_, LmuFunctionIndex::kGetSensorReadingID, nullptr, 0,\n      nullptr, 0, lux_values, &scalar_output_count, nullptr, 0);\n  if (kr != KERN_SUCCESS)\n    return false;\n  uint64_t mean = (lux_values[0] + lux_values[1]) \/ 2;\n  double lux = LMUvalueToLux(mean);\n  if (lux == current_lux_)\n    return true;\n  current_lux_ = lux;\n  SensorReading reading;\n  reading.als.timestamp =\n      (base::TimeTicks::Now() - base::TimeTicks()).InSecondsF();\n  reading.als.value = current_lux_;\n  UpdateSharedBufferAndNotifyClients(reading);\n  return true;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":161748
  },
  {
    "code":" buffer_extend(struct buffer_list *current)\n {\n struct buffer_list *add;\n   assert(current->next == NULL);\n   add = NEW(struct buffer_list);\n if (add == NULL)\n return NULL;\n   add->next = NULL;\n   current->next = add;\n return add;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":173006
  },
  {
    "code":"xfs_da_get_buf(\n  struct xfs_trans  *trans,\n  struct xfs_inode  *dp,\n  xfs_dablk_t    bno,\n  xfs_daddr_t    mappedbno,\n  struct xfs_buf    **bpp,\n  int      whichfork)\n{\n  struct xfs_buf    *bp;\n  struct xfs_buf_map  map;\n  struct xfs_buf_map  *mapp;\n  int      nmap;\n  int      error;\n  *bpp = NULL;\n  mapp = &map;\n  nmap = 1;\n  error = xfs_dabuf_map(trans, dp, bno, mappedbno, whichfork,\n        &mapp, &nmap);\n  if (error) {\n    if (error == -1)\n      error = 0;\n    goto out_free;\n  }\n  bp = xfs_trans_get_buf_map(trans, dp->i_mount->m_ddev_targp,\n            mapp, nmap, 0);\n  error = bp ? bp->b_error : XFS_ERROR(EIO);\n  if (error) {\n    xfs_trans_brelse(trans, bp);\n    goto out_free;\n  }\n  *bpp = bp;\nout_free:\n  if (mapp != &map)\n    kmem_free(mapp);\n  return error;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":35955
  },
  {
    "code":"void Document::setContextFeatures(PassRefPtr<ContextFeatures> features)\n{\n    m_contextFeatures = features;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":109807
  },
  {
    "code":"status_t Camera3Device::dump(int fd, const Vector<String16> &args) {\n    ATRACE_CALL();\n (void)args;\n bool gotInterfaceLock = tryLockSpinRightRound(mInterfaceLock);\n bool gotLock = tryLockSpinRightRound(mLock);\n    ALOGW_IF(!gotInterfaceLock,\n \"Camera %d: %s: Unable to lock interface lock, proceeding anyway\",\n            mId, __FUNCTION__);\n    ALOGW_IF(!gotLock,\n \"Camera %d: %s: Unable to lock main lock, proceeding anyway\",\n            mId, __FUNCTION__);\n String8 lines;\n const char *status =\n            mStatus == STATUS_ERROR         ? \"ERROR\" :\n            mStatus == STATUS_UNINITIALIZED ? \"UNINITIALIZED\" :\n            mStatus == STATUS_UNCONFIGURED  ? \"UNCONFIGURED\" :\n            mStatus == STATUS_CONFIGURED    ? \"CONFIGURED\" :\n            mStatus == STATUS_ACTIVE        ? \"ACTIVE\" :\n \"Unknown\";\n    lines.appendFormat(\"    Device status: %s\\n\", status);\n if (mStatus == STATUS_ERROR) {\n        lines.appendFormat(\"    Error cause: %s\\n\", mErrorCause.string());\n }\n    lines.appendFormat(\"    Stream configuration:\\n\");\n    lines.appendFormat(\"    Operation mode: %s \\n\", mIsConstrainedHighSpeedConfiguration ?\n \"CONSTRAINED HIGH SPEED VIDEO\" : \"NORMAL\");\n if (mInputStream != NULL) {\n        write(fd, lines.string(), lines.size());\n        mInputStream->dump(fd, args);\n } else {\n        lines.appendFormat(\"      No input stream.\\n\");\n        write(fd, lines.string(), lines.size());\n }\n for (size_t i = 0; i < mOutputStreams.size(); i++) {\n        mOutputStreams[i]->dump(fd,args);\n }\n    lines = String8(\"    In-flight requests:\\n\");\n if (mInFlightMap.size() == 0) {\n        lines.append(\"      None\\n\");\n } else {\n for (size_t i = 0; i < mInFlightMap.size(); i++) {\n InFlightRequest r = mInFlightMap.valueAt(i);\n            lines.appendFormat(\"      Frame %d |  Timestamp: %\" PRId64 \", metadata\"\n \" arrived: %s, buffers left: %d\\n\", mInFlightMap.keyAt(i),\n                    r.shutterTimestamp, r.haveResultMetadata ? \"true\" : \"false\",\n                    r.numBuffersLeft);\n }\n }\n    write(fd, lines.string(), lines.size());\n {\n        lines = String8(\"    Last request sent:\\n\");\n        write(fd, lines.string(), lines.size());\n CameraMetadata lastRequest = getLatestRequestLocked();\n        lastRequest.dump(fd, 2, 6);\n }\n if (mHal3Device != NULL) {\n        lines = String8(\"    HAL device dump:\\n\");\n        write(fd, lines.string(), lines.size());\n        mHal3Device->ops->dump(mHal3Device, fd);\n }\n if (gotLock) mLock.unlock();\n if (gotInterfaceLock) mInterfaceLock.unlock();\n return OK;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":174215
  },
  {
    "code":"void RenderWidgetHostImpl::ForwardWheelEvent(\n    const WebMouseWheelEvent& wheel_event) {\n  ForwardWheelEventWithLatencyInfo(wheel_event, ui::LatencyInfo());\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":143626
  },
  {
    "code":"xfs_attr3_rmt_blocks(\n  struct xfs_mount *mp,\n  int    attrlen)\n{\n  if (xfs_sb_version_hascrc(&mp->m_sb)) {\n    int buflen = XFS_ATTR3_RMT_BUF_SPACE(mp, mp->m_sb.sb_blocksize);\n    return (attrlen + buflen - 1) \/ buflen;\n  }\n  return XFS_B_TO_FSB(mp, attrlen);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":44967
  },
  {
    "code":"void HTMLInputElement::stepUp(int n, ExceptionState& exceptionState)\n{\n    m_inputType->stepUp(n, exceptionState);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":122371
  },
  {
    "code":"static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_esn,\n           struct nlattr *rp)\n{\n  struct xfrm_replay_state_esn *up;\n  if (!replay_esn || !rp)\n    return 0;\n  up = nla_data(rp);\n  if (xfrm_replay_state_esn_len(replay_esn) !=\n      xfrm_replay_state_esn_len(up))\n    return -EINVAL;\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":33168
  },
  {
    "code":"void WebProcessProxy::addMessageReceiver(CoreIPC::StringReference messageReceiverName, CoreIPC::MessageReceiver* messageReceiver)\n{\n    m_messageReceiverMap.addMessageReceiver(messageReceiverName, messageReceiver);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":113368
  },
  {
    "code":"    PassRefPtr<BlobDataHandle> getOrCreateBlobDataHandle(const String& uuid, const String& type, long long size = -1)\n    {\n        BlobDataHandleMap::const_iterator it = m_blobDataHandles.find(uuid);\n        if (it != m_blobDataHandles.end()) {\n            return it->value;\n        }\n        return BlobDataHandle::create(uuid, type, size);\n    }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":128949
  },
  {
    "code":"static void bubbleSort(double array[])\n{\n  for (int j = 0; j < 3; ++j) {\n    int kk = j;\n    for (int k = j + 1; k < 4; ++k) {\n      if (array[k] < array[kk]) {\n        kk = k;\n      }\n    }\n    double tmp = array[j];\n    array[j] = array[kk];\n    array[kk] = tmp;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":8068
  },
  {
    "code":"static int deviceprange(i_ctx_t * i_ctx_p, ref *space, float *ptr)\n{\n    int code;\n    ref tref;\n    code = array_get(imemory, space, 1, &tref);\n    if (code < 0)\n        return code;\n    ptr[0] = 0;\n    ptr[1] = (float)(1 << tref.value.intval);\n    return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":3074
  },
  {
    "code":"static int usage(int code)\n{\n  printf(\"Usage: %s [-dhv] [-i SEC] [IFACE [IFACE ...]]\\n\"\n         \"\\n\"\n         \"    -d        Developer debug mode\\n\"\n         \"    -h        This help text\\n\"\n         \"    -i SEC    SSDP notify interval (30-900), default %d sec\\n\"\n         \"    -r SEC    Interface refresh interval (5-1800), default %d sec\\n\"\n         \"    -v        Show program version\\n\"\n         \"\\n\"\n         \"Bug report address: %-40s\\n\", PACKAGE_NAME, NOTIFY_INTERVAL, REFRESH_INTERVAL, PACKAGE_BUGREPORT);\n  return code;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":88811
  },
  {
    "code":"void BrowserChildProcessHostImpl::RemoveObserver(\n    BrowserChildProcessObserver* observer) {\n  g_browser_child_process_observers.Get().RemoveObserver(observer);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":162037
  },
  {
    "code":"int register_socket(int in, int out, struct sockaddr *addr, struct sockaddr *mask, void (*cb)(int sd))\n{\n  struct ifsock *ifs;\n  struct sockaddr_in *address = (struct sockaddr_in *)addr;\n  struct sockaddr_in *netmask = (struct sockaddr_in *)mask;\n  ifs = calloc(1, sizeof(*ifs));\n  if (!ifs) {\n    char *host = inet_ntoa(address->sin_addr);\n    logit(LOG_ERR, \"Failed registering host %s socket: %s\", host, strerror(errno));\n    return -1;\n  }\n  ifs->in   = in;\n  ifs->out  = out;\n  ifs->mod  = 1;\n  ifs->cb   = cb;\n  ifs->addr = *address;\n  if (mask)\n    ifs->mask = *netmask;\n  LIST_INSERT_HEAD(&il, ifs, link);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":88805
  },
  {
    "code":"v8::Handle<v8::Value> V8WebGLRenderingContext::uniformMatrix4fvCallback(const v8::Arguments& args)\n{\n    INC_STATS(\"DOM.WebGLRenderingContext.uniformMatrix4fv()\");\n    return uniformMatrixHelper(args, 4);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":118049
  },
  {
    "code":"rad_config(struct rad_handle *h, const char *path)\n{\n  FILE *fp;\n  char buf[MAXCONFLINE];\n  int linenum;\n  int retval;\n  if (path == NULL)\n    path = PATH_RADIUS_CONF;\n  if ((fp = fopen(path, \"r\")) == NULL) {\n    generr(h, \"Cannot open \\\"%s\\\": %s\", path, strerror(errno));\n    return -1;\n  }\n  retval = 0;\n  linenum = 0;\n  while (fgets(buf, sizeof buf, fp) != NULL) {\n    int len;\n    char *fields[5];\n    int nfields;\n    char msg[ERRSIZE];\n    char *type;\n    char *host, *res;\n    char *port_str;\n    char *secret;\n    char *timeout_str;\n    char *maxtries_str;\n    char *end;\n    char *wanttype;\n    unsigned long timeout;\n    unsigned long maxtries;\n    int port;\n    int i;\n    linenum++;\n    len = strlen(buf);\n    if (buf[len - 1] != '\\n' && !(buf[len - 2] != '\\r' && buf[len - 1] != '\\n')) {\n      if (len == sizeof buf - 1)\n        generr(h, \"%s:%d: line too long\", path,\n            linenum);\n      else\n        generr(h, \"%s:%d: missing newline\", path,\n            linenum);\n      retval = -1;\n      break;\n    }\n    buf[len - 1] = '\\0';\n    nfields = split(buf, fields, 5, msg, sizeof msg);\n    if (nfields == -1) {\n      generr(h, \"%s:%d: %s\", path, linenum, msg);\n      retval = -1;\n      break;\n    }\n    if (nfields == 0)\n      continue;\n    if (strcmp(fields[0], \"auth\") != 0 &&\n        strcmp(fields[0], \"acct\") != 0) {\n      if (nfields >= 5) {\n        generr(h, \"%s:%d: invalid service type\", path,\n            linenum);\n        retval = -1;\n        break;\n      }\n      nfields++;\n      for (i = nfields;  --i > 0;  )\n        fields[i] = fields[i - 1];\n      fields[0] = \"auth\";\n    }\n    if (nfields < 3) {\n      generr(h, \"%s:%d: missing shared secret\", path,\n          linenum);\n      retval = -1;\n      break;\n    }\n    type = fields[0];\n    host = fields[1];\n    secret = fields[2];\n    timeout_str = fields[3];\n    maxtries_str = fields[4];\n    wanttype = h->type == RADIUS_AUTH ? \"auth\" : \"acct\";\n    if (strcmp(type, wanttype) != 0)\n      continue;\n    res = host;\n    host = strsep(&res, \":\");\n    port_str = strsep(&res, \":\");\n    if (port_str != NULL) {\n      port = strtoul(port_str, &end, 10);\n      if (*end != '\\0') {\n        generr(h, \"%s:%d: invalid port\", path,\n            linenum);\n        retval = -1;\n        break;\n      }\n    } else\n      port = 0;\n    if (timeout_str != NULL) {\n      timeout = strtoul(timeout_str, &end, 10);\n      if (*end != '\\0') {\n        generr(h, \"%s:%d: invalid timeout\", path,\n            linenum);\n        retval = -1;\n        break;\n      }\n    } else\n      timeout = TIMEOUT;\n    if (maxtries_str != NULL) {\n      maxtries = strtoul(maxtries_str, &end, 10);\n      if (*end != '\\0') {\n        generr(h, \"%s:%d: invalid maxtries\", path,\n            linenum);\n        retval = -1;\n        break;\n      }\n    } else\n      maxtries = MAXTRIES;\n    if (rad_add_server(h, host, port, secret, timeout, maxtries) ==\n        -1) {\n      strcpy(msg, h->errmsg);\n      generr(h, \"%s:%d: %s\", path, linenum, msg);\n      retval = -1;\n      break;\n    }\n  }\n  memset(buf, 0, sizeof buf);\n  fclose(fp);\n  return retval;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":31530
  },
  {
    "code":"  void OnWriteText(const std::string& text) { last_text_ = text; }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":148832
  },
  {
    "code":"error::Error GLES2DecoderImpl::HandleGetUniformfv(\n    uint32_t immediate_data_size,\n    const volatile void* cmd_data) {\n  const volatile gles2::cmds::GetUniformfv& c =\n      *static_cast<const volatile gles2::cmds::GetUniformfv*>(cmd_data);\n  GLuint program = c.program;\n  GLint fake_location = c.location;\n  GLuint service_id;\n  GLint real_location = -1;\n  Error error;\n  cmds::GetUniformfv::Result* result;\n  GLenum result_type;\n  GLsizei result_size;\n  if (GetUniformSetup<GLfloat>(program, fake_location, c.params_shm_id,\n                               c.params_shm_offset, &error, &real_location,\n                               &service_id, &result, &result_type,\n                               &result_size)) {\n    if (result_type == GL_BOOL || result_type == GL_BOOL_VEC2 ||\n        result_type == GL_BOOL_VEC3 || result_type == GL_BOOL_VEC4) {\n      GLsizei num_values = result_size \/ sizeof(GLfloat);\n      std::unique_ptr<GLint[]> temp(new GLint[num_values]);\n      api()->glGetUniformivFn(service_id, real_location, temp.get());\n      GLfloat* dst = result->GetData();\n      for (GLsizei ii = 0; ii < num_values; ++ii) {\n        dst[ii] = (temp[ii] != 0);\n      }\n    } else {\n      api()->glGetUniformfvFn(service_id, real_location, result->GetData());\n    }\n  }\n  return error;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":154249
  },
  {
    "code":"bool RendererSchedulerImpl::TaskQueuePolicy::IsQueueEnabled(\n    MainThreadTaskQueue* task_queue) const {\n  if (!is_enabled)\n    return false;\n  if (is_paused && task_queue->CanBePaused())\n    return false;\n  if (is_blocked && task_queue->CanBeDeferred())\n    return false;\n  if (is_stopped && task_queue->CanBeStopped())\n    return false;\n  return true;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":156215
  },
  {
    "code":"void OnGetFileInfoByResourceId(Profile* profile,\n                               const std::string& resource_id,\n                               base::PlatformFileError error,\n                               const FilePath& ,\n                               scoped_ptr<GDataFileProto> file_proto) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::UI));\n  if (error != base::PLATFORM_FILE_OK)\n    return;\n  DCHECK(file_proto.get());\n  const std::string& file_name = file_proto->gdata_entry().file_name();\n  const GURL edit_url = GetFileResourceUrl(resource_id, file_name);\n  OpenEditURLUIThread(profile, &edit_url);\n  DVLOG(1) << \"OnFindEntryByResourceId \" << edit_url;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":112939
  },
  {
    "code":"static int cmd_queue(struct ImapData *idata, const char *cmdstr, int flags)\n{\n  if (cmd_queue_full(idata))\n  {\n    mutt_debug(3, \"Draining IMAP command pipeline\\n\");\n    const int rc = imap_exec(idata, NULL, IMAP_CMD_FAIL_OK | (flags & IMAP_CMD_POLL));\n    if (rc < 0 && rc != -2)\n      return rc;\n  }\n  struct ImapCommand *cmd = cmd_new(idata);\n  if (!cmd)\n    return IMAP_CMD_BAD;\n  if (mutt_buffer_printf(idata->cmdbuf, \"%s %s\\r\\n\", cmd->seq, cmdstr) < 0)\n    return IMAP_CMD_BAD;\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":79562
  },
  {
    "code":"static struct multipath *alloc_multipath(struct dm_target *ti)\n{\n  struct multipath *m;\n  m = kzalloc(sizeof(*m), GFP_KERNEL);\n  if (m) {\n    INIT_LIST_HEAD(&m->priority_groups);\n    INIT_LIST_HEAD(&m->queued_ios);\n    spin_lock_init(&m->lock);\n    m->queue_io = 1;\n    m->pg_init_delay_msecs = DM_PG_INIT_DELAY_DEFAULT;\n    INIT_WORK(&m->process_queued_ios, process_queued_ios);\n    INIT_WORK(&m->trigger_event, trigger_event);\n    init_waitqueue_head(&m->pg_init_wait);\n    mutex_init(&m->work_mutex);\n    m->mpio_pool = mempool_create_slab_pool(MIN_IOS, _mpio_cache);\n    if (!m->mpio_pool) {\n      kfree(m);\n      return NULL;\n    }\n    m->ti = ti;\n    ti->private = m;\n  }\n  return m;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":23576
  },
  {
    "code":" int UnpackEntry(sqlite_utils::SQLStatement* statement, EntryKernel** kernel) {\n   *kernel = NULL;\n   int query_result = statement->step();\n  if (query_result == SQLITE_ROW) {\n    *kernel = new EntryKernel();\n    DCHECK_EQ(statement->column_count(), static_cast<int>(FIELD_COUNT));\n     int i = 0;\n     for (i = BEGIN_FIELDS; i < INT64_FIELDS_END; ++i) {\n       (*kernel)->put(static_cast<Int64Field>(i), statement->column_int64(i));\n     }\n    for ( ; i < TIME_FIELDS_END; ++i) {\n      (*kernel)->put(static_cast<TimeField>(i),\n                     browser_sync::ProtoTimeToTime(\n                         statement->column_int64(i)));\n    }\n     for ( ; i < ID_FIELDS_END; ++i) {\n       (*kernel)->mutable_ref(static_cast<IdField>(i)).s_ =\n           statement->column_string(i);\n    }\n    for ( ; i < BIT_FIELDS_END; ++i) {\n      (*kernel)->put(static_cast<BitField>(i), (0 != statement->column_int(i)));\n    }\n    for ( ; i < STRING_FIELDS_END; ++i) {\n      (*kernel)->put(static_cast<StringField>(i),\n          statement->column_string(i));\n    }\n    for ( ; i < PROTO_FIELDS_END; ++i) {\n       (*kernel)->mutable_ref(static_cast<ProtoField>(i)).ParseFromArray(\n           statement->column_blob(i), statement->column_bytes(i));\n     }\n   } else {\n    DCHECK_EQ(query_result, SQLITE_DONE);\n     (*kernel) = NULL;\n   }\n   return query_result;\n}\n",
    "vul":1,
    "flaw_line_no":[
      4,
      5,
      6,
      7,
      8,
      9,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      20,
      21,
      23,
      24,
      25,
      27,
      28,
      29,
      32,
      33
    ],
    "bigvul_id":183669
  },
  {
    "code":"void DataReductionProxySettings::SetCallbackToRegisterSyntheticFieldTrial(\n    const SyntheticFieldTrialRegistrationCallback&\n        on_data_reduction_proxy_enabled) {\n  register_synthetic_field_trial_ = on_data_reduction_proxy_enabled;\n   RegisterDataReductionProxyFieldTrial();\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":155517
  },
  {
    "code":"int simple_set_acl(struct inode *inode, struct posix_acl *acl, int type)\n{\n  int error;\n  if (type == ACL_TYPE_ACCESS) {\n    error = posix_acl_equiv_mode(acl, &inode->i_mode);\n    if (error < 0)\n      return 0;\n    if (error == 0)\n      acl = NULL;\n  }\n  inode->i_ctime = CURRENT_TIME;\n  set_cached_acl(inode, type, acl);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":50395
  },
  {
    "code":"static void merge_param(HashTable *params, zval *zdata, zval ***current_param, zval ***current_args TSRMLS_DC)\n{\n  zval **ptr, **zdata_ptr;\n  php_http_array_hashkey_t hkey = php_http_array_hashkey_init(0);\n#if 0\n  {\n    zval tmp;\n    INIT_PZVAL_ARRAY(&tmp, params);\n    fprintf(stderr, \"params = \");\n    zend_print_zval_r(&tmp, 1 TSRMLS_CC);\n    fprintf(stderr, \"\\n\");\n  }\n#endif\n  hkey.type = zend_hash_get_current_key_ex(Z_ARRVAL_P(zdata), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL);\n  if ((hkey.type == HASH_KEY_IS_STRING && !zend_hash_exists(params, hkey.str, hkey.len))\n  ||  (hkey.type == HASH_KEY_IS_LONG && !zend_hash_index_exists(params, hkey.num))\n  ) {\n    zval *tmp, *arg, **args;\n    zend_hash_get_current_data(Z_ARRVAL_P(zdata), (void *) &ptr);\n    Z_ADDREF_PP(ptr);\n    MAKE_STD_ZVAL(tmp);\n    array_init(tmp);\n    add_assoc_zval_ex(tmp, ZEND_STRS(\"value\"), *ptr);\n    MAKE_STD_ZVAL(arg);\n    array_init(arg);\n    zend_hash_update(Z_ARRVAL_P(tmp), \"arguments\", sizeof(\"arguments\"), (void *) &arg, sizeof(zval *), (void *) &args);\n    *current_args = args;\n    if (hkey.type == HASH_KEY_IS_STRING) {\n      zend_hash_update(params, hkey.str, hkey.len, (void *) &tmp, sizeof(zval *), (void *) &ptr);\n    } else {\n      zend_hash_index_update(params, hkey.num, (void *) &tmp, sizeof(zval *), (void *) &ptr);\n    }\n  } else {\n    if (hkey.type == HASH_KEY_IS_STRING) {\n      zend_hash_find(params, hkey.str, hkey.len, (void *) &ptr);\n    } else {\n      zend_hash_index_find(params, hkey.num, (void *) &ptr);\n    }\n    zdata_ptr = &zdata;\n    if (Z_TYPE_PP(ptr) == IS_ARRAY\n    &&  SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), \"value\", sizeof(\"value\"), (void *) &ptr)\n    &&  SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &zdata_ptr)\n    ) {\n      zval **test_ptr;\n       while (Z_TYPE_PP(zdata_ptr) == IS_ARRAY\n       &&  SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(zdata_ptr), (void *) &test_ptr)\n       ) {\n        if (Z_TYPE_PP(test_ptr) == IS_ARRAY) {\n           if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {\n            if (SUCCESS == zend_hash_find(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) &ptr)) {\n              zdata_ptr = test_ptr;\n            } else {\n              Z_ADDREF_PP(test_ptr);\n              zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n              break;\n            }\n          } else {\n            if (SUCCESS == zend_hash_index_find(Z_ARRVAL_PP(ptr), hkey.num, (void *) &ptr)) {\n              zdata_ptr = test_ptr;\n            } else if (hkey.num) {\n              Z_ADDREF_PP(test_ptr);\n              zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n              break;\n            } else {\n              Z_ADDREF_PP(test_ptr);\n              zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n              break;\n            }\n          }\n        } else {\n          Z_ADDREF_PP(test_ptr);\n          if (Z_TYPE_PP(ptr) != IS_ARRAY) {\n            zval_dtor(*ptr);\n            array_init(*ptr);\n          }\n          if (HASH_KEY_IS_STRING == zend_hash_get_current_key_ex(Z_ARRVAL_PP(zdata_ptr), &hkey.str, &hkey.len, &hkey.num, hkey.dup, NULL)) {\n            zend_hash_update(Z_ARRVAL_PP(ptr), hkey.str, hkey.len, (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n          } else if (hkey.num) {\n            zend_hash_index_update(Z_ARRVAL_PP(ptr), hkey.num, (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n          } else {\n            zend_hash_next_index_insert(Z_ARRVAL_PP(ptr), (void *) test_ptr, sizeof(zval *), (void *) &ptr);\n          }\n          break;\n        }\n      }\n    }\n  }\n  while (Z_TYPE_PP(ptr) == IS_ARRAY && SUCCESS == zend_hash_get_current_data(Z_ARRVAL_PP(ptr), (void *) &ptr));\n  *current_param = ptr;\n}\n",
    "vul":1,
    "flaw_line_no":[
      48
    ],
    "bigvul_id":183037
  },
  {
    "code":"media_status_t AMediaCodec_releaseOutputBufferAtTime(\n AMediaCodec *mData, size_t idx, int64_t timestampNs) {\n    ALOGV(\"render @ %\" PRId64, timestampNs);\n return translate_error(mData->mCodec->renderOutputBufferAndRelease(idx, timestampNs));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":176178
  },
  {
    "code":"config_tos(\n  config_tree *ptree\n  )\n{\n  attr_val *tos;\n  int item;\n  item = -1;  \n  tos = HEAD_PFIFO(ptree->orphan_cmds);\n  for (; tos != NULL; tos = tos->link) {\n    switch(tos->attr) {\n    default:\n      NTP_INSIST(0);\n      break;\n    case T_Ceiling:\n      item = PROTO_CEILING;\n      break;\n    case T_Floor:\n      item = PROTO_FLOOR;\n      break;\n    case T_Cohort:\n      item = PROTO_COHORT;\n      break;\n    case T_Orphan:\n      item = PROTO_ORPHAN;\n      break;\n    case T_Orphanwait:\n      item = PROTO_ORPHWAIT;\n      break;\n    case T_Mindist:\n      item = PROTO_MINDISP;\n      break;\n    case T_Maxdist:\n      item = PROTO_MAXDIST;\n      break;\n    case T_Minclock:\n      item = PROTO_MINCLOCK;\n      break;\n    case T_Maxclock:\n      item = PROTO_MAXCLOCK;\n      break;\n    case T_Minsane:\n      item = PROTO_MINSANE;\n      break;\n    case T_Beacon:\n      item = PROTO_BEACON;\n      break;\n    }\n    proto_config(item, 0, tos->value.d, NULL);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":74146
  },
  {
    "code":"gluster_compare_hosts(gluster_hostdef *src_server, gluster_hostdef *dst_server)\n{\n  if (src_server->type != dst_server->type)\n    return false;\n  switch (src_server->type) {\n    case GLUSTER_TRANSPORT_UNIX:\n      if (!strcmp(src_server->u.uds.socket, dst_server->u.uds.socket))\n        return true;\n      break;\n    case GLUSTER_TRANSPORT_TCP:\n    case GLUSTER_TRANSPORT_RDMA:\n      if (!strcmp(src_server->u.inet.addr, dst_server->u.inet.addr)\n          &&\n        !strcmp(src_server->u.inet.port, dst_server->u.inet.port))\n        return true;\n      break;\n    case GLUSTER_TRANSPORT__MAX:\n      break;\n  }\n    return false;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":59061
  },
  {
    "code":"int hidp_del_connection(struct hidp_conndel_req *req)\n{\n  struct hidp_session *session;\n  int err = 0;\n  BT_DBG(\"\");\n  down_read(&hidp_session_sem);\n  session = __hidp_get_session(&req->bdaddr);\n  if (session) {\n    if (req->flags & (1 << HIDP_VIRTUAL_CABLE_UNPLUG)) {\n      hidp_send_ctrl_message(session,\n        HIDP_TRANS_HID_CONTROL | HIDP_CTRL_VIRTUAL_CABLE_UNPLUG, NULL, 0);\n    } else {\n      skb_queue_purge(&session->ctrl_transmit);\n      skb_queue_purge(&session->intr_transmit);\n      atomic_inc(&session->terminate);\n      wake_up_process(session->task);\n    }\n  } else\n    err = -ENOENT;\n  up_read(&hidp_session_sem);\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":33728
  },
  {
    "code":"void RenderMessageFilter::OnOpenChannelToPpapiBroker(int routing_id,\n                                                     int request_id,\n                                                     const FilePath& path) {\n  plugin_service_->OpenChannelToPpapiBroker(\n      path, new OpenChannelToPpapiBrokerCallback(this, routing_id, request_id));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":125565
  },
  {
    "code":"int ecryptfs_set_f_namelen(long *namelen, long lower_namelen,\n         struct ecryptfs_mount_crypt_stat *mount_crypt_stat)\n{\n  struct blkcipher_desc desc;\n  struct mutex *tfm_mutex;\n  size_t cipher_blocksize;\n  int rc;\n  if (!(mount_crypt_stat->flags & ECRYPTFS_GLOBAL_ENCRYPT_FILENAMES)) {\n    (*namelen) = lower_namelen;\n    return 0;\n  }\n  rc = ecryptfs_get_tfm_and_mutex_for_cipher_name(&desc.tfm, &tfm_mutex,\n      mount_crypt_stat->global_default_fn_cipher_name);\n  if (unlikely(rc)) {\n    (*namelen) = 0;\n    return rc;\n  }\n  mutex_lock(tfm_mutex);\n  cipher_blocksize = crypto_blkcipher_blocksize(desc.tfm);\n  mutex_unlock(tfm_mutex);\n  if (lower_namelen == NAME_MAX\n      && (cipher_blocksize == 8 || cipher_blocksize == 16)) {\n    (*namelen) = ENC_NAME_MAX_BLOCKLEN_8_OR_16;\n    return 0;\n  }\n  (*namelen) = lower_namelen;\n  (*namelen) -= ECRYPTFS_FNEK_ENCRYPTED_FILENAME_PREFIX_SIZE;\n  (*namelen) = ecryptfs_max_decoded_size(*namelen) - 3;\n  (*namelen) -= ECRYPTFS_TAG_70_MAX_METADATA_SIZE;\n  (*namelen) -= ECRYPTFS_FILENAME_MIN_RANDOM_PREPEND_BYTES;\n  (*namelen) -= cipher_blocksize - 1;\n  if ((*namelen) < 0)\n    (*namelen) = 0;\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":45437
  },
  {
    "code":"pg_hypot(double x, double y)\n{\n  double    yx;\n  if (isinf(x) || isinf(y))\n    return get_float8_infinity();\n  if (isnan(x) || isnan(y))\n    return get_float8_nan();\n  x = fabs(x);\n  y = fabs(y);\n  if (x < y)\n  {\n    double    temp = x;\n    x = y;\n    y = temp;\n  }\n  if (y == 0.0)\n    return x;\n  yx = y \/ x;\n  return x * sqrt(1.0 + (yx * yx));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":38971
  },
  {
    "code":"static void GenerateCLAHEHistogram(const RectangleInfo *clahe_info,\n  const RectangleInfo *tile_info,const size_t number_bins,\n  const unsigned short *lut,const unsigned short *pixels,size_t *histogram)\n{\n  register const unsigned short\n    *p;\n  register ssize_t\n    i;\n  for (i=0; i < (ssize_t) number_bins; i++)\n    histogram[i]=0L;\n  p=pixels;\n  for (i=0; i < (ssize_t) tile_info->height; i++)\n  {\n    const unsigned short\n      *q;\n    q=p+tile_info->width;\n    while (p < q)\n      histogram[lut[*p++]]++;\n    q+=clahe_info->width;\n    p=q-tile_info->width;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":88998
  },
  {
    "code":"static int spacePop(xmlParserCtxtPtr ctxt) {\n int ret;\n if (ctxt->spaceNr <= 0) return(0);\n    ctxt->spaceNr--;\n if (ctxt->spaceNr > 0)\n  ctxt->space = &ctxt->spaceTab[ctxt->spaceNr - 1];\n else\n        ctxt->space = &ctxt->spaceTab[0];\n    ret = ctxt->spaceTab[ctxt->spaceNr];\n    ctxt->spaceTab[ctxt->spaceNr] = -1;\n return(ret);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":176549
  },
  {
    "code":"xps_parse_glyphs(xps_document *doc, const fz_matrix *ctm,\n    char *base_uri, xps_resource *dict, fz_xml *root)\n{\n  fz_xml *node;\n  char *fill_uri;\n  char *opacity_mask_uri;\n  char *bidi_level_att;\n  char *fill_att;\n  char *font_size_att;\n  char *font_uri_att;\n  char *origin_x_att;\n  char *origin_y_att;\n  char *is_sideways_att;\n  char *indices_att;\n  char *unicode_att;\n  char *style_att;\n  char *transform_att;\n  char *clip_att;\n  char *opacity_att;\n  char *opacity_mask_att;\n  char *navigate_uri_att;\n  fz_xml *transform_tag = NULL;\n  fz_xml *clip_tag = NULL;\n  fz_xml *fill_tag = NULL;\n  fz_xml *opacity_mask_tag = NULL;\n  char *fill_opacity_att = NULL;\n  xps_part *part;\n  fz_font *font;\n  char partname[1024];\n  char fakename[1024];\n  char *subfont;\n  float font_size = 10;\n  int subfontid = 0;\n  int is_sideways = 0;\n  int bidi_level = 0;\n  fz_text *text;\n  fz_rect area;\n  fz_matrix local_ctm = *ctm;\n  bidi_level_att = fz_xml_att(root, \"BidiLevel\");\n  fill_att = fz_xml_att(root, \"Fill\");\n  font_size_att = fz_xml_att(root, \"FontRenderingEmSize\");\n  font_uri_att = fz_xml_att(root, \"FontUri\");\n  origin_x_att = fz_xml_att(root, \"OriginX\");\n  origin_y_att = fz_xml_att(root, \"OriginY\");\n  is_sideways_att = fz_xml_att(root, \"IsSideways\");\n  indices_att = fz_xml_att(root, \"Indices\");\n  unicode_att = fz_xml_att(root, \"UnicodeString\");\n  style_att = fz_xml_att(root, \"StyleSimulations\");\n  transform_att = fz_xml_att(root, \"RenderTransform\");\n  clip_att = fz_xml_att(root, \"Clip\");\n  opacity_att = fz_xml_att(root, \"Opacity\");\n  opacity_mask_att = fz_xml_att(root, \"OpacityMask\");\n  navigate_uri_att = fz_xml_att(root, \"FixedPage.NavigateUri\");\n  for (node = fz_xml_down(root); node; node = fz_xml_next(node))\n  {\n    if (!strcmp(fz_xml_tag(node), \"Glyphs.RenderTransform\"))\n      transform_tag = fz_xml_down(node);\n    if (!strcmp(fz_xml_tag(node), \"Glyphs.OpacityMask\"))\n      opacity_mask_tag = fz_xml_down(node);\n    if (!strcmp(fz_xml_tag(node), \"Glyphs.Clip\"))\n      clip_tag = fz_xml_down(node);\n    if (!strcmp(fz_xml_tag(node), \"Glyphs.Fill\"))\n      fill_tag = fz_xml_down(node);\n  }\n  fill_uri = base_uri;\n  opacity_mask_uri = base_uri;\n  xps_resolve_resource_reference(doc, dict, &transform_att, &transform_tag, NULL);\n  xps_resolve_resource_reference(doc, dict, &clip_att, &clip_tag, NULL);\n  xps_resolve_resource_reference(doc, dict, &fill_att, &fill_tag, &fill_uri);\n  xps_resolve_resource_reference(doc, dict, &opacity_mask_att, &opacity_mask_tag, &opacity_mask_uri);\n  if (!font_size_att || !font_uri_att || !origin_x_att || !origin_y_att) {\n    fz_warn(doc->ctx, \"missing attributes in glyphs element\");\n    return;\n  }\n  if (!indices_att && !unicode_att)\n    return; \n  if (is_sideways_att)\n    is_sideways = !strcmp(is_sideways_att, \"true\");\n  if (bidi_level_att)\n    bidi_level = atoi(bidi_level_att);\n  xps_resolve_url(partname, base_uri, font_uri_att, sizeof partname);\n  subfont = strrchr(partname, '#');\n  if (subfont)\n  {\n    subfontid = atoi(subfont + 1);\n    *subfont = 0;\n  }\n  fz_strlcpy(fakename, partname, sizeof fakename);\n  if (style_att)\n  {\n    if (!strcmp(style_att, \"BoldSimulation\"))\n      fz_strlcat(fakename, \"#Bold\", sizeof fakename);\n    else if (!strcmp(style_att, \"ItalicSimulation\"))\n      fz_strlcat(fakename, \"#Italic\", sizeof fakename);\n    else if (!strcmp(style_att, \"BoldItalicSimulation\"))\n      fz_strlcat(fakename, \"#BoldItalic\", sizeof fakename);\n  }\n  font = xps_lookup_font(doc, fakename);\n  if (!font)\n  {\n    fz_try(doc->ctx)\n    {\n      part = xps_read_part(doc, partname);\n    }\n    fz_catch(doc->ctx)\n    {\n      fz_rethrow_if(doc->ctx, FZ_ERROR_TRYLATER);\n      fz_warn(doc->ctx, \"cannot find font resource part '%s'\", partname);\n      return;\n    }\n    if (strstr(part->name, \".odttf\"))\n      xps_deobfuscate_font_resource(doc, part);\n    if (strstr(part->name, \".ODTTF\"))\n      xps_deobfuscate_font_resource(doc, part);\n    fz_try(doc->ctx)\n    {\n      fz_buffer *buf = fz_new_buffer_from_data(doc->ctx, part->data, part->size);\n      font = fz_new_font_from_buffer(doc->ctx, NULL, buf, subfontid, 1);\n      fz_drop_buffer(doc->ctx, buf);\n    }\n    fz_catch(doc->ctx)\n    {\n      fz_rethrow_if(doc->ctx, FZ_ERROR_TRYLATER);\n      fz_warn(doc->ctx, \"cannot load font resource '%s'\", partname);\n      xps_free_part(doc, part);\n      return;\n    }\n    if (style_att)\n    {\n      font->ft_bold = !!strstr(style_att, \"Bold\");\n      font->ft_italic = !!strstr(style_att, \"Italic\");\n    }\n    xps_select_best_font_encoding(doc, font);\n    xps_insert_font(doc, fakename, font);\n    fz_free(doc->ctx, part->name);\n    fz_free(doc->ctx, part);\n  }\n  if (transform_att || transform_tag)\n  {\n    fz_matrix transform;\n    if (transform_att)\n      xps_parse_render_transform(doc, transform_att, &transform);\n    if (transform_tag)\n      xps_parse_matrix_transform(doc, transform_tag, &transform);\n    fz_concat(&local_ctm, &transform, &local_ctm);\n  }\n  if (clip_att || clip_tag)\n    xps_clip(doc, &local_ctm, dict, clip_att, clip_tag);\n  font_size = fz_atof(font_size_att);\n  text = xps_parse_glyphs_imp(doc, &local_ctm, font, font_size,\n      fz_atof(origin_x_att), fz_atof(origin_y_att),\n      is_sideways, bidi_level, indices_att, unicode_att);\n  fz_bound_text(doc->ctx, text, NULL, &local_ctm, &area);\n  if (navigate_uri_att)\n    xps_add_link(doc, &area, base_uri, navigate_uri_att);\n  xps_begin_opacity(doc, &local_ctm, &area, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);\n  if (fill_tag && !strcmp(fz_xml_tag(fill_tag), \"SolidColorBrush\"))\n  {\n    fill_opacity_att = fz_xml_att(fill_tag, \"Opacity\");\n    fill_att = fz_xml_att(fill_tag, \"Color\");\n    fill_tag = NULL;\n  }\n        if (fill_att)\n        {\n               float samples[32];\n                fz_colorspace *colorspace;\n                xps_parse_color(doc, base_uri, fill_att, &colorspace, samples);\n    if (fill_opacity_att)\n      samples[0] *= fz_atof(fill_opacity_att);\n    xps_set_color(doc, colorspace, samples);\n    fz_fill_text(doc->dev, text, &local_ctm,\n      doc->colorspace, doc->color, doc->alpha);\n  }\n  if (fill_tag)\n  {\n    fz_clip_text(doc->dev, text, &local_ctm, 0);\n    xps_parse_brush(doc, &local_ctm, &area, fill_uri, dict, fill_tag);\n    fz_pop_clip(doc->dev);\n  }\n  xps_end_opacity(doc, opacity_mask_uri, dict, opacity_att, opacity_mask_tag);\n  fz_free_text(doc->ctx, text);\n  if (clip_att || clip_tag)\n    fz_pop_clip(doc->dev);\n  fz_drop_font(doc->ctx, font);\n}\n",
    "vul":1,
    "flaw_line_no":[
      165
    ],
    "bigvul_id":178401
  },
  {
    "code":"attr_writer(mrb_state *mrb, mrb_value obj)\n{\n  mrb_value name = mrb_proc_cfunc_env_get(mrb, 0);\n  mrb_value val;\n  mrb_get_args(mrb, \"o\", &val);\n  mrb_iv_set(mrb, obj, to_sym(mrb, name), val);\n  return val;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":82039
  },
  {
    "code":"void snd_timer_notify(struct snd_timer *timer, int event, struct timespec *tstamp)\n{\n  unsigned long flags;\n  unsigned long resolution = 0;\n  struct snd_timer_instance *ti, *ts;\n  if (timer->card && timer->card->shutdown)\n    return;\n  if (! (timer->hw.flags & SNDRV_TIMER_HW_SLAVE))\n    return;\n  if (snd_BUG_ON(event < SNDRV_TIMER_EVENT_MSTART ||\n           event > SNDRV_TIMER_EVENT_MRESUME))\n    return;\n  spin_lock_irqsave(&timer->lock, flags);\n  if (event == SNDRV_TIMER_EVENT_MSTART ||\n      event == SNDRV_TIMER_EVENT_MCONTINUE ||\n      event == SNDRV_TIMER_EVENT_MRESUME) {\n    if (timer->hw.c_resolution)\n      resolution = timer->hw.c_resolution(timer);\n    else\n      resolution = timer->hw.resolution;\n  }\n  list_for_each_entry(ti, &timer->active_list_head, active_list) {\n    if (ti->ccallback)\n      ti->ccallback(ti, event, tstamp, resolution);\n    list_for_each_entry(ts, &ti->slave_active_head, active_list)\n      if (ts->ccallback)\n        ts->ccallback(ts, event, tstamp, resolution);\n  }\n  spin_unlock_irqrestore(&timer->lock, flags);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":52700
  },
  {
    "code":"void CCThreadProxy::setThread(CCThread* ccThread)\n{\n    s_ccThread = ccThread;\n#ifndef NDEBUG\n    CCProxy::setImplThread(s_ccThread->threadID());\n#endif\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":102729
  },
  {
    "code":"static bool ldm_parse_tocblock (const u8 *data, struct tocblock *toc)\n{\n  BUG_ON (!data || !toc);\n  if (MAGIC_TOCBLOCK != get_unaligned_be64(data)) {\n    ldm_crit (\"Cannot find TOCBLOCK, database may be corrupt.\");\n    return false;\n  }\n  strncpy (toc->bitmap1_name, data + 0x24, sizeof (toc->bitmap1_name));\n  toc->bitmap1_name[sizeof (toc->bitmap1_name) - 1] = 0;\n  toc->bitmap1_start = get_unaligned_be64(data + 0x2E);\n  toc->bitmap1_size  = get_unaligned_be64(data + 0x36);\n  if (strncmp (toc->bitmap1_name, TOC_BITMAP1,\n      sizeof (toc->bitmap1_name)) != 0) {\n    ldm_crit (\"TOCBLOCK's first bitmap is '%s', should be '%s'.\",\n        TOC_BITMAP1, toc->bitmap1_name);\n    return false;\n  }\n  strncpy (toc->bitmap2_name, data + 0x46, sizeof (toc->bitmap2_name));\n  toc->bitmap2_name[sizeof (toc->bitmap2_name) - 1] = 0;\n  toc->bitmap2_start = get_unaligned_be64(data + 0x50);\n  toc->bitmap2_size  = get_unaligned_be64(data + 0x58);\n  if (strncmp (toc->bitmap2_name, TOC_BITMAP2,\n      sizeof (toc->bitmap2_name)) != 0) {\n    ldm_crit (\"TOCBLOCK's second bitmap is '%s', should be '%s'.\",\n        TOC_BITMAP2, toc->bitmap2_name);\n    return false;\n  }\n  ldm_debug (\"Parsed TOCBLOCK successfully.\");\n  return true;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":27324
  },
  {
    "code":"daemon_msg_open_req(uint8 ver, struct daemon_slpars *pars, uint32 plen,\n    char *source, size_t sourcelen)\n{\n  char errbuf[PCAP_ERRBUF_SIZE];    \n  char errmsgbuf[PCAP_ERRBUF_SIZE];  \n  pcap_t *fp;        \n  int nread;\n  char sendbuf[RPCAP_NETBUF_SIZE];  \n  int sendbufidx = 0;      \n  struct rpcap_openreply *openreply;  \n  if (plen > sourcelen - 1)\n  {\n    pcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string too long\");\n    goto error;\n  }\n  nread = sock_recv(pars->sockctrl, source, plen,\n      SOCK_RECEIVEALL_YES|SOCK_EOF_IS_ERROR, errbuf, PCAP_ERRBUF_SIZE);\n  if (nread == -1)\n  {\n    rpcapd_log(LOGPRIO_ERROR, \"Read from client failed: %s\", errbuf);\n    return -1;\n  }\n  source[nread] = '\\0';\n  plen -= nread;\n  if (is_url(source))\n  {\n    pcap_snprintf(errmsgbuf, PCAP_ERRBUF_SIZE, \"Source string refers to a remote device\");\n    goto error;\n  }\n  if ((fp = pcap_open_live(source,\n      1500 ,\n      0 ,\n      1000 ,\n      errmsgbuf)) == NULL)\n    goto error;\n  if (sock_bufferize(NULL, sizeof(struct rpcap_header), NULL, &sendbufidx,\n      RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n    goto error;\n  rpcap_createhdr((struct rpcap_header *) sendbuf, ver,\n      RPCAP_MSG_OPEN_REPLY, 0, sizeof(struct rpcap_openreply));\n  openreply = (struct rpcap_openreply *) &sendbuf[sendbufidx];\n  if (sock_bufferize(NULL, sizeof(struct rpcap_openreply), NULL, &sendbufidx,\n      RPCAP_NETBUF_SIZE, SOCKBUF_CHECKONLY, errmsgbuf, PCAP_ERRBUF_SIZE) == -1)\n    goto error;\n  memset(openreply, 0, sizeof(struct rpcap_openreply));\n  openreply->linktype = htonl(pcap_datalink(fp));\n  openreply->tzoff = 0; \n  pcap_close(fp);\n  if (sock_send(pars->sockctrl, sendbuf, sendbufidx, errbuf, PCAP_ERRBUF_SIZE) == -1)\n  {\n    rpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n    return -1;\n  }\n  return 0;\nerror:\n  if (rpcap_senderror(pars->sockctrl, ver, PCAP_ERR_OPEN,\n      errmsgbuf, errbuf) == -1)\n  {\n    rpcapd_log(LOGPRIO_ERROR, \"Send to client failed: %s\", errbuf);\n    return -1;\n  }\n  if (rpcapd_discard(pars->sockctrl, plen) == -1)\n  {\n    return -1;\n  }\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":88428
  },
  {
    "code":"void Job::OnError(int line_number, const base::string16& error) {\n  HandleAlertOrError(false, line_number, error);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":143383
  },
  {
    "code":"static void __netdev_adjacent_dev_unlink_lists(struct net_device *dev,\n                 struct net_device *upper_dev,\n                 struct list_head *up_list,\n                 struct list_head *down_list)\n{\n  __netdev_adjacent_dev_remove(dev, upper_dev, up_list);\n  __netdev_adjacent_dev_remove(upper_dev, dev, down_list);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":48752
  },
  {
    "code":"void WebPluginImpl::ShowModalHTMLDialog(const GURL& url, int width, int height,\n                                        const std::string& json_arguments,\n                                        std::string* json_retval) {\n  if (page_delegate_) {\n    page_delegate_->ShowModalHTMLDialogForPlugin(\n        url, gfx::Size(width, height), json_arguments, json_retval);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":100005
  },
  {
    "code":"pch_suffix_context (void)\n{\n    return p_suffix_context;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":2709
  },
  {
    "code":"static unsigned long ptrace_get_debugreg(struct task_struct *tsk, int n)\n{\n  struct thread_struct *thread = &(tsk->thread);\n  unsigned long val = 0;\n  if (n < HBP_NUM) {\n    struct perf_event *bp;\n    if (ptrace_get_breakpoints(tsk) < 0)\n      return -ESRCH;\n    bp = thread->ptrace_bps[n];\n    if (!bp)\n      val = 0;\n    else\n      val = bp->hw.info.address;\n    ptrace_put_breakpoints(tsk);\n  } else if (n == 6) {\n    val = thread->debugreg6;\n   } else if (n == 7) {\n    val = thread->ptrace_dr7;\n  }\n  return val;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":25905
  },
  {
    "code":"void Document::pageSizeAndMarginsInPixels(int pageIndex, IntSize& pageSize, int& marginTop, int& marginRight, int& marginBottom, int& marginLeft)\n{\n    RefPtr<ComputedStyle> style = styleForPage(pageIndex);\n    int width = pageSize.width();\n    int height = pageSize.height();\n    switch (style->pageSizeType()) {\n    case PAGE_SIZE_AUTO:\n        break;\n    case PAGE_SIZE_AUTO_LANDSCAPE:\n        if (width < height)\n            std::swap(width, height);\n        break;\n    case PAGE_SIZE_AUTO_PORTRAIT:\n        if (width > height)\n            std::swap(width, height);\n        break;\n    case PAGE_SIZE_RESOLVED: {\n        FloatSize size = style->pageSize();\n        width = size.width();\n        height = size.height();\n        break;\n    }\n    default:\n        ASSERT_NOT_REACHED();\n    }\n    pageSize = IntSize(width, height);\n    marginTop = style->marginTop().isAuto() ? marginTop : intValueForLength(style->marginTop(), width);\n    marginRight = style->marginRight().isAuto() ? marginRight : intValueForLength(style->marginRight(), width);\n    marginBottom = style->marginBottom().isAuto() ? marginBottom : intValueForLength(style->marginBottom(), width);\n    marginLeft = style->marginLeft().isAuto() ? marginLeft : intValueForLength(style->marginLeft(), width);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":135319
  },
  {
    "code":"void SVGElement::AddedEventListener(\n    const AtomicString& event_type,\n    RegisteredEventListener& registered_listener) {\n  Node::AddedEventListener(event_type, registered_listener);\n  HeapHashSet<WeakMember<SVGElement>> instances;\n  CollectInstancesForSVGElement(this, instances);\n  AddEventListenerOptionsResolved* options = registered_listener.Options();\n  EventListener* listener = registered_listener.Callback();\n  for (SVGElement* element : instances) {\n    bool result =\n        element->Node::AddEventListenerInternal(event_type, listener, options);\n    DCHECK(result);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":165764
  },
  {
    "code":"void dumpInnerHTML(WebCore::HTMLElement* element)\n{\n    printf(\"%s\\n\", element->innerHTML().ascii().data());\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":105243
  },
  {
    "code":"  RelayTruncate(const FilePath& path,\n                int64 length,\n                base::FileUtilProxy::StatusCallback* callback)\n      : RelayWithStatusCallback(callback),\n        path_(path),\n        length_(length) {\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":102532
  },
  {
    "code":"nfs4_proc_layoutcommit(struct nfs4_layoutcommit_data *data, bool sync)\n{\n  struct rpc_message msg = {\n    .rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_LAYOUTCOMMIT],\n    .rpc_argp = &data->args,\n    .rpc_resp = &data->res,\n    .rpc_cred = data->cred,\n  };\n  struct rpc_task_setup task_setup_data = {\n    .task = &data->task,\n    .rpc_client = NFS_CLIENT(data->args.inode),\n    .rpc_message = &msg,\n    .callback_ops = &nfs4_layoutcommit_ops,\n    .callback_data = data,\n  };\n  struct rpc_task *task;\n  int status = 0;\n  dprintk(\"NFS: initiating layoutcommit call. sync %d \"\n    \"lbw: %llu inode %lu\\n\", sync,\n    data->args.lastbytewritten,\n    data->args.inode->i_ino);\n  if (!sync) {\n    data->inode = nfs_igrab_and_active(data->args.inode);\n    if (data->inode == NULL) {\n      nfs4_layoutcommit_release(data);\n      return -EAGAIN;\n    }\n    task_setup_data.flags = RPC_TASK_ASYNC;\n  }\n  nfs4_init_sequence(&data->args.seq_args, &data->res.seq_res, 1);\n  task = rpc_run_task(&task_setup_data);\n  if (IS_ERR(task))\n    return PTR_ERR(task);\n  if (sync)\n    status = task->tk_status;\n  trace_nfs4_layoutcommit(data->args.inode, status);\n  dprintk(\"%s: status %d\\n\", __func__, status);\n  rpc_put_task(task);\n  return status;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":57197
  },
  {
    "code":"xfs_log_dinode_to_disk(\n  struct xfs_log_dinode  *from,\n  struct xfs_dinode  *to)\n{\n  to->di_magic = cpu_to_be16(from->di_magic);\n  to->di_mode = cpu_to_be16(from->di_mode);\n  to->di_version = from->di_version;\n  to->di_format = from->di_format;\n  to->di_onlink = 0;\n  to->di_uid = cpu_to_be32(from->di_uid);\n  to->di_gid = cpu_to_be32(from->di_gid);\n  to->di_nlink = cpu_to_be32(from->di_nlink);\n  to->di_projid_lo = cpu_to_be16(from->di_projid_lo);\n  to->di_projid_hi = cpu_to_be16(from->di_projid_hi);\n  memcpy(to->di_pad, from->di_pad, sizeof(to->di_pad));\n  to->di_atime.t_sec = cpu_to_be32(from->di_atime.t_sec);\n  to->di_atime.t_nsec = cpu_to_be32(from->di_atime.t_nsec);\n  to->di_mtime.t_sec = cpu_to_be32(from->di_mtime.t_sec);\n  to->di_mtime.t_nsec = cpu_to_be32(from->di_mtime.t_nsec);\n  to->di_ctime.t_sec = cpu_to_be32(from->di_ctime.t_sec);\n  to->di_ctime.t_nsec = cpu_to_be32(from->di_ctime.t_nsec);\n  to->di_size = cpu_to_be64(from->di_size);\n  to->di_nblocks = cpu_to_be64(from->di_nblocks);\n  to->di_extsize = cpu_to_be32(from->di_extsize);\n  to->di_nextents = cpu_to_be32(from->di_nextents);\n  to->di_anextents = cpu_to_be16(from->di_anextents);\n  to->di_forkoff = from->di_forkoff;\n  to->di_aformat = from->di_aformat;\n  to->di_dmevmask = cpu_to_be32(from->di_dmevmask);\n  to->di_dmstate = cpu_to_be16(from->di_dmstate);\n  to->di_flags = cpu_to_be16(from->di_flags);\n  to->di_gen = cpu_to_be32(from->di_gen);\n  if (from->di_version == 3) {\n    to->di_changecount = cpu_to_be64(from->di_changecount);\n    to->di_crtime.t_sec = cpu_to_be32(from->di_crtime.t_sec);\n    to->di_crtime.t_nsec = cpu_to_be32(from->di_crtime.t_nsec);\n    to->di_flags2 = cpu_to_be64(from->di_flags2);\n    to->di_cowextsize = cpu_to_be32(from->di_cowextsize);\n    to->di_ino = cpu_to_be64(from->di_ino);\n    to->di_lsn = cpu_to_be64(from->di_lsn);\n    memcpy(to->di_pad2, from->di_pad2, sizeof(to->di_pad2));\n    uuid_copy(&to->di_uuid, &from->di_uuid);\n    to->di_flushiter = 0;\n  } else {\n    to->di_flushiter = cpu_to_be16(from->di_flushiter);\n   }\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":79906
  },
  {
    "code":"SMB2_set_compression(const unsigned int xid, struct cifs_tcon *tcon,\n         u64 persistent_fid, u64 volatile_fid)\n{\n  int rc;\n  struct  compress_ioctl fsctl_input;\n  char *ret_data = NULL;\n  fsctl_input.CompressionState =\n      cpu_to_le16(COMPRESSION_FORMAT_DEFAULT);\n  rc = SMB2_ioctl(xid, tcon, persistent_fid, volatile_fid,\n      FSCTL_SET_COMPRESSION, true ,\n      (char *)&fsctl_input ,\n      2 , CIFSMaxBufSize ,\n      &ret_data , NULL);\n  cifs_dbg(FYI, \"set compression rc %d\\n\", rc);\n  return rc;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":88096
  },
  {
    "code":"  TestCase& EnableMyFilesVolume() {\n    enable_myfiles_volume.emplace(true);\n    return *this;\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":142379
  },
  {
    "code":"void OutOfProcessInstance::FillRect(const pp::Rect& rect, uint32 color) {\n  DCHECK(!image_data_.is_null() || rect.IsEmpty());\n  uint32* buffer_start = static_cast<uint32*>(image_data_.data());\n  int stride = image_data_.stride();\n  uint32* ptr = buffer_start + rect.y() * stride \/ 4 + rect.x();\n  int height = rect.height();\n  int width = rect.width();\n  for (int y = 0; y < height; ++y) {\n    for (int x = 0; x < width; ++x)\n      *(ptr + x) = color;\n    ptr += stride \/4;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":140612
  },
  {
    "code":"XML_ParseBuffer(XML_Parser parser, int len, int isFinal)\n{\n  const char *start;\n  enum XML_Status result = XML_STATUS_OK;\n  if (parser == NULL)\n    return XML_STATUS_ERROR;\n  switch (parser->m_parsingStatus.parsing) {\n  case XML_SUSPENDED:\n    parser->m_errorCode = XML_ERROR_SUSPENDED;\n    return XML_STATUS_ERROR;\n  case XML_FINISHED:\n    parser->m_errorCode = XML_ERROR_FINISHED;\n    return XML_STATUS_ERROR;\n  case XML_INITIALIZED:\n    if (parser->m_parentParser == NULL && !startParsing(parser)) {\n      parser->m_errorCode = XML_ERROR_NO_MEMORY;\n      return XML_STATUS_ERROR;\n    }\n  default:\n    parser->m_parsingStatus.parsing = XML_PARSING;\n  }\n  start = parser->m_bufferPtr;\n  parser->m_positionPtr = start;\n  parser->m_bufferEnd += len;\n  parser->m_parseEndPtr = parser->m_bufferEnd;\n  parser->m_parseEndByteIndex += len;\n  parser->m_parsingStatus.finalBuffer = (XML_Bool)isFinal;\n  parser->m_errorCode = parser->m_processor(parser, start, parser->m_parseEndPtr, &parser->m_bufferPtr);\n  if (parser->m_errorCode != XML_ERROR_NONE) {\n    parser->m_eventEndPtr = parser->m_eventPtr;\n    parser->m_processor = errorProcessor;\n    return XML_STATUS_ERROR;\n  }\n  else {\n    switch (parser->m_parsingStatus.parsing) {\n    case XML_SUSPENDED:\n      result = XML_STATUS_SUSPENDED;\n      break;\n    case XML_INITIALIZED:\n    case XML_PARSING:\n      if (isFinal) {\n        parser->m_parsingStatus.parsing = XML_FINISHED;\n        return result;\n      }\n    default: ;  \n    }\n  }\n  XmlUpdatePosition(parser->m_encoding, parser->m_positionPtr, parser->m_bufferPtr, &parser->m_position);\n  parser->m_positionPtr = parser->m_bufferPtr;\n  return result;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":92260
  },
  {
    "code":"void RTCPeerConnectionHandler::OnRemoveReceiverPlanB(uintptr_t receiver_id) {\n  DCHECK(task_runner_->RunsTasksInCurrentSequence());\n  TRACE_EVENT0(\"webrtc\", \"RTCPeerConnectionHandler::OnRemoveReceiverPlanB\");\n  auto it = FindReceiver(receiver_id);\n  DCHECK(it != rtp_receivers_.end());\n  auto receiver = std::make_unique<RTCRtpReceiver>(*(*it));\n  track_metrics_.RemoveTrack(MediaStreamTrackMetrics::Direction::kReceive,\n                             MediaStreamTrackMetricsKind(receiver->Track()),\n                             receiver->Track().Id().Utf8());\n  if (peer_connection_tracker_) {\n    auto receiver_only_transceiver =\n        std::make_unique<RTCRtpReceiverOnlyTransceiver>(\n            std::make_unique<RTCRtpReceiver>(*receiver));\n    size_t receiver_index = GetTransceiverIndex(*receiver_only_transceiver);\n    peer_connection_tracker_->TrackRemoveTransceiver(\n        this,\n        PeerConnectionTracker::TransceiverUpdatedReason::kSetRemoteDescription,\n        *receiver_only_transceiver.get(), receiver_index);\n  }\n  rtp_receivers_.erase(it);\n  for (const auto& stream_id : receiver->state().stream_ids()) {\n    if (!IsRemoteStream(rtp_receivers_, stream_id))\n      PerSessionWebRTCAPIMetrics::GetInstance()->IncrementStreamCounter();\n  }\n  if (!is_closed_)\n    client_->DidRemoveReceiverPlanB(std::move(receiver));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":166010
  },
  {
    "code":"IntSize WebPagePrivate::mapFromTransformed(const IntSize& size) const\n{\n    return mapFromTransformed(IntRect(IntPoint::zero(), size)).size();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":111210
  },
  {
    "code":"static void nfs_zap_caches_locked(struct inode *inode)\n{\n  struct nfs_inode *nfsi = NFS_I(inode);\n  int mode = inode->i_mode;\n  nfs_inc_stats(inode, NFSIOS_ATTRINVALIDATE);\n  nfsi->attrtimeo = NFS_MINATTRTIMEO(inode);\n  nfsi->attrtimeo_timestamp = jiffies;\n  memset(NFS_COOKIEVERF(inode), 0, sizeof(NFS_COOKIEVERF(inode)));\n  if (S_ISREG(mode) || S_ISDIR(mode) || S_ISLNK(mode))\n    nfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_DATA|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;\n  else\n    nfsi->cache_validity |= NFS_INO_INVALID_ATTR|NFS_INO_INVALID_ACCESS|NFS_INO_INVALID_ACL|NFS_INO_REVAL_PAGECACHE;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":22825
  },
  {
    "code":"int AXLayoutObject::textLength() const {\n  if (!isTextControl())\n    return -1;\n  return text().length();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":137995
  },
  {
    "code":"xfs_inode_ag_iterator(\n  struct xfs_mount  *mp,\n  int      (*execute)(struct xfs_inode *ip, int flags,\n             void *args),\n  int      flags,\n  void      *args)\n{\n  return xfs_inode_ag_iterator_flags(mp, execute, flags, args, 0);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":79954
  },
  {
    "code":"  UpdatePersistentHostQuotaTask(\n      QuotaManager* manager,\n      const std::string& host,\n      int new_quota,\n      HostQuotaCallback* callback)\n      : DatabaseTaskBase(manager),\n        host_(host),\n        new_quota_(new_quota),\n        callback_(callback) {\n    DCHECK_GE(new_quota_, 0);\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":101060
  },
  {
    "code":"smb2_echo_callback(struct mid_q_entry *mid)\n{\n  struct TCP_Server_Info *server = mid->callback_data;\n  struct smb2_echo_rsp *smb2 = (struct smb2_echo_rsp *)mid->resp_buf;\n  unsigned int credits_received = 1;\n  if (mid->mid_state == MID_RESPONSE_RECEIVED)\n    credits_received = le16_to_cpu(smb2->hdr.CreditRequest);\n  DeleteMidQEntry(mid);\n  add_credits(server, credits_received, CIFS_ECHO_OP);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":36007
  },
  {
    "code":"uint8_t* AMediaCodec_getOutputBuffer(AMediaCodec *mData, size_t idx, size_t *out_size) {\n if (mData->mAsyncNotify != NULL) {\n        sp<MediaCodecBuffer> abuf;\n if (mData->mCodec->getOutputBuffer(idx, &abuf) != 0) {\n return NULL;\n }\n if (out_size != NULL) {\n *out_size = abuf->capacity();\n }\n return abuf->data();\n }\n    android::Vector<android::sp<android::MediaCodecBuffer> > abufs;\n if (mData->mCodec->getOutputBuffers(&abufs) == 0) {\n size_t n = abufs.size();\n if (idx >= n) {\n            ALOGE(\"buffer index %zu out of range\", idx);\n return NULL;\n }\n if (out_size != NULL) {\n *out_size = abufs[idx]->capacity();\n }\n return abufs[idx]->data();\n }\n    ALOGE(\"couldn't get output buffers\");\n return NULL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":176171
  },
  {
    "code":"  explicit ProbablySameFilterMatcher(\n      const base::Callback<bool(const GURL&)>& filter)\n      : to_match_(filter) {\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":167361
  },
  {
    "code":"static int handle_invvpid(struct kvm_vcpu *vcpu)\n{\n  struct vcpu_vmx *vmx = to_vmx(vcpu);\n  u32 vmx_instruction_info;\n  unsigned long type, types;\n  gva_t gva;\n  struct x86_exception e;\n  int vpid;\n  if (!(vmx->nested.nested_vmx_secondary_ctls_high &\n        SECONDARY_EXEC_ENABLE_VPID) ||\n      !(vmx->nested.nested_vmx_vpid_caps & VMX_VPID_INVVPID_BIT)) {\n    kvm_queue_exception(vcpu, UD_VECTOR);\n    return 1;\n  }\n  if (!nested_vmx_check_permission(vcpu))\n    return 1;\n  vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);\n  type = kvm_register_readl(vcpu, (vmx_instruction_info >> 28) & 0xf);\n  types = (vmx->nested.nested_vmx_vpid_caps &\n      VMX_VPID_EXTENT_SUPPORTED_MASK) >> 8;\n  if (type >= 32 || !(types & (1 << type))) {\n    nested_vmx_failValid(vcpu,\n      VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n    return kvm_skip_emulated_instruction(vcpu);\n  }\n  if (get_vmx_mem_address(vcpu, vmcs_readl(EXIT_QUALIFICATION),\n      vmx_instruction_info, false, &gva))\n    return 1;\n  if (kvm_read_guest_virt(&vcpu->arch.emulate_ctxt, gva, &vpid,\n        sizeof(u32), &e)) {\n    kvm_inject_page_fault(vcpu, &e);\n    return 1;\n  }\n  switch (type) {\n  case VMX_VPID_EXTENT_INDIVIDUAL_ADDR:\n  case VMX_VPID_EXTENT_SINGLE_CONTEXT:\n  case VMX_VPID_EXTENT_SINGLE_NON_GLOBAL:\n    if (!vpid) {\n      nested_vmx_failValid(vcpu,\n        VMXERR_INVALID_OPERAND_TO_INVEPT_INVVPID);\n      return kvm_skip_emulated_instruction(vcpu);\n    }\n    break;\n  case VMX_VPID_EXTENT_ALL_CONTEXT:\n    break;\n  default:\n    WARN_ON_ONCE(1);\n    return kvm_skip_emulated_instruction(vcpu);\n  }\n  __vmx_flush_tlb(vcpu, vmx->nested.vpid02);\n  nested_vmx_succeed(vcpu);\n  return kvm_skip_emulated_instruction(vcpu);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":48031
  },
  {
    "code":"device_filesystem_list_open_files_authorized_cb (Daemon *daemon,\n                                                 Device *device,\n                                                 DBusGMethodInvocation *context,\n                                                 const gchar *action_id,\n                                                 guint num_user_data,\n                                                 gpointer *user_data_elements)\n{\n  int n;\n  char *argv[16];\n  GError *error;\n  if (!device->priv->device_is_mounted || device->priv->device_mount_paths->len == 0)\n    {\n      throw_error (context, ERROR_FAILED, \"Device is not mounted\");\n      goto out;\n    }\n  n = 0;\n  argv[n++] = \"lsof\";\n  argv[n++] = \"-t\";\n  argv[n++] = ((gchar **) device->priv->device_mount_paths->pdata)[0];\n  argv[n++] = NULL;\n  error = NULL;\n  if (!job_new (context, NULL, \n                FALSE, device, argv, NULL, filesystem_list_open_files_completed_cb, FALSE, NULL, NULL))\n    {\n      goto out;\n    }\n out:\n  ;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":11634
  },
  {
    "code":"void ChildProcessSecurityPolicy::Remove(int renderer_id) {\n  AutoLock lock(lock_);\n  if (!security_state_.count(renderer_id))\n    return;  \n  delete security_state_[renderer_id];\n  security_state_.erase(renderer_id);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":100540
  },
  {
    "code":"void DataReductionProxyConfig::EnableGetNetworkIdAsynchronously() {\n  get_network_id_asynchronously_ = true;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":150546
  },
  {
    "code":"hook_print_log ()\n{\n    int type, i, j;\n    struct t_hook *ptr_hook;\n    struct tm *local_time;\n    char text_time[1024];\n    for (type = 0; type < HOOK_NUM_TYPES; type++)\n    {\n        for (ptr_hook = weechat_hooks[type]; ptr_hook;\n             ptr_hook = ptr_hook->next_hook)\n        {\n            log_printf (\"\");\n            log_printf (\"[hook (addr:0x%lx)]\", ptr_hook);\n            log_printf (\"  plugin. . . . . . . . . : 0x%lx ('%s')\",\n                        ptr_hook->plugin, plugin_get_name (ptr_hook->plugin));\n            log_printf (\"  deleted . . . . . . . . : %d\",    ptr_hook->deleted);\n            log_printf (\"  running . . . . . . . . : %d\",    ptr_hook->running);\n            log_printf (\"  priority. . . . . . . . : %d\",    ptr_hook->priority);\n            log_printf (\"  type. . . . . . . . . . : %d (%s)\",\n                        ptr_hook->type, hook_type_string[ptr_hook->type]);\n            log_printf (\"  callback_data . . . . . : 0x%lx\", ptr_hook->callback_data);\n            switch (ptr_hook->type)\n            {\n                case HOOK_TYPE_COMMAND:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  command data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_COMMAND(ptr_hook, callback));\n                        log_printf (\"    command . . . . . . . : '%s'\",  HOOK_COMMAND(ptr_hook, command));\n                        log_printf (\"    description . . . . . : '%s'\",  HOOK_COMMAND(ptr_hook, description));\n                        log_printf (\"    args. . . . . . . . . : '%s'\",  HOOK_COMMAND(ptr_hook, args));\n                        log_printf (\"    args_description. . . : '%s'\",  HOOK_COMMAND(ptr_hook, args_description));\n                        log_printf (\"    completion. . . . . . : '%s'\",  HOOK_COMMAND(ptr_hook, completion));\n                        log_printf (\"    cplt_num_templates. . : %d\",    HOOK_COMMAND(ptr_hook, cplt_num_templates));\n                        for (i = 0; i < HOOK_COMMAND(ptr_hook, cplt_num_templates); i++)\n                        {\n                            log_printf (\"    cplt_templates[%04d] . . . : '%s'\",\n                                        i, HOOK_COMMAND(ptr_hook, cplt_templates)[i]);\n                            log_printf (\"    cplt_templates_static[%04d]: '%s'\",\n                                        i, HOOK_COMMAND(ptr_hook, cplt_templates_static)[i]);\n                            log_printf (\"      num_args. . . . . . : %d\",\n                                        HOOK_COMMAND(ptr_hook, cplt_template_num_args)[i]);\n                            for (j = 0; j < HOOK_COMMAND(ptr_hook, cplt_template_num_args)[i]; j++)\n                            {\n                                log_printf (\"      args[%04d]. . . . . : '%s'\",\n                                            j, HOOK_COMMAND(ptr_hook, cplt_template_args)[i][j]);\n                            }\n                        }\n                        log_printf (\"    num_args_concat . . . : %d\", HOOK_COMMAND(ptr_hook, cplt_template_num_args_concat));\n                        for (i = 0; i < HOOK_COMMAND(ptr_hook, cplt_template_num_args_concat); i++)\n                        {\n                            log_printf (\"    args_concat[%04d] . . : '%s'\",\n                                        i, HOOK_COMMAND(ptr_hook, cplt_template_args_concat)[i]);\n                        }\n                    }\n                    break;\n                case HOOK_TYPE_COMMAND_RUN:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  command_run data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_COMMAND_RUN(ptr_hook, callback));\n                        log_printf (\"    command . . . . . . . : '%s'\",  HOOK_COMMAND_RUN(ptr_hook, command));\n                    }\n                    break;\n                case HOOK_TYPE_TIMER:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  timer data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_TIMER(ptr_hook, callback));\n                        log_printf (\"    interval. . . . . . . : %ld\",   HOOK_TIMER(ptr_hook, interval));\n                        log_printf (\"    align_second. . . . . : %d\",    HOOK_TIMER(ptr_hook, align_second));\n                        log_printf (\"    remaining_calls . . . : %d\",    HOOK_TIMER(ptr_hook, remaining_calls));\n                        local_time = localtime (&HOOK_TIMER(ptr_hook, last_exec).tv_sec);\n                        strftime (text_time, sizeof (text_time),\n                                  \"%d\/%m\/%Y %H:%M:%S\", local_time);\n                        log_printf (\"    last_exec.tv_sec. . . : %ld (%s)\",\n                                    HOOK_TIMER(ptr_hook, last_exec.tv_sec),\n                                    text_time);\n                        log_printf (\"    last_exec.tv_usec . . : %ld\",   HOOK_TIMER(ptr_hook, last_exec.tv_usec));\n                        local_time = localtime (&HOOK_TIMER(ptr_hook, next_exec).tv_sec);\n                        strftime (text_time, sizeof (text_time),\n                                  \"%d\/%m\/%Y %H:%M:%S\", local_time);\n                        log_printf (\"    next_exec.tv_sec. . . : %ld (%s)\",\n                                    HOOK_TIMER(ptr_hook, next_exec.tv_sec),\n                                    text_time);\n                        log_printf (\"    next_exec.tv_usec . . : %ld\",   HOOK_TIMER(ptr_hook, next_exec.tv_usec));\n                    }\n                    break;\n                case HOOK_TYPE_FD:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  fd data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_FD(ptr_hook, callback));\n                        log_printf (\"    fd. . . . . . . . . . : %d\",    HOOK_FD(ptr_hook, fd));\n                        log_printf (\"    flags . . . . . . . . : %d\",    HOOK_FD(ptr_hook, flags));\n                    }\n                    break;\n                case HOOK_TYPE_PROCESS:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  process data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_PROCESS(ptr_hook, callback));\n                        log_printf (\"    command . . . . . . . : '%s'\",  HOOK_PROCESS(ptr_hook, command));\n                        log_printf (\"    timeout . . . . . . . : %d\",    HOOK_PROCESS(ptr_hook, timeout));\n                        log_printf (\"    child_read[stdout]. . : %d\",    HOOK_PROCESS(ptr_hook, child_read[HOOK_PROCESS_STDOUT]));\n                        log_printf (\"    child_write[stdout] . : %d\",    HOOK_PROCESS(ptr_hook, child_write[HOOK_PROCESS_STDOUT]));\n                        log_printf (\"    child_read[stderr]. . : %d\",    HOOK_PROCESS(ptr_hook, child_read[HOOK_PROCESS_STDERR]));\n                        log_printf (\"    child_write[stderr] . : %d\",    HOOK_PROCESS(ptr_hook, child_write[HOOK_PROCESS_STDERR]));\n                        log_printf (\"    child_pid . . . . . . : %d\",    HOOK_PROCESS(ptr_hook, child_pid));\n                        log_printf (\"    hook_fd[stdout] . . . : 0x%lx\", HOOK_PROCESS(ptr_hook, hook_fd[HOOK_PROCESS_STDOUT]));\n                        log_printf (\"    hook_fd[stderr] . . . : 0x%lx\", HOOK_PROCESS(ptr_hook, hook_fd[HOOK_PROCESS_STDERR]));\n                        log_printf (\"    hook_timer. . . . . . : 0x%lx\", HOOK_PROCESS(ptr_hook, hook_timer));\n                    }\n                    break;\n                case HOOK_TYPE_CONNECT:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  connect data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_CONNECT(ptr_hook, callback));\n                        log_printf (\"    address . . . . . . . : '%s'\",  HOOK_CONNECT(ptr_hook, address));\n                        log_printf (\"    port. . . . . . . . . : %d\",    HOOK_CONNECT(ptr_hook, port));\n                        log_printf (\"    sock. . . . . . . . . : %d\",    HOOK_CONNECT(ptr_hook, sock));\n                        log_printf (\"    ipv6. . . . . . . . . : %d\",    HOOK_CONNECT(ptr_hook, ipv6));\n#ifdef HAVE_GNUTLS\n                        log_printf (\"    gnutls_sess . . . . . : 0x%lx\", HOOK_CONNECT(ptr_hook, gnutls_sess));\n                        log_printf (\"    gnutls_cb . . . . . . : 0x%lx\", HOOK_CONNECT(ptr_hook, gnutls_cb));\n                        log_printf (\"    gnutls_dhkey_size . . : %d\",    HOOK_CONNECT(ptr_hook, gnutls_dhkey_size));\n#endif\n                        log_printf (\"    local_hostname. . . . : '%s'\",  HOOK_CONNECT(ptr_hook, local_hostname));\n                        log_printf (\"    child_read. . . . . . : %d\",    HOOK_CONNECT(ptr_hook, child_read));\n                        log_printf (\"    child_write . . . . . : %d\",    HOOK_CONNECT(ptr_hook, child_write));\n                        log_printf (\"    child_pid . . . . . . : %d\",    HOOK_CONNECT(ptr_hook, child_pid));\n                        log_printf (\"    hook_fd . . . . . . . : 0x%lx\", HOOK_CONNECT(ptr_hook, hook_fd));\n                        log_printf (\"    handshake_hook_fd . . : 0x%lx\", HOOK_CONNECT(ptr_hook, handshake_hook_fd));\n                        log_printf (\"    handshake_hook_timer. : 0x%lx\", HOOK_CONNECT(ptr_hook, handshake_hook_timer));\n                        log_printf (\"    handshake_fd_flags. . : %d\",    HOOK_CONNECT(ptr_hook, handshake_fd_flags));\n                        log_printf (\"    handshake_ip_address. : '%s'\",  HOOK_CONNECT(ptr_hook, handshake_ip_address));\n                    }\n                    break;\n                case HOOK_TYPE_PRINT:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  print data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_PRINT(ptr_hook, callback));\n                        log_printf (\"    buffer. . . . . . . . : 0x%lx\", HOOK_PRINT(ptr_hook, buffer));\n                        log_printf (\"    tags_count. . . . . . : %d\",    HOOK_PRINT(ptr_hook, tags_count));\n                        log_printf (\"    tags_array. . . . . . : 0x%lx\", HOOK_PRINT(ptr_hook, tags_array));\n                        log_printf (\"    message . . . . . . . : '%s'\",  HOOK_PRINT(ptr_hook, message));\n                        log_printf (\"    strip_colors. . . . . : %d\",    HOOK_PRINT(ptr_hook, strip_colors));\n                    }\n                    break;\n                case HOOK_TYPE_SIGNAL:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  signal data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_SIGNAL(ptr_hook, callback));\n                        log_printf (\"    signal. . . . . . . . : '%s'\",  HOOK_SIGNAL(ptr_hook, signal));\n                    }\n                    break;\n                case HOOK_TYPE_HSIGNAL:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  signal data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_HSIGNAL(ptr_hook, callback));\n                        log_printf (\"    signal. . . . . . . . : '%s'\",  HOOK_HSIGNAL(ptr_hook, signal));\n                    }\n                    break;\n                case HOOK_TYPE_CONFIG:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  config data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_CONFIG(ptr_hook, callback));\n                        log_printf (\"    option. . . . . . . . : '%s'\",  HOOK_CONFIG(ptr_hook, option));\n                    }\n                    break;\n                case HOOK_TYPE_COMPLETION:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  completion data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_COMPLETION(ptr_hook, callback));\n                        log_printf (\"    completion_item . . . : '%s'\",  HOOK_COMPLETION(ptr_hook, completion_item));\n                        log_printf (\"    description . . . . . : '%s'\",  HOOK_COMPLETION(ptr_hook, description));\n                    }\n                    break;\n                case HOOK_TYPE_MODIFIER:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  modifier data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_MODIFIER(ptr_hook, callback));\n                        log_printf (\"    modifier. . . . . . . : '%s'\",  HOOK_MODIFIER(ptr_hook, modifier));\n                    }\n                    break;\n                case HOOK_TYPE_INFO:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  info data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_INFO(ptr_hook, callback));\n                        log_printf (\"    info_name . . . . . . : '%s'\",  HOOK_INFO(ptr_hook, info_name));\n                        log_printf (\"    description . . . . . : '%s'\",  HOOK_INFO(ptr_hook, description));\n                        log_printf (\"    args_description. . . : '%s'\",  HOOK_INFO(ptr_hook, args_description));\n                    }\n                    break;\n                case HOOK_TYPE_INFO_HASHTABLE:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  info_hashtable data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_INFO_HASHTABLE(ptr_hook, callback));\n                        log_printf (\"    info_name . . . . . . : '%s'\",  HOOK_INFO_HASHTABLE(ptr_hook, info_name));\n                        log_printf (\"    description . . . . . : '%s'\",  HOOK_INFO_HASHTABLE(ptr_hook, description));\n                        log_printf (\"    args_description. . . : '%s'\",  HOOK_INFO_HASHTABLE(ptr_hook, args_description));\n                        log_printf (\"    output_description. . : '%s'\",  HOOK_INFO_HASHTABLE(ptr_hook, output_description));\n                    }\n                    break;\n                case HOOK_TYPE_INFOLIST:\n                    if (!ptr_hook->deleted)\n                    {\n                        log_printf (\"  infolist data:\");\n                        log_printf (\"    callback. . . . . . . : 0x%lx\", HOOK_INFOLIST(ptr_hook, callback));\n                        log_printf (\"    infolist_name . . . . : '%s'\",  HOOK_INFOLIST(ptr_hook, infolist_name));\n                        log_printf (\"    description . . . . . : '%s'\",  HOOK_INFOLIST(ptr_hook, description));\n                        log_printf (\"    pointer_description . : '%s'\",  HOOK_INFOLIST(ptr_hook, pointer_description));\n                        log_printf (\"    args_description. . . : '%s'\",  HOOK_INFOLIST(ptr_hook, args_description));\n                    }\n                    break;\n                case HOOK_NUM_TYPES:\n                    break;\n            }\n            log_printf (\"  prev_hook . . . . . . . : 0x%lx\", ptr_hook->prev_hook);\n            log_printf (\"  next_hook . . . . . . . : 0x%lx\", ptr_hook->next_hook);\n        }\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":3426
  },
  {
    "code":"long long mkvparser::UnserializeUInt(\n    IMkvReader* pReader,\n    long long pos,\n    long long size)\n{\n    assert(pReader);\n    assert(pos >= 0);\n    if ((size <= 0) || (size > 8))\n        return E_FILE_FORMAT_INVALID;\n    long long result = 0;\n    for (long long i = 0; i < size; ++i)\n    {\n        unsigned char b;\n        const long status = pReader->Read(pos, 1, &b);\n        if (status < 0)\n            return status;\n        result <<= 8;\n        result |= b;\n        ++pos;\n     }\n    return result;\n }\n",
    "vul":1,
    "flaw_line_no":[
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      21
    ],
    "bigvul_id":188472
  },
  {
    "code":"static int get_descriptor_addr(struct edgeport_serial *serial,\n        int desc_type, struct ti_i2c_desc *rom_desc)\n{\n  int start_address;\n  int status;\n  start_address = 2;\n  do {\n    status = read_rom(serial,\n           start_address,\n           sizeof(struct ti_i2c_desc),\n           (__u8 *)rom_desc);\n    if (status)\n      return 0;\n    if (rom_desc->Type == desc_type)\n      return start_address;\n    start_address = start_address + sizeof(struct ti_i2c_desc)\n              + rom_desc->Size;\n  } while ((start_address < TI_MAX_I2C_SIZE) && rom_desc->Type);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":33347
  },
  {
    "code":"METHODDEF(JDIMENSION)\nget_8bit_row(j_compress_ptr cinfo, cjpeg_source_ptr sinfo)\n{\n  bmp_source_ptr source = (bmp_source_ptr)sinfo;\n  register JSAMPARRAY colormap = source->colormap;\n  JSAMPARRAY image_ptr;\n  register int t;\n  register JSAMPROW inptr, outptr;\n  register JDIMENSION col;\n  if (source->use_inversion_array) {\n    source->source_row--;\n    image_ptr = (*cinfo->mem->access_virt_sarray)\n      ((j_common_ptr)cinfo, source->whole_image,\n       source->source_row, (JDIMENSION)1, FALSE);\n    inptr = image_ptr[0];\n  } else {\n    if (!ReadOK(source->pub.input_file, source->iobuffer, source->row_width))\n      ERREXIT(cinfo, JERR_INPUT_EOF);\n    inptr = source->iobuffer;\n  }\n  outptr = source->pub.buffer[0];\n  if (cinfo->in_color_space == JCS_GRAYSCALE) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      t = GETJSAMPLE(*inptr++);\n      *outptr++ = colormap[0][t];\n    }\n  } else if (cinfo->in_color_space == JCS_CMYK) {\n    for (col = cinfo->image_width; col > 0; col--) {\n      t = GETJSAMPLE(*inptr++);\n      rgb_to_cmyk(colormap[0][t], colormap[1][t], colormap[2][t], outptr,\n                  outptr + 1, outptr + 2, outptr + 3);\n      outptr += 4;\n    }\n  } else {\n    register int rindex = rgb_red[cinfo->in_color_space];\n    register int gindex = rgb_green[cinfo->in_color_space];\n    register int bindex = rgb_blue[cinfo->in_color_space];\n    register int aindex = alpha_index[cinfo->in_color_space];\n    register int ps = rgb_pixelsize[cinfo->in_color_space];\n    if (aindex >= 0) {\n      for (col = cinfo->image_width; col > 0; col--) {\n        t = GETJSAMPLE(*inptr++);\n        outptr[rindex] = colormap[0][t];\n        outptr[gindex] = colormap[1][t];\n        outptr[bindex] = colormap[2][t];\n        outptr[aindex] = 0xFF;\n        outptr += ps;\n      }\n    } else {\n      for (col = cinfo->image_width; col > 0; col--) {\n        t = GETJSAMPLE(*inptr++);\n        outptr[rindex] = colormap[0][t];\n        outptr[gindex] = colormap[1][t];\n        outptr[bindex] = colormap[2][t];\n        outptr += ps;\n      }\n    }\n  }\n  return 1;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":84763
  },
  {
    "code":"void yr_re_print(\n    RE_AST* re_ast)\n{\n  _yr_re_print_node(re_ast->root_node);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":64583
  },
  {
    "code":"void WebGLRenderingContextBase::MarkLayerComposited() {\n  if (!isContextLost())\n    GetDrawingBuffer()->ResetBuffersToAutoClear();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":154966
  },
  {
    "code":"XML_SetExternalEntityRefHandler(XML_Parser parser,\n                                XML_ExternalEntityRefHandler handler) {\n  if (parser != NULL)\n    parser->m_externalEntityRefHandler = handler;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":88222
  },
  {
    "code":"static inline int cop1_64bit(struct pt_regs *xcp)\n{\n  if (cpu_has_fpu)\n    return xcp->cp0_status & ST0_FR;\n#ifdef CONFIG_64BIT\n  return !test_thread_flag(TIF_32BIT_REGS);\n#else\n  return 0;\n#endif\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":25435
  },
  {
    "code":"int dec2octal(int decimal)\n{\n  int octal, pos;\n  octal = 0; pos = 0;\n  while (decimal > 0) {\n    octal += (decimal & 7)*(pos == 0 ? 1 : pos);\n    decimal \/= 8;\n    pos += 10;\n  }\n  return octal;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":63631
  },
  {
    "code":"const sync_pb::ExtensionSpecifics& BaseNode::GetExtensionSpecifics() const {\n  DCHECK_EQ(syncable::EXTENSIONS, GetModelType());\n  return GetEntitySpecifics().GetExtension(sync_pb::extension);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":101371
  },
  {
    "code":"static int arcmsr_alloc_ccb_pool(struct AdapterControlBlock *acb)\n{\n  struct pci_dev *pdev = acb->pdev;\n  void *dma_coherent;\n  dma_addr_t dma_coherent_handle;\n  struct CommandControlBlock *ccb_tmp;\n  int i = 0, j = 0;\n  dma_addr_t cdb_phyaddr;\n  unsigned long roundup_ccbsize;\n  unsigned long max_xfer_len;\n  unsigned long max_sg_entrys;\n  uint32_t  firm_config_version;\n  for (i = 0; i < ARCMSR_MAX_TARGETID; i++)\n    for (j = 0; j < ARCMSR_MAX_TARGETLUN; j++)\n      acb->devstate[i][j] = ARECA_RAID_GONE;\n  max_xfer_len = ARCMSR_MAX_XFER_LEN;\n  max_sg_entrys = ARCMSR_DEFAULT_SG_ENTRIES;\n  firm_config_version = acb->firm_cfg_version;\n  if((firm_config_version & 0xFF) >= 3){\n    max_xfer_len = (ARCMSR_CDB_SG_PAGE_LENGTH << ((firm_config_version >> 8) & 0xFF)) * 1024;\n    max_sg_entrys = (max_xfer_len\/4096);\n  }\n  acb->host->max_sectors = max_xfer_len\/512;\n  acb->host->sg_tablesize = max_sg_entrys;\n  roundup_ccbsize = roundup(sizeof(struct CommandControlBlock) + (max_sg_entrys - 1) * sizeof(struct SG64ENTRY), 32);\n  acb->uncache_size = roundup_ccbsize * ARCMSR_MAX_FREECCB_NUM;\n  dma_coherent = dma_alloc_coherent(&pdev->dev, acb->uncache_size, &dma_coherent_handle, GFP_KERNEL);\n  if(!dma_coherent){\n    printk(KERN_NOTICE \"arcmsr%d: dma_alloc_coherent got error\\n\", acb->host->host_no);\n    return -ENOMEM;\n  }\n  acb->dma_coherent = dma_coherent;\n  acb->dma_coherent_handle = dma_coherent_handle;\n  memset(dma_coherent, 0, acb->uncache_size);\n  ccb_tmp = dma_coherent;\n  acb->vir2phy_offset = (unsigned long)dma_coherent - (unsigned long)dma_coherent_handle;\n  for(i = 0; i < ARCMSR_MAX_FREECCB_NUM; i++){\n    cdb_phyaddr = dma_coherent_handle + offsetof(struct CommandControlBlock, arcmsr_cdb);\n    switch (acb->adapter_type) {\n    case ACB_ADAPTER_TYPE_A:\n    case ACB_ADAPTER_TYPE_B:\n      ccb_tmp->cdb_phyaddr = cdb_phyaddr >> 5;\n      break;\n    case ACB_ADAPTER_TYPE_C:\n    case ACB_ADAPTER_TYPE_D:\n      ccb_tmp->cdb_phyaddr = cdb_phyaddr;\n      break;\n    }\n    acb->pccb_pool[i] = ccb_tmp;\n    ccb_tmp->acb = acb;\n    INIT_LIST_HEAD(&ccb_tmp->list);\n    list_add_tail(&ccb_tmp->list, &acb->ccb_free_list);\n    ccb_tmp = (struct CommandControlBlock *)((unsigned long)ccb_tmp + roundup_ccbsize);\n    dma_coherent_handle = dma_coherent_handle + roundup_ccbsize;\n  }\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":49735
  },
  {
    "code":"blink::mojom::BlobURLTokenPtrInfo CloneBlobURLToken(\n    mojo::MessagePipeHandle handle) {\n  if (!handle.is_valid())\n    return nullptr;\n  blink::mojom::BlobURLTokenPtrInfo result;\n  blink::mojom::BlobURLTokenPtr token(\n      blink::mojom::BlobURLTokenPtrInfo(mojo::ScopedMessagePipeHandle(handle),\n                                        blink::mojom::BlobURLToken::Version_));\n  token->Clone(MakeRequest(&result));\n  ignore_result(token.PassInterface().PassHandle().release());\n  return result;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":152212
  },
  {
    "code":"iscsi_process_read(void *arg)\n{\n    IscsiLun *iscsilun = arg;\n    struct iscsi_context *iscsi = iscsilun->iscsi;\n    iscsi_service(iscsi, POLLIN);\n    iscsi_set_events(iscsilun);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":10520
  },
  {
    "code":"EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionWithScriptStateVoidException(ExecState* exec)\n{\n    JSValue thisValue = exec->hostThisValue();\n    if (!thisValue.inherits(&JSTestObj::s_info))\n        return throwVMTypeError(exec);\n    JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));\n    ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);\n    TestObj* impl = static_cast<TestObj*>(castedThis->impl());\n    ExceptionCode ec = 0;\n    impl->withScriptStateVoidException(exec, ec);\n    setDOMException(exec, ec);\n    return JSValue::encode(jsUndefined());\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":106155
  },
  {
    "code":"MojoVideoEncodeAccelerator::MojoVideoEncodeAccelerator(\n    mojom::VideoEncodeAcceleratorPtr vea,\n    const gpu::VideoEncodeAcceleratorSupportedProfiles& supported_profiles)\n    : vea_(std::move(vea)), supported_profiles_(supported_profiles) {\n  DVLOG(1) << __func__;\n  DCHECK(vea_);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":162329
  },
  {
    "code":"static int ecb_encrypt(struct blkcipher_desc *desc, struct scatterlist *dst,\n           struct scatterlist *src, unsigned int nbytes)\n{\n  return glue_ecb_crypt_128bit(&cast6_enc, desc, dst, src, nbytes);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":46913
  },
  {
    "code":"static ZEND_RESULT_CODE parse_userinfo(struct parse_state *state, const char *ptr)\n{\n  size_t mb;\n  const char *password = NULL, *end = state->ptr, *tmp = ptr;\n  TSRMLS_FETCH_FROM_CTX(state->ts);\n  state->url.user = &state->buffer[state->offset];\n  do {\n    switch (*ptr) {\n    case ':':\n      if (password) {\n        php_error_docref(NULL TSRMLS_CC, E_WARNING,\n            \"Failed to parse password; duplicate ':' at pos %u in '%s'\",\n            (unsigned) (ptr - tmp), tmp);\n        return FAILURE;\n      }\n      password = ptr + 1;\n      state->buffer[state->offset++] = 0;\n      state->url.pass = &state->buffer[state->offset];\n      break;\n    case '%':\n      if (ptr[1] != '%' && (end - ptr <= 2 || !isxdigit(*(ptr+1)) || !isxdigit(*(ptr+2)))) {\n        php_error_docref(NULL TSRMLS_CC, E_WARNING,\n            \"Failed to parse userinfo; invalid percent encoding at pos %u in '%s'\",\n            (unsigned) (ptr - tmp), tmp);\n        return FAILURE;\n      }\n      state->buffer[state->offset++] = *ptr++;\n      state->buffer[state->offset++] = *ptr++;\n      state->buffer[state->offset++] = *ptr;\n      break;\n    case '!': case '$': case '&': case '\\'': case '(': case ')': case '*':\n    case '+': case ',': case ';': case '=': \n    case '-': case '.': case '_': case '~': \n    case 'A': case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':\n    case 'H': case 'I': case 'J': case 'K': case 'L': case 'M': case 'N':\n    case 'O': case 'P': case 'Q': case 'R': case 'S': case 'T': case 'U':\n    case 'V': case 'W': case 'X': case 'Y': case 'Z':\n    case 'a': case 'b': case 'c': case 'd': case 'e': case 'f': case 'g':\n    case 'h': case 'i': case 'j': case 'k': case 'l': case 'm': case 'n':\n    case 'o': case 'p': case 'q': case 'r': case 's': case 't': case 'u':\n    case 'v': case 'w': case 'x': case 'y': case 'z':\n    case '0': case '1': case '2': case '3': case '4': case '5': case '6':\n    case '7': case '8': case '9':\n      state->buffer[state->offset++] = *ptr;\n      break;\n    default:\n      if (!(mb = parse_mb(state, PARSE_USERINFO, ptr, end, tmp, 0))) {\n        return FAILURE;\n      }\n      ptr += mb - 1;\n    }\n  } while(++ptr != end);\n  state->buffer[state->offset++] = 0;\n  return SUCCESS;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":73835
  },
  {
    "code":"static void ext3_mark_recovery_complete(struct super_block * sb,\n          struct ext3_super_block * es)\n{\n  journal_t *journal = EXT3_SB(sb)->s_journal;\n  journal_lock_updates(journal);\n  if (journal_flush(journal) < 0)\n    goto out;\n  if (EXT3_HAS_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER) &&\n      sb->s_flags & MS_RDONLY) {\n    EXT3_CLEAR_INCOMPAT_FEATURE(sb, EXT3_FEATURE_INCOMPAT_RECOVER);\n    ext3_commit_super(sb, es, 1);\n  }\nout:\n  journal_unlock_updates(journal);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":32934
  },
  {
    "code":"static void FS_CheckMPPaks( void )\n{\n  searchpath_t  *path;\n  pack_t    *curpack;\n  unsigned int foundPak = 0;\n  for( path = fs_searchpaths; path; path = path->next )\n  {\n    const char* pakBasename = path->pack->pakBasename;\n    if(!path->pack)\n      continue;\n    curpack = path->pack;\n    if(!Q_stricmpn( curpack->pakGamename, BASEGAME, MAX_OSPATH )\n      && strlen(pakBasename) == 7 && !Q_stricmpn( pakBasename, \"mp_pak\", 6 )\n      && pakBasename[6] >= '0' && pakBasename[6] <= '0' + NUM_MP_PAKS - 1)\n    {\n      if( curpack->checksum != mppak_checksums[pakBasename[6]-'0'] )\n      {\n        if(pakBasename[6] == '0')\n        {\n          Com_Printf(\"\\n\\n\"\n            \"**************************************************\\n\"\n            \"WARNING: \" BASEGAME \"\/mp_pak0.pk3 is present but its checksum (%u)\\n\"\n            \"is not correct. Please re-copy mp_pak0.pk3 from your\\n\"\n            \"legitimate RTCW CDROM.\\n\"\n            \"**************************************************\\n\\n\\n\",\n            curpack->checksum );\n        }\n        else\n        {\n          Com_Printf(\"\\n\\n\"\n            \"**************************************************\\n\"\n            \"WARNING: \" BASEGAME \"\/mp_pak%d.pk3 is present but its checksum (%u)\\n\"\n            \"is not correct. Please re-install the point release\\n\"\n            \"**************************************************\\n\\n\\n\",\n            pakBasename[6]-'0', curpack->checksum );\n        }\n      }\n      foundPak |= 1<<(pakBasename[6]-'0');\n    }\n    else\n    {\n      int index;\n      for(index = 0; index < ARRAY_LEN(mppak_checksums); index++)\n      {\n        if(curpack->checksum == mppak_checksums[index])\n        {\n          Com_Printf(\"\\n\\n\"\n            \"**************************************************\\n\"\n            \"WARNING: %s is renamed pak file %s%cmp_pak%d.pk3\\n\"\n            \"Running in standalone mode won't work\\n\"\n            \"Please rename, or remove this file\\n\"\n            \"**************************************************\\n\\n\\n\",\n            curpack->pakFilename, BASEGAME, PATH_SEP, index);\n          foundPak |= 0x80000000;\n        }\n      }\n    }\n  }\n  if(!foundPak && Q_stricmp(com_basegame->string, BASEGAME))\n  {\n    Cvar_Set(\"com_standalone\", \"1\");\n  }\n  else\n    Cvar_Set(\"com_standalone\", \"0\");\n  if(!com_standalone->integer && (foundPak & 0x3f) != 0x3f)\n  {\n    char errorText[MAX_STRING_CHARS] = \"\";\n    char missingPaks[MAX_STRING_CHARS] = \"\";\n    int i = 0;\n    if((foundPak & 0x3f) != 0x3f)\n    {\n      for( i = 0; i < NUM_MP_PAKS; i++ ) {\n        if ( !( foundPak & ( 1 << i ) ) ) {\n          Q_strcat( missingPaks, sizeof( missingPaks ), va( \"mp_pak%d.pk3 \", i ) );\n        }\n      }\n      Q_strcat( errorText, sizeof( errorText ),\n        va( \"\\n\\nPoint Release files are missing: %s \\n\"\n        \"Please re-install the 1.41 point release.\\n\\n\", missingPaks ) );\n    }\n    Com_Error(ERR_FATAL, \"%s\", errorText);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":95760
  },
  {
    "code":"void QuotaManager::DidGetLRUOrigin(const GURL* origin,\n                                   bool success) {\n  DidDatabaseWork(success);\n  if (origins_in_use_.find(*origin) != origins_in_use_.end() ||\n      access_notified_origins_.find(*origin) != access_notified_origins_.end())\n    lru_origin_callback_.Run(GURL());\n  else\n    lru_origin_callback_.Run(*origin);\n  access_notified_origins_.clear();\n  lru_origin_callback_.Reset();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":108486
  },
  {
    "code":"partition_create_filesystem_create_hook (DBusGMethodInvocation *context,\n                                         Device *device,\n                                         gboolean filesystem_create_succeeded,\n                                         gpointer user_data)\n{\n  if (!filesystem_create_succeeded)\n    {\n    }\n  else\n    {\n      dbus_g_method_return (context, device->priv->object_path);\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":11792
  },
  {
    "code":"int PrintRenderFrameHelper::PrintPreviewContext::last_error() const {\n  return error_;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":161972
  },
  {
    "code":"png_init_filter_functions_neon(png_structp pp, unsigned int bpp)\n{\n#ifdef PNG_ARM_NEON_API_SUPPORTED\n switch ((pp->options >> PNG_ARM_NEON) & 3)\n {\n case PNG_OPTION_UNSET:\n#endif \n#ifdef PNG_ARM_NEON_CHECK_SUPPORTED\n {\n static volatile sig_atomic_t no_neon = -1; \n if (no_neon < 0)\n               no_neon = !png_have_neon(pp);\n if (no_neon)\n return;\n }\n#ifdef PNG_ARM_NEON_API_SUPPORTED\n break;\n#endif\n#endif \n#ifdef PNG_ARM_NEON_API_SUPPORTED\n default: \n return;\n case PNG_OPTION_ON:\n break;\n }\n#endif\n   pp->read_filter[PNG_FILTER_VALUE_UP-1] = png_read_filter_row_up_neon;\n if (bpp == 3)\n {\n      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub3_neon;\n      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg3_neon;\n      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =\n         png_read_filter_row_paeth3_neon;\n }\n else if (bpp == 4)\n {\n      pp->read_filter[PNG_FILTER_VALUE_SUB-1] = png_read_filter_row_sub4_neon;\n      pp->read_filter[PNG_FILTER_VALUE_AVG-1] = png_read_filter_row_avg4_neon;\n      pp->read_filter[PNG_FILTER_VALUE_PAETH-1] =\n          png_read_filter_row_paeth4_neon;\n    }\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":172931
  },
  {
    "code":"decompileDELETE(int n, SWF_ACTION *actions, int maxn, int is_type2)\n{\n  if (is_type2)\n    push(newVar3(\"delete(\",getName(pop()),\")\"));\n  else\n    push(newVar_N(\"delete(\",getName(pop()),\".\",getName(pop()), 0,\")\"));\n  if (OpCode(actions, n+1, maxn) == SWFACTION_POP)\n  {\n    INDENT\n    puts(getName(pop()));\n    println(\";\" );\n    return 1;\n  }\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":89492
  },
  {
    "code":"static int airo_get_retry(struct net_device *dev,\n        struct iw_request_info *info,\n        struct iw_param *vwrq,\n        char *extra)\n{\n  struct airo_info *local = dev->ml_priv;\n  vwrq->disabled = 0;      \n  readConfigRid(local, 1);\n  if((vwrq->flags & IW_RETRY_TYPE) == IW_RETRY_LIFETIME) {\n    vwrq->flags = IW_RETRY_LIFETIME;\n    vwrq->value = le16_to_cpu(local->config.txLifetime) * 1024;\n  } else if((vwrq->flags & IW_RETRY_LONG)) {\n    vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;\n    vwrq->value = le16_to_cpu(local->config.longRetryLimit);\n  } else {\n    vwrq->flags = IW_RETRY_LIMIT;\n    vwrq->value = le16_to_cpu(local->config.shortRetryLimit);\n    if(local->config.shortRetryLimit != local->config.longRetryLimit)\n      vwrq->flags |= IW_RETRY_SHORT;\n  }\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":23961
  },
  {
    "code":"entry_guards_load_guards_from_state(or_state_t *state, int set)\n{\n  const config_line_t *line = state->Guard;\n  int n_errors = 0;\n  if (!guard_contexts)\n    guard_contexts = smartlist_new();\n  if (set) {\n    SMARTLIST_FOREACH_BEGIN(guard_contexts, guard_selection_t *, gs) {\n      guard_selection_free(gs);\n      if (curr_guard_context == gs)\n        curr_guard_context = NULL;\n      SMARTLIST_DEL_CURRENT(guard_contexts, gs);\n    } SMARTLIST_FOREACH_END(gs);\n  }\n  for ( ; line != NULL; line = line->next) {\n    entry_guard_t *guard = entry_guard_parse_from_state(line->value);\n    if (guard == NULL) {\n      ++n_errors;\n      continue;\n    }\n    tor_assert(guard->selection_name);\n    if (!strcmp(guard->selection_name, \"legacy\")) {\n      ++n_errors;\n      entry_guard_free(guard);\n      continue;\n    }\n    if (set) {\n      guard_selection_t *gs;\n      gs = get_guard_selection_by_name(guard->selection_name,\n                                       GS_TYPE_INFER, 1);\n      tor_assert(gs);\n      smartlist_add(gs->sampled_entry_guards, guard);\n      guard->in_selection = gs;\n    } else {\n      entry_guard_free(guard);\n    }\n  }\n  if (set) {\n    SMARTLIST_FOREACH_BEGIN(guard_contexts, guard_selection_t *, gs) {\n      entry_guards_update_all(gs);\n    } SMARTLIST_FOREACH_END(gs);\n  }\n  return n_errors ? -1 : 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":69691
  },
  {
    "code":"static int calc_combed_score(const FieldMatchContext *fm, const AVFrame *src)\n{\n    int x, y, plane, max_v = 0;\n    const int cthresh = fm->cthresh;\n    const int cthresh6 = cthresh * 6;\n    for (plane = 0; plane < (fm->chroma ? 3 : 1); plane++) {\n        const uint8_t *srcp = src->data[plane];\n        const int src_linesize = src->linesize[plane];\n        const int width  = get_width (fm, src, plane);\n        const int height = get_height(fm, src, plane);\n        uint8_t *cmkp = fm->cmask_data[plane];\n        const int cmk_linesize = fm->cmask_linesize[plane];\n        if (cthresh < 0) {\n            fill_buf(cmkp, width, height, cmk_linesize, 0xff);\n            continue;\n        }\n        fill_buf(cmkp, width, height, cmk_linesize, 0);\n#define FILTER(xm2, xm1, xp1, xp2) \\\n        abs(  4 * srcp[x] \\\n             -3 * (srcp[x + (xm1)*src_linesize] + srcp[x + (xp1)*src_linesize]) \\\n             +    (srcp[x + (xm2)*src_linesize] + srcp[x + (xp2)*src_linesize])) > cthresh6\n        for (x = 0; x < width; x++) {\n            const int s1 = abs(srcp[x] - srcp[x + src_linesize]);\n            if (s1 > cthresh && FILTER(2, 1, 1, 2))\n                cmkp[x] = 0xff;\n        }\n        srcp += src_linesize;\n        cmkp += cmk_linesize;\n        for (x = 0; x < width; x++) {\n            const int s1 = abs(srcp[x] - srcp[x - src_linesize]);\n            const int s2 = abs(srcp[x] - srcp[x + src_linesize]);\n            if (s1 > cthresh && s2 > cthresh && FILTER(2, -1, 1, 2))\n                cmkp[x] = 0xff;\n        }\n        srcp += src_linesize;\n        cmkp += cmk_linesize;\n        for (y = 2; y < height-2; y++) {\n            for (x = 0; x < width; x++) {\n                const int s1 = abs(srcp[x] - srcp[x - src_linesize]);\n                const int s2 = abs(srcp[x] - srcp[x + src_linesize]);\n                if (s1 > cthresh && s2 > cthresh && FILTER(-2, -1, 1, 2))\n                    cmkp[x] = 0xff;\n            }\n            srcp += src_linesize;\n            cmkp += cmk_linesize;\n        }\n        for (x = 0; x < width; x++) {\n            const int s1 = abs(srcp[x] - srcp[x - src_linesize]);\n            const int s2 = abs(srcp[x] - srcp[x + src_linesize]);\n            if (s1 > cthresh && s2 > cthresh && FILTER(-2, -1, 1, -2))\n                cmkp[x] = 0xff;\n        }\n        srcp += src_linesize;\n        cmkp += cmk_linesize;\n        for (x = 0; x < width; x++) {\n            const int s1 = abs(srcp[x] - srcp[x - src_linesize]);\n            if (s1 > cthresh && FILTER(-2, -1, -1, -2))\n                cmkp[x] = 0xff;\n        }\n    }\n    if (fm->chroma) {\n        uint8_t *cmkp  = fm->cmask_data[0];\n        uint8_t *cmkpU = fm->cmask_data[1];\n        uint8_t *cmkpV = fm->cmask_data[2];\n        const int width  = FF_CEIL_RSHIFT(src->width,  fm->hsub);\n        const int height = FF_CEIL_RSHIFT(src->height, fm->vsub);\n        const int cmk_linesize   = fm->cmask_linesize[0] << 1;\n        const int cmk_linesizeUV = fm->cmask_linesize[2];\n        uint8_t *cmkpp  = cmkp - (cmk_linesize>>1);\n        uint8_t *cmkpn  = cmkp + (cmk_linesize>>1);\n        uint8_t *cmkpnn = cmkp +  cmk_linesize;\n        for (y = 1; y < height - 1; y++) {\n            cmkpp  += cmk_linesize;\n            cmkp   += cmk_linesize;\n            cmkpn  += cmk_linesize;\n            cmkpnn += cmk_linesize;\n            cmkpV  += cmk_linesizeUV;\n            cmkpU  += cmk_linesizeUV;\n            for (x = 1; x < width - 1; x++) {\n#define HAS_FF_AROUND(p, lz) (p[x-1 - lz] == 0xff || p[x - lz] == 0xff || p[x+1 - lz] == 0xff || \\\n                              p[x-1     ] == 0xff ||                      p[x+1     ] == 0xff || \\\n                              p[x-1 + lz] == 0xff || p[x + lz] == 0xff || p[x+1 + lz] == 0xff)\n                if ((cmkpV[x] == 0xff && HAS_FF_AROUND(cmkpV, cmk_linesizeUV)) ||\n                    (cmkpU[x] == 0xff && HAS_FF_AROUND(cmkpU, cmk_linesizeUV))) {\n                    ((uint16_t*)cmkp)[x]  = 0xffff;\n                    ((uint16_t*)cmkpn)[x] = 0xffff;\n                    if (y&1) ((uint16_t*)cmkpp)[x]  = 0xffff;\n                    else     ((uint16_t*)cmkpnn)[x] = 0xffff;\n                }\n            }\n        }\n    }\n    {\n        const int blockx = fm->blockx;\n        const int blocky = fm->blocky;\n        const int xhalf = blockx\/2;\n        const int yhalf = blocky\/2;\n        const int cmk_linesize = fm->cmask_linesize[0];\n        const uint8_t *cmkp    = fm->cmask_data[0] + cmk_linesize;\n        const int width  = src->width;\n        const int height = src->height;\n        const int xblocks = ((width+xhalf)\/blockx) + 1;\n        const int xblocks4 = xblocks<<2;\n        const int yblocks = ((height+yhalf)\/blocky) + 1;\n        int *c_array = fm->c_array;\n        const int arraysize = (xblocks*yblocks)<<2;\n        int      heighta = (height\/(blocky\/2))*(blocky\/2);\n        const int widtha = (width \/(blockx\/2))*(blockx\/2);\n        if (heighta == height)\n            heighta = height - yhalf;\n        memset(c_array, 0, arraysize * sizeof(*c_array));\n#define C_ARRAY_ADD(v) do {                         \\\n    const int box1 = (x \/ blockx) * 4;              \\\n    const int box2 = ((x + xhalf) \/ blockx) * 4;    \\\n    c_array[temp1 + box1    ] += v;                 \\\n    c_array[temp1 + box2 + 1] += v;                 \\\n    c_array[temp2 + box1 + 2] += v;                 \\\n    c_array[temp2 + box2 + 3] += v;                 \\\n} while (0)\n#define VERTICAL_HALF(y_start, y_end) do {                                  \\\n    for (y = y_start; y < y_end; y++) {                                     \\\n        const int temp1 = (y \/ blocky) * xblocks4;                          \\\n        const int temp2 = ((y + yhalf) \/ blocky) * xblocks4;                \\\n        for (x = 0; x < width; x++)                                         \\\n            if (cmkp[x - cmk_linesize] == 0xff &&                           \\\n                cmkp[x               ] == 0xff &&                           \\\n                cmkp[x + cmk_linesize] == 0xff)                             \\\n                C_ARRAY_ADD(1);                                             \\\n        cmkp += cmk_linesize;                                               \\\n    }                                                                       \\\n} while (0)\n        VERTICAL_HALF(1, yhalf);\n        for (y = yhalf; y < heighta; y += yhalf) {\n            const int temp1 = (y \/ blocky) * xblocks4;\n            const int temp2 = ((y + yhalf) \/ blocky) * xblocks4;\n            for (x = 0; x < widtha; x += xhalf) {\n                const uint8_t *cmkp_tmp = cmkp + x;\n                int u, v, sum = 0;\n                for (u = 0; u < yhalf; u++) {\n                    for (v = 0; v < xhalf; v++)\n                        if (cmkp_tmp[v - cmk_linesize] == 0xff &&\n                            cmkp_tmp[v               ] == 0xff &&\n                            cmkp_tmp[v + cmk_linesize] == 0xff)\n                            sum++;\n                    cmkp_tmp += cmk_linesize;\n                }\n                if (sum)\n                    C_ARRAY_ADD(sum);\n            }\n            for (x = widtha; x < width; x++) {\n                const uint8_t *cmkp_tmp = cmkp + x;\n                int u, sum = 0;\n                for (u = 0; u < yhalf; u++) {\n                    if (cmkp_tmp[-cmk_linesize] == 0xff &&\n                        cmkp_tmp[            0] == 0xff &&\n                        cmkp_tmp[ cmk_linesize] == 0xff)\n                        sum++;\n                    cmkp_tmp += cmk_linesize;\n                }\n                if (sum)\n                    C_ARRAY_ADD(sum);\n            }\n            cmkp += cmk_linesize * yhalf;\n        }\n        VERTICAL_HALF(heighta, height - 1);\n        for (x = 0; x < arraysize; x++)\n            if (c_array[x] > max_v)\n                max_v = c_array[x];\n    }\n    return max_v;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":29729
  },
  {
    "code":"  tt_sbit_decoder_init( TT_SBitDecoder       decoder,\n                        TT_Face              face,\n                        FT_ULong             strike_index,\n                        TT_SBit_MetricsRec*  metrics )\n  {\n    FT_Error   error;\n    FT_Stream  stream = face->root.stream;\n    FT_ULong   ebdt_size;\n    error = face->goto_table( face, TTAG_CBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_EBDT, stream, &ebdt_size );\n    if ( error )\n      error = face->goto_table( face, TTAG_bdat, stream, &ebdt_size );\n    if ( error )\n      goto Exit;\n    decoder->face    = face;\n    decoder->stream  = stream;\n    decoder->bitmap  = &face->root.glyph->bitmap;\n    decoder->metrics = metrics;\n    decoder->metrics_loaded   = 0;\n    decoder->bitmap_allocated = 0;\n    decoder->ebdt_start = FT_STREAM_POS();\n    decoder->ebdt_size  = ebdt_size;\n    decoder->eblc_base  = face->sbit_table;\n    decoder->eblc_limit = face->sbit_table + face->sbit_table_size;\n    {\n      FT_Byte*  p;\n      if ( 8 + 48 * strike_index + 3 * 4 + 34 + 1 > face->sbit_table_size )\n      {\n        error = FT_THROW( Invalid_File_Format );\n        goto Exit;\n      }\n      p = decoder->eblc_base + 8 + 48 * strike_index;\n      decoder->strike_index_array = FT_NEXT_ULONG( p );\n      p                          += 4;\n      decoder->strike_index_count = FT_NEXT_ULONG( p );\n       p                          += 34;\n       decoder->bit_depth          = *p;\n      if ( decoder->strike_index_array > face->sbit_table_size             ||\n           decoder->strike_index_array + 8 * decoder->strike_index_count >\n             face->sbit_table_size                                         )\n         error = FT_THROW( Invalid_File_Format );\n     }\n  }\n",
    "vul":1,
    "flaw_line_no":[
      39,
      40,
      41
    ],
    "bigvul_id":178018
  },
  {
    "code":"NPClass* NPJSObject::npClass()\n{\n    static NPClass npClass = {\n        NP_CLASS_STRUCT_VERSION,\n        NP_Allocate,\n        NP_Deallocate,\n        0,\n        NP_HasMethod,\n        NP_Invoke,\n        NP_InvokeDefault,\n         NP_HasProperty,\n         NP_GetProperty,\n         NP_SetProperty,\n        0,\n         NP_Enumerate,\n         NP_Construct\n     };\n    return &npClass;\n}\n",
    "vul":1,
    "flaw_line_no":[
      14
    ],
    "bigvul_id":183513
  },
  {
    "code":"static void ipmi_debug_msg(const char *title, unsigned char *data,\n         unsigned int len)\n{\n  int i, pos;\n  char buf[100];\n  pos = snprintf(buf, sizeof(buf), \"%s: \", title);\n  for (i = 0; i < len; i++)\n    pos += snprintf(buf + pos, sizeof(buf) - pos,\n        \" %2.2x\", data[i]);\n  pr_debug(\"%s\\n\", buf);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":91268
  },
  {
    "code":"match(struct magic_set *ms, struct magic *magic, uint32_t nmagic,\n    const unsigned char *s, size_t nbytes, size_t offset, int mode, int text,\n    int flip, int recursion_level, int *printed_something, int *need_separator,\n    int *returnval)\n{\n  uint32_t magindex = 0;\n  unsigned int cont_level = 0;\n  int returnvalv = 0, e; \n  int firstline = 1; \n  int print = (ms->flags & (MAGIC_MIME|MAGIC_APPLE)) == 0;\n  if (returnval == NULL)\n    returnval = &returnvalv;\n  if (file_check_mem(ms, cont_level) == -1)\n    return -1;\n  for (magindex = 0; magindex < nmagic; magindex++) {\n    int flush = 0;\n    struct magic *m = &magic[magindex];\n    if (m->type != FILE_NAME)\n    if ((IS_LIBMAGIC_STRING(m->type) &&\n#define FLT (STRING_BINTEST | STRING_TEXTTEST)\n         ((text && (m->str_flags & FLT) == STRING_BINTEST) ||\n          (!text && (m->str_flags & FLT) == STRING_TEXTTEST))) ||\n        (m->flag & mode) != mode) {\n      while (magindex + 1 < nmagic &&\n                               magic[magindex + 1].cont_level != 0 &&\n             ++magindex)\n        continue;\n      continue; \n    }\n    ms->offset = m->offset;\n    ms->line = m->lineno;\n    switch (mget(ms, s, m, nbytes, offset, cont_level, mode, text,\n        flip, recursion_level + 1, printed_something,\n        need_separator, returnval)) {\n    case -1:\n      return -1;\n    case 0:\n      flush = m->reln != '!';\n      break;\n    default:\n      if (m->type == FILE_INDIRECT)\n        *returnval = 1;\n      switch (magiccheck(ms, m)) {\n      case -1:\n        return -1;\n      case 0:\n        flush++;\n        break;\n      default:\n        flush = 0;\n        break;\n      }\n      break;\n    }\n    if (flush) {\n      while (magindex < nmagic - 1 &&\n          magic[magindex + 1].cont_level != 0)\n        magindex++;\n      continue;\n    }\n    if ((e = handle_annotation(ms, m)) != 0) {\n      *returnval = 1;\n      return e;\n    }\n    if (*m->desc) {\n      *need_separator = 1;\n      *printed_something = 1;\n      if (print_sep(ms, firstline) == -1)\n        return -1;\n    }\n    if (print && mprint(ms, m) == -1)\n      return -1;\n    ms->c.li[cont_level].off = moffset(ms, m);\n    if (file_check_mem(ms, ++cont_level) == -1)\n      return -1;\n    while (magindex + 1 < nmagic && magic[magindex+1].cont_level != 0 &&\n        ++magindex) {\n      m = &magic[magindex];\n      ms->line = m->lineno; \n      if (cont_level < m->cont_level)\n        continue;\n      if (cont_level > m->cont_level) {\n        cont_level = m->cont_level;\n      }\n      ms->offset = m->offset;\n      if (m->flag & OFFADD) {\n        ms->offset +=\n            ms->c.li[cont_level - 1].off;\n      }\n#ifdef ENABLE_CONDITIONALS\n      if (m->cond == COND_ELSE ||\n          m->cond == COND_ELIF) {\n        if (ms->c.li[cont_level].last_match == 1)\n          continue;\n      }\n#endif\n      switch (mget(ms, s, m, nbytes, offset, cont_level, mode,\n          text, flip, recursion_level + 1, printed_something,\n          need_separator, returnval)) {\n      case -1:\n        return -1;\n      case 0:\n        if (m->reln != '!')\n          continue;\n        flush = 1;\n        break;\n      default:\n        if (m->type == FILE_INDIRECT)\n          *returnval = 1;\n        flush = 0;\n        break;\n      }\n      switch (flush ? 1 : magiccheck(ms, m)) {\n      case -1:\n        return -1;\n      case 0:\n#ifdef ENABLE_CONDITIONALS\n        ms->c.li[cont_level].last_match = 0;\n#endif\n        break;\n      default:\n#ifdef ENABLE_CONDITIONALS\n        ms->c.li[cont_level].last_match = 1;\n#endif\n        if (m->type != FILE_DEFAULT)\n          ms->c.li[cont_level].got_match = 1;\n        else if (ms->c.li[cont_level].got_match) {\n          ms->c.li[cont_level].got_match = 0;\n          break;\n        }\n        if ((e = handle_annotation(ms, m)) != 0) {\n          *returnval = 1;\n          return e;\n        }\n        if (*m->desc) {\n          if (!*printed_something) {\n            *printed_something = 1;\n            if (print_sep(ms, firstline)\n                == -1)\n              return -1;\n          }\n        }\n        if (*need_separator\n            && ((m->flag & NOSPACE) == 0)\n            && *m->desc) {\n          if (print &&\n              file_printf(ms, \" \") == -1)\n            return -1;\n          *need_separator = 0;\n        }\n        if (print && mprint(ms, m) == -1)\n          return -1;\n        ms->c.li[cont_level].off = moffset(ms, m);\n        if (*m->desc)\n          *need_separator = 1;\n        if (file_check_mem(ms, ++cont_level) == -1)\n          return -1;\n        break;\n      }\n    }\n    if (*printed_something) {\n      firstline = 0;\n      if (print)\n        *returnval = 1;\n    }\n    if ((ms->flags & MAGIC_CONTINUE) == 0 && *printed_something) {\n      return *returnval; \n    }\n  }\n  return *returnval;  \n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":14831
  },
  {
    "code":"void ResourceFetcher::didFinishLoading(const Resource* resource, double finishTime, int64_t encodedDataLength)\n{\n    TRACE_EVENT_ASYNC_END0(\"net\", \"Resource\", resource);\n    context().dispatchDidFinishLoading(m_documentLoader, resource->identifier(), finishTime, encodedDataLength);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":129696
  },
  {
    "code":"void streamFreeConsumer(streamConsumer *sc) {\n    raxFree(sc->pel); \n    sdsfree(sc->name);\n    zfree(sc);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":81793
  },
  {
    "code":"static int alloc_picture(H264Context *h, Picture *pic)\n{\n    int i, ret = 0;\n    av_assert0(!pic->f.data[0]);\n    pic->tf.f = &pic->f;\n    ret = ff_thread_get_buffer(h->avctx, &pic->tf, pic->reference ?\n                                                   AV_GET_BUFFER_FLAG_REF : 0);\n    if (ret < 0)\n        goto fail;\n    h->linesize   = pic->f.linesize[0];\n    h->uvlinesize = pic->f.linesize[1];\n    pic->crop     = h->sps.crop;\n    pic->crop_top = h->sps.crop_top;\n    pic->crop_left= h->sps.crop_left;\n    if (h->avctx->hwaccel) {\n        const AVHWAccel *hwaccel = h->avctx->hwaccel;\n        av_assert0(!pic->hwaccel_picture_private);\n        if (hwaccel->priv_data_size) {\n            pic->hwaccel_priv_buf = av_buffer_allocz(hwaccel->priv_data_size);\n            if (!pic->hwaccel_priv_buf)\n                return AVERROR(ENOMEM);\n            pic->hwaccel_picture_private = pic->hwaccel_priv_buf->data;\n        }\n    }\n    if (!h->qscale_table_pool) {\n        ret = init_table_pools(h);\n        if (ret < 0)\n            goto fail;\n    }\n    pic->qscale_table_buf = av_buffer_pool_get(h->qscale_table_pool);\n    pic->mb_type_buf      = av_buffer_pool_get(h->mb_type_pool);\n    if (!pic->qscale_table_buf || !pic->mb_type_buf)\n        goto fail;\n    pic->mb_type      = (uint32_t*)pic->mb_type_buf->data + 2 * h->mb_stride + 1;\n    pic->qscale_table = pic->qscale_table_buf->data + 2 * h->mb_stride + 1;\n    for (i = 0; i < 2; i++) {\n        pic->motion_val_buf[i] = av_buffer_pool_get(h->motion_val_pool);\n        pic->ref_index_buf[i]  = av_buffer_pool_get(h->ref_index_pool);\n        if (!pic->motion_val_buf[i] || !pic->ref_index_buf[i])\n            goto fail;\n        pic->motion_val[i] = (int16_t (*)[2])pic->motion_val_buf[i]->data + 4;\n        pic->ref_index[i]  = pic->ref_index_buf[i]->data;\n    }\n    return 0;\nfail:\n    unref_picture(h, pic);\n    return (ret < 0) ? ret : AVERROR(ENOMEM);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":28198
  },
  {
    "code":"static int construct_alloc_key(struct keyring_search_context *ctx,\n             struct key *dest_keyring,\n             unsigned long flags,\n             struct key_user *user,\n             struct key **_key)\n{\n  struct assoc_array_edit *edit;\n  struct key *key;\n  key_perm_t perm;\n  key_ref_t key_ref;\n  int ret;\n  kenter(\"%s,%s,,,\",\n         ctx->index_key.type->name, ctx->index_key.description);\n  *_key = NULL;\n  mutex_lock(&user->cons_lock);\n  perm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;\n  perm |= KEY_USR_VIEW;\n  if (ctx->index_key.type->read)\n    perm |= KEY_POS_READ;\n  if (ctx->index_key.type == &key_type_keyring ||\n      ctx->index_key.type->update)\n    perm |= KEY_POS_WRITE;\n  key = key_alloc(ctx->index_key.type, ctx->index_key.description,\n      ctx->cred->fsuid, ctx->cred->fsgid, ctx->cred,\n      perm, flags);\n  if (IS_ERR(key))\n    goto alloc_failed;\n  set_bit(KEY_FLAG_USER_CONSTRUCT, &key->flags);\n  if (dest_keyring) {\n    ret = __key_link_begin(dest_keyring, &ctx->index_key, &edit);\n    if (ret < 0)\n      goto link_prealloc_failed;\n  }\n  mutex_lock(&key_construction_mutex);\n  key_ref = search_process_keyrings(ctx);\n  if (!IS_ERR(key_ref))\n    goto key_already_present;\n  if (dest_keyring)\n    __key_link(key, &edit);\n  mutex_unlock(&key_construction_mutex);\n  if (dest_keyring)\n    __key_link_end(dest_keyring, &ctx->index_key, edit);\n  mutex_unlock(&user->cons_lock);\n  *_key = key;\n  kleave(\" = 0 [%d]\", key_serial(key));\n  return 0;\nkey_already_present:\n  key_put(key);\n  mutex_unlock(&key_construction_mutex);\n  key = key_ref_to_ptr(key_ref);\n  if (dest_keyring) {\n    ret = __key_link_check_live_key(dest_keyring, key);\n    if (ret == 0)\n      __key_link(key, &edit);\n    __key_link_end(dest_keyring, &ctx->index_key, edit);\n    if (ret < 0)\n      goto link_check_failed;\n  }\n  mutex_unlock(&user->cons_lock);\n  *_key = key;\n  kleave(\" = -EINPROGRESS [%d]\", key_serial(key));\n  return -EINPROGRESS;\nlink_check_failed:\n  mutex_unlock(&user->cons_lock);\n  key_put(key);\n  kleave(\" = %d [linkcheck]\", ret);\n  return ret;\nlink_prealloc_failed:\n  mutex_unlock(&user->cons_lock);\n  key_put(key);\n  kleave(\" = %d [prelink]\", ret);\n  return ret;\nalloc_failed:\n  mutex_unlock(&user->cons_lock);\n  kleave(\" = %ld\", PTR_ERR(key));\n  return PTR_ERR(key);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":41982
  },
  {
    "code":"IntSize WebViewTest::PrintICBSizeFromPageSize(const FloatSize& page_size) {\n  const float ratio = page_size.Height() \/ (float)page_size.Width();\n  const int icb_width =\n      floor(page_size.Width() * PrintContext::kPrintingMinimumShrinkFactor);\n  const int icb_height = floor(icb_width * ratio);\n  return IntSize(icb_width, icb_height);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":160879
  },
  {
    "code":"get_pdf14_device_proto(gx_device * dev, pdf14_device ** pdevproto,\n        pdf14_device * ptempdevproto, gs_gstate * pgs,\n        const gs_pdf14trans_t * pdf14pct, bool use_pdf14_accum)\n{\n    bool using_blend_cs;\n    pdf14_default_colorspace_t dev_cs =\n                pdf14_determine_default_blend_cs(dev, use_pdf14_accum,\n                                                 &using_blend_cs);\n    switch (dev_cs) {\n        case PDF14_DeviceGray:\n            *pdevproto = (pdf14_device *)&gs_pdf14_Gray_device;\n            *ptempdevproto = **pdevproto;\n            ptempdevproto->color_info.max_components = 1;\n            ptempdevproto->color_info.num_components =\n                                    ptempdevproto->color_info.max_components;\n            ptempdevproto->color_info.max_gray = 255;\n            ptempdevproto->color_info.gray_index = 0; \n            ptempdevproto->color_info.dither_grays = 256;\n            ptempdevproto->sep_device = false;\n            *pdevproto = ptempdevproto;\n            break;\n        case PDF14_DeviceRGB:\n            *pdevproto = (pdf14_device *)&gs_pdf14_RGB_device;\n            *ptempdevproto = **pdevproto;\n            ptempdevproto->sep_device = false;\n            *pdevproto = ptempdevproto;\n            break;\n        case PDF14_DeviceCMYK:\n            *pdevproto = (pdf14_device *)&gs_pdf14_CMYK_device;\n            *ptempdevproto = **pdevproto;\n            ptempdevproto->sep_device = false;\n            *pdevproto = ptempdevproto;\n            break;\n        case PDF14_DeviceCMYKspot:\n            *pdevproto = (pdf14_device *)&gs_pdf14_CMYKspot_device;\n            if (pdf14pct->params.num_spot_colors >= 0) {\n                *ptempdevproto = **pdevproto;\n                ptempdevproto->devn_params.page_spot_colors =\n                    pdf14pct->params.num_spot_colors;\n                ptempdevproto->color_info.num_components =\n                    ptempdevproto->devn_params.num_std_colorant_names +\n                    pdf14pct->params.num_spot_colors;\n                if (ptempdevproto->color_info.num_components >\n                        GS_CLIENT_COLOR_MAX_COMPONENTS)\n                    ptempdevproto->color_info.num_components =\n                        GS_CLIENT_COLOR_MAX_COMPONENTS;\n                ptempdevproto->color_info.depth =\n                                    ptempdevproto->color_info.num_components * 8;\n                ptempdevproto->sep_device = true;\n                *pdevproto = ptempdevproto;\n            }\n            break;\n        case PDF14_DeviceCustom:\n            *ptempdevproto = gs_pdf14_custom_device;\n            ptempdevproto->color_info = dev->color_info;\n            ptempdevproto->color_info.depth =\n                ptempdevproto->color_info.num_components * 8;\n            ptempdevproto->color_info.max_gray = 255;\n            ptempdevproto->color_info.max_color = 255;\n            ptempdevproto->color_info.dither_grays = 256;\n            ptempdevproto->color_info.dither_colors = 256;\n            *pdevproto = ptempdevproto;\n            break;\n        default:      \n            return_error(gs_error_rangecheck);\n    }\n    ptempdevproto->using_blend_cs = using_blend_cs;\n    return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":2928
  },
  {
    "code":"void do_set_cpus_allowed(struct task_struct *p, const struct cpumask *new_mask)\n{\n  struct rq *rq = task_rq(p);\n  bool queued, running;\n  lockdep_assert_held(&p->pi_lock);\n  queued = task_on_rq_queued(p);\n  running = task_current(rq, p);\n  if (queued) {\n    lockdep_assert_held(&rq->lock);\n    dequeue_task(rq, p, DEQUEUE_SAVE);\n  }\n  if (running)\n    put_prev_task(rq, p);\n  p->sched_class->set_cpus_allowed(p, new_mask);\n  if (running)\n    p->sched_class->set_curr_task(rq);\n  if (queued)\n    enqueue_task(rq, p, ENQUEUE_RESTORE);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":55527
  },
  {
    "code":"static int tls_prf_sha384( unsigned char *secret, size_t slen, char *label,\n                           unsigned char *random, size_t rlen,\n                           unsigned char *dstbuf, size_t dlen )\n{\n    size_t nb;\n    size_t i, j, k;\n    unsigned char tmp[128];\n    unsigned char h_i[48];\n    if( sizeof( tmp ) < 48 + strlen( label ) + rlen )\n        return( POLARSSL_ERR_SSL_BAD_INPUT_DATA );\n    nb = strlen( label );\n    memcpy( tmp + 48, label, nb );\n    memcpy( tmp + 48 + nb, random, rlen );\n    nb += rlen;\n    sha4_hmac( secret, slen, tmp + 48, nb, tmp, 1 );\n    for( i = 0; i < dlen; i += 48 )\n    {\n        sha4_hmac( secret, slen, tmp, 48 + nb, h_i, 1 );\n        sha4_hmac( secret, slen, tmp, 48,      tmp, 1 );\n        k = ( i + 48 > dlen ) ? dlen % 48 : 48;\n        for( j = 0; j < k; j++ )\n            dstbuf[i + j]  = h_i[j];\n    }\n    memset( tmp, 0, sizeof( tmp ) );\n    memset( h_i, 0, sizeof( h_i ) );\n    return( 0 );\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":29057
  },
  {
    "code":"static unsigned long count_vma_pages_range(struct mm_struct *mm,\n    unsigned long addr, unsigned long end)\n{\n  unsigned long nr_pages = 0;\n  struct vm_area_struct *vma;\n  vma = find_vma_intersection(mm, addr, end);\n  if (!vma)\n    return 0;\n  nr_pages = (min(end, vma->vm_end) -\n    max(addr, vma->vm_start)) >> PAGE_SHIFT;\n  for (vma = vma->vm_next; vma; vma = vma->vm_next) {\n    unsigned long overlap_len;\n    if (vma->vm_start > end)\n      break;\n    overlap_len = min(end, vma->vm_end) - vma->vm_start;\n    nr_pages += overlap_len >> PAGE_SHIFT;\n  }\n  return nr_pages;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":90553
  },
  {
    "code":"static int __init crypto_authenc_esn_module_init(void)\n{\n  return crypto_register_template(&crypto_authenc_esn_tmpl);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":45553
  },
  {
    "code":"userauth_pubkey(struct ssh *ssh)\n {\n   Authctxt *authctxt = ssh->authctxt;\n   struct passwd *pw = authctxt->pw;\n  struct sshbuf *b;\n   struct sshkey *key = NULL;\n  char *pkalg, *userstyle = NULL, *key_s = NULL, *ca_s = NULL;\n  u_char *pkblob, *sig, have_sig;\n   size_t blen, slen;\n   int r, pktype;\n   int authenticated = 0;\n   struct sshauthopt *authopts = NULL;\n  if (!authctxt->valid) {\n    debug2(\"%s: disabled because of invalid user\", __func__);\n    return 0;\n  }\n   if ((r = sshpkt_get_u8(ssh, &have_sig)) != 0 ||\n       (r = sshpkt_get_cstring(ssh, &pkalg, NULL)) != 0 ||\n       (r = sshpkt_get_string(ssh, &pkblob, &blen)) != 0)\n    fatal(\"%s: parse request failed: %s\", __func__, ssh_err(r));\n  pktype = sshkey_type_from_name(pkalg);\n  if (pktype == KEY_UNSPEC) {\n    verbose(\"%s: unsupported public key algorithm: %s\",\n        __func__, pkalg);\n    goto done;\n  }\n  if ((r = sshkey_from_blob(pkblob, blen, &key)) != 0) {\n    error(\"%s: could not parse key: %s\", __func__, ssh_err(r));\n    goto done;\n  }\n  if (key == NULL) {\n    error(\"%s: cannot decode key: %s\", __func__, pkalg);\n    goto done;\n  }\n  if (key->type != pktype) {\n    error(\"%s: type mismatch for decoded key \"\n        \"(received %d, expected %d)\", __func__, key->type, pktype);\n    goto done;\n  }\n  if (sshkey_type_plain(key->type) == KEY_RSA &&\n      (ssh->compat & SSH_BUG_RSASIGMD5) != 0) {\n    logit(\"Refusing RSA key because client uses unsafe \"\n        \"signature scheme\");\n    goto done;\n  }\n  if (auth2_key_already_used(authctxt, key)) {\n    logit(\"refusing previously-used %s key\", sshkey_type(key));\n    goto done;\n  }\n  if (match_pattern_list(pkalg, options.pubkey_key_types, 0) != 1) {\n    logit(\"%s: key type %s not in PubkeyAcceptedKeyTypes\",\n        __func__, sshkey_ssh_name(key));\n    goto done;\n  }\n  key_s = format_key(key);\n  if (sshkey_is_cert(key))\n    ca_s = format_key(key->cert->signature_key);\n  if (have_sig) {\n    debug3(\"%s: have %s signature for %s%s%s\",\n        __func__, pkalg, key_s,\n        ca_s == NULL ? \"\" : \" CA \",\n        ca_s == NULL ? \"\" : ca_s);\n    if ((r = sshpkt_get_string(ssh, &sig, &slen)) != 0 ||\n        (r = sshpkt_get_end(ssh)) != 0)\n      fatal(\"%s: %s\", __func__, ssh_err(r));\n    if ((b = sshbuf_new()) == NULL)\n      fatal(\"%s: sshbuf_new failed\", __func__);\n    if (ssh->compat & SSH_OLD_SESSIONID) {\n      if ((r = sshbuf_put(b, session_id2,\n          session_id2_len)) != 0)\n        fatal(\"%s: sshbuf_put session id: %s\",\n            __func__, ssh_err(r));\n    } else {\n      if ((r = sshbuf_put_string(b, session_id2,\n          session_id2_len)) != 0)\n         fatal(\"%s: sshbuf_put_string session id: %s\",\n             __func__, ssh_err(r));\n     }\n     xasprintf(&userstyle, \"%s%s%s\", authctxt->user,\n         authctxt->style ? \":\" : \"\",\n        authctxt->style ? authctxt->style : \"\");\n    if ((r = sshbuf_put_u8(b, SSH2_MSG_USERAUTH_REQUEST)) != 0 ||\n        (r = sshbuf_put_cstring(b, userstyle)) != 0 ||\n        (r = sshbuf_put_cstring(b, authctxt->service)) != 0 ||\n        (r = sshbuf_put_cstring(b, \"publickey\")) != 0 ||\n        (r = sshbuf_put_u8(b, have_sig)) != 0 ||\n        (r = sshbuf_put_cstring(b, pkalg) != 0) ||\n        (r = sshbuf_put_string(b, pkblob, blen)) != 0)\n      fatal(\"%s: build packet failed: %s\",\n          __func__, ssh_err(r));\n #ifdef DEBUG_PK\n     sshbuf_dump(b, stderr);\n #endif\n     authenticated = 0;\n     if (PRIVSEP(user_key_allowed(ssh, pw, key, 1, &authopts)) &&\n        PRIVSEP(sshkey_verify(key, sig, slen,\n        sshbuf_ptr(b), sshbuf_len(b),\n        (ssh->compat & SSH_BUG_SIGTYPE) == 0 ? pkalg : NULL,\n        ssh->compat)) == 0) {\n       authenticated = 1;\n     }\n     sshbuf_free(b);\n    free(sig);\n     auth2_record_key(authctxt, authenticated, key);\n   } else {\n     debug(\"%s: test pkalg %s pkblob %s%s%s\",\n        __func__, pkalg, key_s,\n        ca_s == NULL ? \"\" : \" CA \",\n        ca_s == NULL ? \"\" : ca_s);\n     if ((r = sshpkt_get_end(ssh)) != 0)\n       fatal(\"%s: %s\", __func__, ssh_err(r));\n    if (PRIVSEP(user_key_allowed(ssh, pw, key, 0, NULL))) {\n      if ((r = sshpkt_start(ssh, SSH2_MSG_USERAUTH_PK_OK))\n          != 0 ||\n          (r = sshpkt_put_cstring(ssh, pkalg)) != 0 ||\n          (r = sshpkt_put_string(ssh, pkblob, blen)) != 0 ||\n          (r = sshpkt_send(ssh)) != 0 ||\n          (r = ssh_packet_write_wait(ssh)) != 0)\n        fatal(\"%s: %s\", __func__, ssh_err(r));\n      authctxt->postponed = 1;\n    }\n  }\ndone:\n  if (authenticated == 1 && auth_activate_options(ssh, authopts) != 0) {\n    debug(\"%s: key options inconsistent with existing\", __func__);\n    authenticated = 0;\n  }\n  debug2(\"%s: authenticated %d pkalg %s\", __func__, authenticated, pkalg);\n  sshauthopt_free(authopts);\n  sshkey_free(key);\n  free(userstyle);\n  free(pkalg);\n   free(pkblob);\n   free(key_s);\n   free(ca_s);\n   return authenticated;\n }\n",
    "vul":1,
    "flaw_line_no":[
      5,
      7,
      8,
      13,
      14,
      15,
      16,
      103
    ],
    "bigvul_id":182278
  },
  {
    "code":"static int vfs_rename_other(struct inode *old_dir, struct dentry *old_dentry,\n          struct inode *new_dir, struct dentry *new_dentry)\n{\n  struct inode *target;\n  int error;\n  error = security_inode_rename(old_dir, old_dentry, new_dir, new_dentry);\n  if (error)\n    return error;\n  dget(new_dentry);\n  target = new_dentry->d_inode;\n  if (target)\n    mutex_lock(&target->i_mutex);\n  if (d_mountpoint(old_dentry)||d_mountpoint(new_dentry))\n    error = -EBUSY;\n  else\n    error = old_dir->i_op->rename(old_dir, old_dentry, new_dir, new_dentry);\n  if (!error) {\n    if (!(old_dir->i_sb->s_type->fs_flags & FS_RENAME_DOES_D_MOVE))\n      d_move(old_dentry, new_dentry);\n  }\n  if (target)\n    mutex_unlock(&target->i_mutex);\n  dput(new_dentry);\n  return error;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":39725
  },
  {
    "code":"local void *yarn_malloc(size_t size)\n{\n    return malloc_track(&mem_track, size);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":44839
  },
  {
    "code":"status_t OMX::freeNode(node_id node) {\n OMXNodeInstance *instance = findInstance(node);\n {\n Mutex::Autolock autoLock(mLock);\n ssize_t index = mLiveNodes.indexOfKey(IInterface::asBinder(instance->observer()));\n if (index < 0) {\n return OK;\n }\n        mLiveNodes.removeItemsAt(index);\n }\n IInterface::asBinder(instance->observer())->unlinkToDeath(this);\n status_t err = instance->freeNode(mMaster);\n {\n Mutex::Autolock autoLock(mLock);\n ssize_t index = mDispatchers.indexOfKey(node);\n        CHECK(index >= 0);\n        mDispatchers.removeItemsAt(index);\n }\n return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":174148
  },
  {
    "code":"inline void SearchBuffer::append(UChar c, bool isStart)\n{\n    m_buffer[m_cursor] = c == noBreakSpace ? ' ' : foldQuoteMarkOrSoftHyphen(c);\n    m_isCharacterStartBuffer[m_cursor] = isStart;\n    if (++m_cursor == m_target.length()) {\n        m_cursor = 0;\n        m_isBufferFull = true;\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":121572
  },
  {
    "code":"void TokenizeTest() {\n  std::vector<STR> r;\n  size_t size;\n  size = Tokenize(STR(\"This is a string\"), STR(\" \"), &r);\n  EXPECT_EQ(4U, size);\n  ASSERT_EQ(4U, r.size());\n  EXPECT_EQ(r[0], STR(\"This\"));\n  EXPECT_EQ(r[1], STR(\"is\"));\n  EXPECT_EQ(r[2], STR(\"a\"));\n  EXPECT_EQ(r[3], STR(\"string\"));\n  r.clear();\n  size = Tokenize(STR(\"one,two,three\"), STR(\",\"), &r);\n  EXPECT_EQ(3U, size);\n  ASSERT_EQ(3U, r.size());\n  EXPECT_EQ(r[0], STR(\"one\"));\n  EXPECT_EQ(r[1], STR(\"two\"));\n  EXPECT_EQ(r[2], STR(\"three\"));\n  r.clear();\n  size = Tokenize(STR(\"one,two:three;four\"), STR(\",:\"), &r);\n  EXPECT_EQ(3U, size);\n  ASSERT_EQ(3U, r.size());\n  EXPECT_EQ(r[0], STR(\"one\"));\n  EXPECT_EQ(r[1], STR(\"two\"));\n  EXPECT_EQ(r[2], STR(\"three;four\"));\n  r.clear();\n  size = Tokenize(STR(\"one,two:three;four\"), STR(\";,:\"), &r);\n  EXPECT_EQ(4U, size);\n  ASSERT_EQ(4U, r.size());\n  EXPECT_EQ(r[0], STR(\"one\"));\n  EXPECT_EQ(r[1], STR(\"two\"));\n  EXPECT_EQ(r[2], STR(\"three\"));\n  EXPECT_EQ(r[3], STR(\"four\"));\n  r.clear();\n  size = Tokenize(STR(\"one, two, three\"), STR(\",\"), &r);\n  EXPECT_EQ(3U, size);\n  ASSERT_EQ(3U, r.size());\n  EXPECT_EQ(r[0], STR(\"one\"));\n  EXPECT_EQ(r[1], STR(\" two\"));\n  EXPECT_EQ(r[2], STR(\" three\"));\n  r.clear();\n  size = Tokenize(STR(\"one, two, three, \"), STR(\",\"), &r);\n  EXPECT_EQ(4U, size);\n  ASSERT_EQ(4U, r.size());\n  EXPECT_EQ(r[0], STR(\"one\"));\n  EXPECT_EQ(r[1], STR(\" two\"));\n  EXPECT_EQ(r[2], STR(\" three\"));\n  EXPECT_EQ(r[3], STR(\" \"));\n  r.clear();\n  size = Tokenize(STR(\"one, two, three,\"), STR(\",\"), &r);\n  EXPECT_EQ(3U, size);\n  ASSERT_EQ(3U, r.size());\n  EXPECT_EQ(r[0], STR(\"one\"));\n  EXPECT_EQ(r[1], STR(\" two\"));\n  EXPECT_EQ(r[2], STR(\" three\"));\n  r.clear();\n  size = Tokenize(STR(), STR(\",\"), &r);\n  EXPECT_EQ(0U, size);\n  ASSERT_EQ(0U, r.size());\n  r.clear();\n  size = Tokenize(STR(\",\"), STR(\",\"), &r);\n  EXPECT_EQ(0U, size);\n  ASSERT_EQ(0U, r.size());\n  r.clear();\n  size = Tokenize(STR(\",;:.\"), STR(\".:;,\"), &r);\n  EXPECT_EQ(0U, size);\n  ASSERT_EQ(0U, r.size());\n  r.clear();\n  size = Tokenize(STR(\"\\t\\ta\\t\"), STR(\"\\t\"), &r);\n  EXPECT_EQ(1U, size);\n  ASSERT_EQ(1U, r.size());\n  EXPECT_EQ(r[0], STR(\"a\"));\n  r.clear();\n  size = Tokenize(STR(\"\\ta\\t\\nb\\tcc\"), STR(\"\\n\"), &r);\n  EXPECT_EQ(2U, size);\n  ASSERT_EQ(2U, r.size());\n  EXPECT_EQ(r[0], STR(\"\\ta\\t\"));\n  EXPECT_EQ(r[1], STR(\"b\\tcc\"));\n  r.clear();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":119128
  },
  {
    "code":"void InspectorClientImpl::hideHighlight()\n{\n    if (WebDevToolsAgentImpl* agent = devToolsAgent())\n        agent->hideHighlight();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":122523
  },
  {
    "code":"void RenderFrameHostImpl::SetNetworkFactoryForTesting(\n    const CreateNetworkFactoryCallback& create_network_factory_callback) {\n  DCHECK(!BrowserThread::IsThreadInitialized(BrowserThread::UI) ||\n         BrowserThread::CurrentlyOn(BrowserThread::UI));\n  DCHECK(create_network_factory_callback.is_null() ||\n         GetCreateNetworkFactoryCallbackForRenderFrame().is_null())\n      << \"It is not expected that this is called with non-null callback when \"\n      << \"another overriding callback is already set.\";\n  GetCreateNetworkFactoryCallbackForRenderFrame() =\n      create_network_factory_callback;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":152090
  },
  {
    "code":"gpc_A(Pixel *out, const Pixel *in, const Background *back)\n{\n (void)back;\n   out->r = in->r;\n   out->g = in->g;\n   out->b = in->b;\n   out->a = 65535;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":173066
  },
  {
    "code":"MagickPrivate void InitializeExceptionInfo(ExceptionInfo *exception)\n{\n  assert(exception != (ExceptionInfo *) NULL);\n  (void) ResetMagickMemory(exception,0,sizeof(*exception));\n  exception->severity=UndefinedException;\n  exception->exceptions=(void *) NewLinkedList(0);\n  exception->semaphore=AllocateSemaphoreInfo();\n  exception->signature=MagickSignature;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":71414
  },
  {
    "code":"void iwl_sta_fill_lq(struct iwl_priv *priv, struct iwl_rxon_context *ctx,\n         u8 sta_id, struct iwl_link_quality_cmd *link_cmd)\n{\n  int i, r;\n  u32 rate_flags = 0;\n  __le32 rate_n_flags;\n  lockdep_assert_held(&priv->shrd->mutex);\n  memset(link_cmd, 0, sizeof(*link_cmd));\n  if (priv->band == IEEE80211_BAND_5GHZ)\n    r = IWL_RATE_6M_INDEX;\n  else if (ctx && ctx->vif && ctx->vif->p2p)\n    r = IWL_RATE_6M_INDEX;\n  else\n    r = IWL_RATE_1M_INDEX;\n  if (r >= IWL_FIRST_CCK_RATE && r <= IWL_LAST_CCK_RATE)\n    rate_flags |= RATE_MCS_CCK_MSK;\n  rate_flags |= first_antenna(hw_params(priv).valid_tx_ant) <<\n        RATE_MCS_ANT_POS;\n  rate_n_flags = iwl_hw_set_rate_n_flags(iwl_rates[r].plcp, rate_flags);\n  for (i = 0; i < LINK_QUAL_MAX_RETRY_NUM; i++)\n    link_cmd->rs_table[i].rate_n_flags = rate_n_flags;\n  link_cmd->general_params.single_stream_ant_msk =\n      first_antenna(hw_params(priv).valid_tx_ant);\n  link_cmd->general_params.dual_stream_ant_msk =\n    hw_params(priv).valid_tx_ant &\n    ~first_antenna(hw_params(priv).valid_tx_ant);\n  if (!link_cmd->general_params.dual_stream_ant_msk) {\n    link_cmd->general_params.dual_stream_ant_msk = ANT_AB;\n  } else if (num_of_ant(hw_params(priv).valid_tx_ant) == 2) {\n    link_cmd->general_params.dual_stream_ant_msk =\n      hw_params(priv).valid_tx_ant;\n  }\n  link_cmd->agg_params.agg_dis_start_th =\n    LINK_QUAL_AGG_DISABLE_START_DEF;\n  link_cmd->agg_params.agg_time_limit =\n    cpu_to_le16(LINK_QUAL_AGG_TIME_LIMIT_DEF);\n  link_cmd->sta_id = sta_id;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":94096
  },
  {
    "code":"int jas_iccattrval_allowmodify(jas_iccattrval_t **attrvalx)\n{\n  jas_iccattrval_t *newattrval;\n  jas_iccattrval_t *attrval = *attrvalx;\n  newattrval = 0;\n  if (attrval->refcnt > 1) {\n    if (!(newattrval = jas_iccattrval_create0()))\n      goto error;\n    newattrval->ops = attrval->ops;\n    newattrval->type = attrval->type;\n    ++newattrval->refcnt;\n    if (newattrval->ops->copy) {\n      if ((*newattrval->ops->copy)(newattrval, attrval))\n        goto error;\n    } else {\n      memcpy(&newattrval->data, &attrval->data,\n        sizeof(newattrval->data));\n    }\n    *attrvalx = newattrval;\n  }\n  return 0;\nerror:\n  if (newattrval) {\n    jas_free(newattrval);\n  }\n  return -1;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":72683
  },
  {
    "code":"void ParamTraits<base::FileDescriptor>::Log(const param_type& p,\n                                            std::string* l) {\n  if (p.auto_close) {\n    l->append(StringPrintf(\"FD(%d auto-close)\", p.fd));\n  } else {\n    l->append(StringPrintf(\"FD(%d)\", p.fd));\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":125788
  },
  {
    "code":"std::string CryptohomeClient::GetStubSanitizedUsername(\n    const std::string& username) {\n  return username + kUserIdStubHashSuffix;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":120310
  },
  {
    "code":"int can_migrate_task(struct task_struct *p, struct lb_env *env)\n{\n  int tsk_cache_hot;\n  lockdep_assert_held(&env->src_rq->lock);\n  if (throttled_lb_pair(task_group(p), env->src_cpu, env->dst_cpu))\n    return 0;\n  if (!cpumask_test_cpu(env->dst_cpu, &p->cpus_allowed)) {\n    int cpu;\n    schedstat_inc(p->se.statistics.nr_failed_migrations_affine);\n    env->flags |= LBF_SOME_PINNED;\n    if (env->idle == CPU_NEWLY_IDLE || (env->flags & LBF_DST_PINNED))\n      return 0;\n    for_each_cpu_and(cpu, env->dst_grpmask, env->cpus) {\n      if (cpumask_test_cpu(cpu, &p->cpus_allowed)) {\n        env->flags |= LBF_DST_PINNED;\n        env->new_dst_cpu = cpu;\n        break;\n      }\n    }\n    return 0;\n  }\n  env->flags &= ~LBF_ALL_PINNED;\n  if (task_running(env->src_rq, p)) {\n    schedstat_inc(p->se.statistics.nr_failed_migrations_running);\n    return 0;\n  }\n  tsk_cache_hot = migrate_degrades_locality(p, env);\n  if (tsk_cache_hot == -1)\n    tsk_cache_hot = task_hot(p, env);\n  if (tsk_cache_hot <= 0 ||\n      env->sd->nr_balance_failed > env->sd->cache_nice_tries) {\n    if (tsk_cache_hot == 1) {\n      schedstat_inc(env->sd->lb_hot_gained[env->idle]);\n      schedstat_inc(p->se.statistics.nr_forced_migrations);\n    }\n    return 1;\n  }\n  schedstat_inc(p->se.statistics.nr_failed_migrations_hot);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":92474
  },
  {
    "code":" void WebPluginDelegatePepper::DidReceiveManualResponse(\n    const GURL& url, const std::string& mime_type,\n    const std::string& headers, uint32 expected_length, uint32 last_modified) {\n  instance()->DidReceiveManualResponse(url, mime_type, headers,\n                                       expected_length, last_modified);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":99866
  },
  {
    "code":"static void local_socket_close(asocket* s) {\n    D(\"entered local_socket_close. LS(%d) fd=%d\", s->id, s->fd);\n    std::lock_guard<std::recursive_mutex> lock(local_socket_list_lock);\n if (s->peer) {\n        D(\"LS(%d): closing peer. peer->id=%d peer->fd=%d\", s->id, s->peer->id, s->peer->fd);\n if (s->peer->shutdown) {\n            s->peer->shutdown(s->peer);\n }\n        s->peer->peer = nullptr;\n        s->peer->close(s->peer);\n        s->peer = nullptr;\n }\n if (s->closing || s->has_write_error || s->pkt_first == NULL) {\n int id = s->id;\n        local_socket_destroy(s);\n        D(\"LS(%d): closed\", id);\n return;\n }\n    D(\"LS(%d): closing\", s->id);\n    s->closing = 1;\n    fdevent_del(&s->fde, FDE_READ);\n    remove_socket(s);\n    D(\"LS(%d): put on socket_closing_list fd=%d\", s->id, s->fd);\n    insert_local_socket(s, &local_socket_closing_list);\n    CHECK_EQ(FDE_WRITE, s->fde.state & FDE_WRITE);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":171398
  },
  {
    "code":"void kvm_vcpu_reload_apic_access_page(struct kvm_vcpu *vcpu)\n{\n  struct page *page = NULL;\n  if (!lapic_in_kernel(vcpu))\n    return;\n  if (!kvm_x86_ops->set_apic_access_page_addr)\n    return;\n  page = gfn_to_page(vcpu->kvm, APIC_DEFAULT_PHYS_BASE >> PAGE_SHIFT);\n  if (is_error_page(page))\n    return;\n  kvm_x86_ops->set_apic_access_page_addr(vcpu, page_to_phys(page));\n  put_page(page);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":57777
  },
  {
    "code":"PlatformLayer* GraphicsContext3D::platformLayer() const\n{\n    return m_private.get();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":115150
  },
  {
    "code":"Node::InsertionNotificationRequest HTMLIFrameElement::InsertedInto(\n    ContainerNode* insertion_point) {\n  InsertionNotificationRequest result =\n      HTMLFrameElementBase::InsertedInto(insertion_point);\n  if (insertion_point->IsInDocumentTree() && GetDocument().IsHTMLDocument())\n    ToHTMLDocument(GetDocument()).AddNamedItem(name_);\n  LogAddElementIfIsolatedWorldAndInDocument(\"iframe\", srcAttr);\n  return result;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":163154
  },
  {
    "code":"void RenderFrameHostManager::SwapOutOldFrame(\n    std::unique_ptr<RenderFrameHostImpl> old_render_frame_host) {\n  TRACE_EVENT1(\"navigation\", \"RenderFrameHostManager::SwapOutOldFrame\",\n               \"FrameTreeNode id\", frame_tree_node_->frame_tree_node_id());\n  old_render_frame_host->SuppressFurtherDialogs();\n  delegate_->CancelModalDialogsForRenderManager();\n  if (!old_render_frame_host->IsRenderFrameLive())\n    return;\n  RenderFrameProxyHost* proxy =\n      CreateRenderFrameProxyHost(old_render_frame_host->GetSiteInstance(),\n                                 old_render_frame_host->render_view_host());\n  old_render_frame_host->SetNavigationHandle(nullptr);\n  old_render_frame_host->SwapOut(proxy, true);\n  proxy->set_render_frame_proxy_created(true);\n  pending_delete_hosts_.push_back(std::move(old_render_frame_host));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":148918
  },
  {
    "code":"LookupFunctionEntry(DWORD64 program_counter, PDWORD64 image_base) {\n#ifdef _WIN64\n  return RtlLookupFunctionEntry(program_counter, image_base, nullptr);\n#else\n  NOTREACHED();\n  return nullptr;\n#endif\n}\n",
    "vul":1,
    "flaw_line_no":[
      2,
      3,
      4,
      5,
      6,
      7,
      8
    ],
    "bigvul_id":185410
  },
  {
    "code":"void ClipboardUtil::CFHtmlExtractMetadata(const std::string& cf_html,\n                                          std::string* base_url,\n                                          size_t* html_start,\n                                          size_t* fragment_start,\n                                          size_t* fragment_end) {\n  if (base_url) {\n    static std::string src_url_str(\"SourceURL:\");\n    size_t line_start = cf_html.find(src_url_str);\n    if (line_start != std::string::npos) {\n      size_t src_end = cf_html.find(\"\\n\", line_start);\n      size_t src_start = line_start + src_url_str.length();\n      if (src_end != std::string::npos && src_start != std::string::npos) {\n        *base_url = cf_html.substr(src_start, src_end - src_start);\n        base::TrimWhitespace(*base_url, base::TRIM_ALL, base_url);\n      }\n    }\n  }\n  std::string cf_html_lower = StringToLowerASCII(cf_html);\n  size_t markup_start = cf_html_lower.find(\"<html\", 0);\n  if (html_start) {\n    *html_start = markup_start;\n  }\n  size_t tag_start = cf_html.find(\"<!--StartFragment\", markup_start);\n  if (tag_start == std::string::npos) {\n    static std::string start_fragment_str(\"StartFragment:\");\n    size_t start_fragment_start = cf_html.find(start_fragment_str);\n    if (start_fragment_start != std::string::npos) {\n      *fragment_start = static_cast<size_t>(atoi(cf_html.c_str() +\n          start_fragment_start + start_fragment_str.length()));\n    }\n    static std::string end_fragment_str(\"EndFragment:\");\n    size_t end_fragment_start = cf_html.find(end_fragment_str);\n    if (end_fragment_start != std::string::npos) {\n      *fragment_end = static_cast<size_t>(atoi(cf_html.c_str() +\n          end_fragment_start + end_fragment_str.length()));\n    }\n  } else {\n    *fragment_start = cf_html.find('>', tag_start) + 1;\n    size_t tag_end = cf_html.rfind(\"<!--EndFragment\", std::string::npos);\n    *fragment_end = cf_html.rfind('<', tag_end);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":130229
  },
  {
    "code":"static void fb_rotate_logo_cw(const u8 *in, u8 *out, u32 width, u32 height)\n{\n  int i, j, h = height - 1;\n  for (i = 0; i < height; i++)\n    for (j = 0; j < width; j++)\n        out[height * j + h - i] = *in++;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":31146
  },
  {
    "code":"static u64 vmci_transport_get_min_buffer_size(struct vsock_sock *vsk)\n{\n  return vmci_trans(vsk)->queue_pair_min_size;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":30380
  },
  {
    "code":" static int cdc_ncm_bind(struct usbnet *dev, struct usb_interface *intf)\n {\n  int ret;\n   if (cdc_ncm_select_altsetting(intf) != CDC_NCM_COMM_ALTSETTING_NCM)\n     return -ENODEV;\n  ret = cdc_ncm_bind_common(dev, intf, CDC_NCM_DATA_ALTSETTING_NCM, 0);\n  usbnet_link_change(dev, 0, 0);\n  return ret;\n }\n",
    "vul":1,
    "flaw_line_no":[
      3,
      6,
      7,
      8
    ],
    "bigvul_id":180495
  },
  {
    "code":"void DevToolsHttpHandler::ServerStarted(\n    std::unique_ptr<base::Thread> thread,\n    std::unique_ptr<ServerWrapper> server_wrapper,\n    std::unique_ptr<DevToolsSocketFactory> socket_factory,\n    std::unique_ptr<net::IPEndPoint> ip_address) {\n  thread_ = std::move(thread);\n  server_wrapper_ = std::move(server_wrapper);\n  socket_factory_ = std::move(socket_factory);\n  server_ip_address_ = std::move(ip_address);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":161087
  },
  {
    "code":"void RenderLayerCompositor::updateGraphicsLayersMappedToRenderLayer(RenderLayer* layer)\n{\n    if (!layer->hasCompositedLayerMapping())\n        return;\n    CompositedLayerMappingPtr compositedLayerMapping = layer->compositedLayerMapping();\n    compositedLayerMapping->updateCompositedBounds();\n    if (layer->reflectionInfo()) {\n        RenderLayer* reflectionLayer = layer->reflectionInfo()->reflectionLayer();\n        ASSERT(reflectionLayer);\n        if (reflectionLayer->hasCompositedLayerMapping())\n            reflectionLayer->compositedLayerMapping()->updateCompositedBounds();\n    }\n    compositedLayerMapping->updateGraphicsLayerConfiguration();\n    compositedLayerMapping->updateGraphicsLayerGeometry();\n    if (!layer->parent())\n        updateRootLayerPosition();\n    if (compositedLayerMapping->hasUnpositionedOverflowControlsLayers())\n        layer->scrollableArea()->positionOverflowControls();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":122224
  },
  {
    "code":"static long ioctl_file_clone_range(struct file *file, void __user *argp)\n{\n  struct file_clone_range args;\n  if (copy_from_user(&args, argp, sizeof(args)))\n    return -EFAULT;\n  return ioctl_file_clone(file, args.src_fd, args.src_offset,\n        args.src_length, args.dest_offset);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":50582
  },
  {
    "code":"static int generate_key(DH *dh)\n{\n     int ok = 0;\n     int generate_new_key = 0;\n     unsigned l;\n    BN_CTX *ctx;\n     BN_MONT_CTX *mont = NULL;\n     BIGNUM *pub_key = NULL, *priv_key = NULL;\n     ctx = BN_CTX_new();\n     if (ctx == NULL)\n         goto err;\n        generate_new_key = 1;\n    } else\n",
    "vul":1,
    "flaw_line_no":[
      6,
      9,
      10,
      11,
      12
    ],
    "bigvul_id":178504
  },
  {
    "code":"static void cbcmac_exit_tfm(struct crypto_tfm *tfm)\n{\n  struct cbcmac_tfm_ctx *ctx = crypto_tfm_ctx(tfm);\n  crypto_free_cipher(ctx->child);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":66646
  },
  {
    "code":"void InspectorAgentRegistry::discardAgents()\n{\n    for (size_t i = 0; i < m_agents.size(); i++)\n        m_agents[i]->discardAgent();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":123583
  },
  {
    "code":"static HashSet<QualifiedName>& getLandmarkRolesNotAllowed() {\n  DEFINE_STATIC_LOCAL(HashSet<QualifiedName>, landmarkRolesNotAllowed, ());\n  if (landmarkRolesNotAllowed.isEmpty()) {\n    landmarkRolesNotAllowed.insert(articleTag);\n    landmarkRolesNotAllowed.insert(asideTag);\n    landmarkRolesNotAllowed.insert(navTag);\n    landmarkRolesNotAllowed.insert(sectionTag);\n    landmarkRolesNotAllowed.insert(blockquoteTag);\n    landmarkRolesNotAllowed.insert(detailsTag);\n    landmarkRolesNotAllowed.insert(fieldsetTag);\n    landmarkRolesNotAllowed.insert(figureTag);\n    landmarkRolesNotAllowed.insert(tdTag);\n    landmarkRolesNotAllowed.insert(mainTag);\n  }\n  return landmarkRolesNotAllowed;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":138045
  },
  {
    "code":"void perf_event_exit_task(struct task_struct *child)\n{\n  struct perf_event *event, *tmp;\n  int ctxn;\n  mutex_lock(&child->perf_event_mutex);\n  list_for_each_entry_safe(event, tmp, &child->perf_event_list,\n         owner_entry) {\n    list_del_init(&event->owner_entry);\n    smp_wmb();\n    event->owner = NULL;\n  }\n  mutex_unlock(&child->perf_event_mutex);\n  for_each_task_context_nr(ctxn)\n    perf_event_exit_task_context(child, ctxn);\n  perf_event_task(child, NULL, 0);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":56078
  },
  {
    "code":"void CastStreamingNativeHandler::CallErrorCallback(\n    int stream_id,\n    const std::string& message) const {\n  v8::Isolate* isolate = context()->isolate();\n  v8::HandleScope handle_scope(isolate);\n  v8::Context::Scope context_scope(context()->v8_context());\n  v8::Local<v8::Array> event_args = v8::Array::New(isolate, 2);\n  event_args->Set(0, v8::Integer::New(isolate, stream_id));\n  event_args->Set(\n      1,\n      v8::String::NewFromUtf8(\n          isolate, message.data(), v8::String::kNormalString, message.size()));\n  context()->DispatchEvent(\"cast.streaming.rtpStream.onError\", event_args);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":169567
  },
  {
    "code":"static int ttusbdecfe_dvbs_set_frontend(struct dvb_frontend *fe)\n{\n  struct dtv_frontend_properties *p = &fe->dtv_property_cache;\n  struct ttusbdecfe_state* state = (struct ttusbdecfe_state*) fe->demodulator_priv;\n  u8 b[] = { 0x00, 0x00, 0x00, 0x01,\n       0x00, 0x00, 0x00, 0x00,\n       0x00, 0x00, 0x00, 0x01,\n       0x00, 0x00, 0x00, 0x00,\n       0x00, 0x00, 0x00, 0x00,\n       0x00, 0x00, 0x00, 0x00,\n       0x00, 0x00, 0x00, 0x00,\n       0x00, 0x00, 0x00, 0x00,\n       0x00, 0x00, 0x00, 0x00,\n       0x00, 0x00, 0x00, 0x00 };\n  __be32 freq;\n  __be32 sym_rate;\n  __be32 band;\n  __be32 lnb_voltage;\n  freq = htonl(p->frequency +\n         (state->hi_band ? LOF_HI : LOF_LO));\n  memcpy(&b[4], &freq, sizeof(u32));\n  sym_rate = htonl(p->symbol_rate);\n  memcpy(&b[12], &sym_rate, sizeof(u32));\n  band = htonl(state->hi_band ? LOF_HI : LOF_LO);\n  memcpy(&b[24], &band, sizeof(u32));\n  lnb_voltage = htonl(state->voltage);\n  memcpy(&b[28], &lnb_voltage, sizeof(u32));\n  state->config->send_command(fe, 0x71, sizeof(b), b, NULL, NULL);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":35446
  },
  {
    "code":"static bool find_andx_cmd_ofs(uint8_t *buf, size_t *pofs)\n{\n  uint8_t cmd;\n  size_t ofs;\n  cmd = CVAL(buf, smb_com);\n  SMB_ASSERT(is_andx_req(cmd));\n  ofs = smb_vwv0;\n  while (CVAL(buf, ofs) != 0xff) {\n    if (!is_andx_req(CVAL(buf, ofs))) {\n      return false;\n    }\n    ofs = SVAL(buf, ofs+2) + 4 + 1;\n    SMB_ASSERT(ofs+4 < talloc_get_size(buf));\n  }\n  *pofs = ofs;\n  return true;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":11055
  },
  {
    "code":"void fdct8x8_ref(const int16_t *in, int16_t *out, int stride, int tx_type) {\n  vp9_fdct8x8_c(in, out, stride);\n }\n",
    "vul":1,
    "flaw_line_no":[
      2
    ],
    "bigvul_id":188586
  },
  {
    "code":"void RenderViewImpl::OnEnableViewSourceMode() {\n  if (!webview())\n    return;\n  WebFrame* main_frame = webview()->mainFrame();\n  if (!main_frame)\n    return;\n  main_frame->enableViewSourceMode(true);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":108934
  },
  {
    "code":"ofputil_async_msg_type_to_string(enum ofputil_async_msg_type type)\n{\n    switch (type) {\n    case OAM_PACKET_IN:      return \"PACKET_IN\";\n    case OAM_PORT_STATUS:    return \"PORT_STATUS\";\n    case OAM_FLOW_REMOVED:   return \"FLOW_REMOVED\";\n    case OAM_ROLE_STATUS:    return \"ROLE_STATUS\";\n    case OAM_TABLE_STATUS:   return \"TABLE_STATUS\";\n    case OAM_REQUESTFORWARD: return \"REQUESTFORWARD\";\n    case OAM_N_TYPES:\n    default:\n        OVS_NOT_REACHED();\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":77478
  },
  {
    "code":"nfs3svc_encode_readres(struct svc_rqst *rqstp, __be32 *p,\n          struct nfsd3_readres *resp)\n{\n  p = encode_post_op_attr(rqstp, p, &resp->fh);\n  if (resp->status == 0) {\n    *p++ = htonl(resp->count);\n    *p++ = htonl(resp->eof);\n    *p++ = htonl(resp->count);  \n    xdr_ressize_check(rqstp, p);\n    rqstp->rq_res.page_len = resp->count;\n    if (resp->count & 3) {\n      rqstp->rq_res.tail[0].iov_base = p;\n      *p = 0;\n      rqstp->rq_res.tail[0].iov_len = 4 - (resp->count & 3);\n    }\n    return 1;\n  } else\n    return xdr_ressize_check(rqstp, p);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":65292
  },
  {
    "code":"static int pppoe_rcv(struct sk_buff *skb, struct net_device *dev,\n         struct packet_type *pt, struct net_device *orig_dev)\n{\n  struct pppoe_hdr *ph;\n  struct pppox_sock *po;\n  struct pppoe_net *pn;\n  int len;\n  skb = skb_share_check(skb, GFP_ATOMIC);\n  if (!skb)\n    goto out;\n  if (!pskb_may_pull(skb, sizeof(struct pppoe_hdr)))\n    goto drop;\n  ph = pppoe_hdr(skb);\n  len = ntohs(ph->length);\n  skb_pull_rcsum(skb, sizeof(*ph));\n  if (skb->len < len)\n    goto drop;\n  if (pskb_trim_rcsum(skb, len))\n    goto drop;\n  pn = pppoe_pernet(dev_net(dev));\n  po = get_item(pn, ph->sid, eth_hdr(skb)->h_source, dev->ifindex);\n  if (!po)\n    goto drop;\n  return sk_receive_skb(sk_pppox(po), skb, 0);\ndrop:\n  kfree_skb(skb);\nout:\n  return NET_RX_DROP;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":40289
  },
  {
    "code":"void PrintPreviewDataService::RemoveEntry(\n    const std::string& preview_ui_addr_str) {\n  PreviewDataStoreMap::iterator it = data_store_map_.find(preview_ui_addr_str);\n  if (it != data_store_map_.end())\n    data_store_map_.erase(it);\n }\n",
    "vul":1,
    "flaw_line_no":[
      2,
      3,
      4,
      5
    ],
    "bigvul_id":184397
  },
  {
    "code":"int mnt_clone_write(struct vfsmount *mnt)\n{\n  if (__mnt_is_readonly(mnt))\n    return -EROFS;\n  preempt_disable();\n  mnt_inc_writers(real_mount(mnt));\n  preempt_enable();\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":32380
  },
  {
    "code":"static int on_message_complete(http_parser *parser)\n{\n  parser_context *ctx = (parser_context *) parser->data;\n  http_subtransport *t = ctx->t;\n  t->parse_finished = 1;\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":71339
  },
  {
    "code":"void AudioNode::disconnect(AudioNode* destination,\n                           unsigned output_index,\n                           ExceptionState& exception_state) {\n  DCHECK(IsMainThread());\n  BaseAudioContext::GraphAutoLocker locker(context());\n  if (output_index >= numberOfOutputs()) {\n    exception_state.ThrowDOMException(\n        kIndexSizeError,\n        ExceptionMessages::IndexOutsideRange(\n            \"output index\", output_index, 0u,\n            ExceptionMessages::kInclusiveBound, numberOfOutputs() - 1,\n            ExceptionMessages::kInclusiveBound));\n    return;\n  }\n  unsigned number_of_disconnections = 0;\n  for (unsigned input_index = 0; input_index < destination->numberOfInputs();\n       ++input_index) {\n    if (DisconnectFromOutputIfConnected(output_index, *destination,\n                                        input_index))\n      number_of_disconnections++;\n  }\n  if (number_of_disconnections == 0) {\n    exception_state.ThrowDOMException(\n        kInvalidAccessError,\n        \"output (\" + String::Number(output_index) +\n            \") is not connected to the given destination.\");\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":161657
  },
  {
    "code":"  explicit PrintingAdapter(Plugin* plugin)\n    : pp::Printing_Dev(plugin),\n      plugin_(plugin) {\n    BrowserPpp* proxy = plugin_->ppapi_proxy();\n    CHECK(proxy != NULL);\n    ppp_printing_ = static_cast<const PPP_Printing_Dev*>(\n        proxy->GetPluginInterface(PPP_PRINTING_DEV_INTERFACE));\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":110330
  },
  {
    "code":"dissect_usb_video_streaming_input_header(proto_tree *tree, tvbuff_t *tvb, int offset)\n{\n    guint8 num_formats;\n    guint8 bm_size;\n    static const int *info_bits[] = {\n        &hf_usb_vid_streaming_info_D[0],\n        NULL\n    };\n    static const int *control_bits[] = {\n        &hf_usb_vid_streaming_control_D[0],\n        &hf_usb_vid_streaming_control_D[1],\n        &hf_usb_vid_streaming_control_D[2],\n        &hf_usb_vid_streaming_control_D[3],\n        &hf_usb_vid_streaming_control_D[4],\n        &hf_usb_vid_streaming_control_D[5],\n        NULL\n    };\n    DISSECTOR_ASSERT(array_length(control_bits) == (1+array_length(hf_usb_vid_streaming_control_D)));\n    num_formats = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_streaming_ifdesc_bNumFormats, tvb, offset,   1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_ifdesc_wTotalLength,          tvb, offset+1, 2, ENC_LITTLE_ENDIAN);\n    offset += 3;\n    dissect_usb_endpoint_address(tree, tvb, offset);\n    offset++;\n    proto_tree_add_bitmask(tree, tvb, offset, hf_usb_vid_streaming_bmInfo,\n                           ett_streaming_info, info_bits, ENC_NA);\n    proto_tree_add_item(tree, hf_usb_vid_streaming_terminal_link,        tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\n    proto_tree_add_item(tree, hf_usb_vid_streaming_still_capture_method, tvb, offset+2, 1, ENC_LITTLE_ENDIAN);\n    offset += 3;\n    proto_tree_add_item(tree, hf_usb_vid_streaming_trigger_support,      tvb, offset,   1, ENC_NA);\n    if (tvb_get_guint8(tvb, offset) > 0)\n    {\n        proto_tree_add_item(tree, hf_usb_vid_streaming_trigger_usage,    tvb, offset+1, 1, ENC_LITTLE_ENDIAN);\n    }\n    else\n    {\n        proto_tree_add_uint_format_value(tree, hf_usb_vid_streaming_trigger_usage, tvb, offset+1, 1, 0, \"Not applicable\");\n    }\n    offset += 2;\n    bm_size = tvb_get_guint8(tvb, offset);\n    proto_tree_add_item(tree, hf_usb_vid_bControlSize, tvb, offset, 1, ENC_LITTLE_ENDIAN);\n    ++offset;\n    if (bm_size > 0)\n    {\n        guint8 i;\n        for (i=0; i<num_formats; ++i)\n        {\n            proto_tree_add_bitmask_len(tree, tvb, offset, bm_size, hf_usb_vid_bmControl,\n                                       ett_streaming_controls, control_bits, &ei_usb_vid_bitmask_len,\n                                       ENC_LITTLE_ENDIAN);\n            offset += bm_size;\n        }\n    }\n    return offset;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":51835
  },
  {
    "code":"static char comparisonAffinity(Expr *pExpr){\n  char aff;\n  assert( pExpr->op==TK_EQ || pExpr->op==TK_IN || pExpr->op==TK_LT ||\n          pExpr->op==TK_GT || pExpr->op==TK_GE || pExpr->op==TK_LE ||\n          pExpr->op==TK_NE || pExpr->op==TK_IS || pExpr->op==TK_ISNOT );\n  assert( pExpr->pLeft );\n  aff = sqlite3ExprAffinity(pExpr->pLeft);\n  if( pExpr->pRight ){\n    aff = sqlite3CompareAffinity(pExpr->pRight, aff);\n  }else if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n    aff = sqlite3CompareAffinity(pExpr->x.pSelect->pEList->a[0].pExpr, aff);\n  }else if( aff==0 ){\n    aff = SQLITE_AFF_BLOB;\n  }\n  return aff;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":149107
  },
  {
    "code":"MagickExport MagickBooleanType CacheComponentGenesis(void)\n{\n  if (cache_semaphore == (SemaphoreInfo *) NULL)\n    cache_semaphore=AllocateSemaphoreInfo();\n  return(MagickTrue);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":73441
  },
  {
    "code":"virDomainGetID(virDomainPtr domain)\n{\n    VIR_DOMAIN_DEBUG(domain);\n    virResetLastError();\n    virCheckDomainReturn(domain, (unsigned int)-1);\n    return domain->id;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":93805
  },
  {
    "code":"lacks_link_info (NautilusFile *file)\n{\n    if (file->details->file_info_is_up_to_date &&\n        !file->details->link_info_is_up_to_date)\n    {\n        if (nautilus_file_is_nautilus_link (file))\n        {\n            return TRUE;\n        }\n        else\n        {\n            link_info_done (file->details->directory, file, NULL, NULL, NULL, FALSE, FALSE);\n            return FALSE;\n        }\n    }\n    else\n    {\n        return FALSE;\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":60927
  },
  {
    "code":"get_uncompressed_data(struct archive_read *a, const void **buff, size_t size,\n    size_t minimum)\n{\n  struct _7zip *zip = (struct _7zip *)a->format->data;\n  ssize_t bytes_avail;\n   if (zip->codec == _7Z_COPY && zip->codec2 == (unsigned long)-1) {\n    *buff = __archive_read_ahead(a, 1, &bytes_avail);\n     if (bytes_avail <= 0) {\n       archive_set_error(&a->archive,\n           ARCHIVE_ERRNO_FILE_FORMAT,\n          \"Truncated 7-Zip file data\");\n      return (ARCHIVE_FATAL);\n    }\n    if ((size_t)bytes_avail >\n        zip->uncompressed_buffer_bytes_remaining)\n      bytes_avail = (ssize_t)\n          zip->uncompressed_buffer_bytes_remaining;\n    if ((size_t)bytes_avail > size)\n      bytes_avail = (ssize_t)size;\n    zip->pack_stream_bytes_unconsumed = bytes_avail;\n  } else if (zip->uncompressed_buffer_pointer == NULL) {\n    archive_set_error(&(a->archive),\n        ARCHIVE_ERRNO_MISC, \"Damaged 7-Zip archive\");\n    return (ARCHIVE_FATAL);\n  } else {\n    if (minimum > zip->uncompressed_buffer_bytes_remaining) {\n      if (extract_pack_stream(a, minimum) < 0)\n        return (ARCHIVE_FATAL);\n    }\n    if (size > zip->uncompressed_buffer_bytes_remaining)\n      bytes_avail = (ssize_t)\n          zip->uncompressed_buffer_bytes_remaining;\n    else\n      bytes_avail = (ssize_t)size;\n    *buff = zip->uncompressed_buffer_pointer;\n    zip->uncompressed_buffer_pointer += bytes_avail;\n  }\n  zip->uncompressed_buffer_bytes_remaining -= bytes_avail;\n  return (bytes_avail);\n}\n",
    "vul":1,
    "flaw_line_no":[
      7
    ],
    "bigvul_id":182656
  },
  {
    "code":"void LayerWebKitThread::setSublayers(const Vector<RefPtr<LayerWebKitThread> >& sublayers)\n{\n    if (sublayers == m_sublayers)\n        return;\n    removeAllSublayers();\n    size_t listSize = sublayers.size();\n    for (size_t i = 0; i < listSize; ++i)\n        addSublayer(sublayers[i]);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":127539
  },
  {
    "code":" void AppCacheDispatcherHost::OnChannelConnected(int32 peer_pid) {\n  if (appcache_service_.get()) {\n    backend_impl_.Initialize(\n         appcache_service_.get(), &frontend_proxy_, process_id_);\n     get_status_callback_ =\n         base::Bind(&AppCacheDispatcherHost::GetStatusCallback,\n                   base::Unretained(this));\n     start_update_callback_ =\n         base::Bind(&AppCacheDispatcherHost::StartUpdateCallback,\n                   base::Unretained(this));\n     swap_cache_callback_ =\n         base::Bind(&AppCacheDispatcherHost::SwapCacheCallback,\n                   base::Unretained(this));\n   }\n }\n",
    "vul":1,
    "flaw_line_no":[
      7,
      10,
      13
    ],
    "bigvul_id":185622
  },
  {
    "code":"void InspectorController::didClearWindowObjectInMainWorld(Frame* frame)\n{\n    if (m_inspectorFrontendClient && frame == m_page->mainFrame())\n        m_inspectorFrontendClient->windowObjectCleared();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":123588
  },
  {
    "code":"static av_always_inline void last_reset(int *recode, int *last) {\n    recode[last[0]] = recode[last[1]] = recode[last[2]] = 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":59725
  },
  {
    "code":"void TabsDetectLanguageFunction::Observe(\n    int type,\n    const content::NotificationSource& source,\n    const content::NotificationDetails& details) {\n  std::string language;\n  if (type == chrome::NOTIFICATION_TAB_LANGUAGE_DETERMINED)\n    language = *content::Details<std::string>(details).ptr();\n  registrar_.RemoveAll();\n  GotLanguage(language);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":121499
  },
  {
    "code":"static inline int bta_role_to_btpan(int bta_pan_role)\n{\n int btpan_role = 0;\n    BTIF_TRACE_DEBUG(\"bta_pan_role:0x%x\", bta_pan_role);\n if (bta_pan_role & PAN_ROLE_NAP_SERVER)\n        btpan_role |= BTPAN_ROLE_PANNAP;\n if (bta_pan_role & PAN_ROLE_CLIENT)\n        btpan_role |= BTPAN_ROLE_PANU;\n return btpan_role;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":171944
  },
  {
    "code":"bool IsStrongEtag(const std::string& etag) {\n  return etag.size() > 2 && etag[0] == '\"';\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":157141
  },
  {
    "code":"void ThreadHeap::ProcessMarkingStack(Visitor* visitor) {\n  bool complete = AdvanceMarkingStackProcessing(\n      visitor, std::numeric_limits<double>::infinity());\n  CHECK(complete);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":166700
  },
  {
    "code":"SettingsPageUIHandler::SettingsPageUIHandler() {\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":130138
  },
  {
    "code":"static int ebcdic_new(BIO *bi)\n{\n    EBCDIC_OUTBUFF *wbuf;\n    wbuf = (EBCDIC_OUTBUFF *) OPENSSL_malloc(sizeof(EBCDIC_OUTBUFF) + 1024);\n    if (!wbuf)\n        return 0;\n    wbuf->alloced = 1024;\n    wbuf->buff[0] = '\\0';\n    bi->ptr = (char *)wbuf;\n    bi->init = 1;\n    bi->flags = 0;\n    return (1);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":13626
  },
  {
    "code":"bool RenderBlock::requiresColumns(int desiredColumnCount) const\n{\n    bool isPaginated = style()->isOverflowPaged() && node() != document().viewportDefiningElement();\n    return firstChild()\n        && (desiredColumnCount != 1 || !style()->hasAutoColumnWidth() || isPaginated)\n        && !firstChild()->isAnonymousColumnsBlock()\n        && !firstChild()->isAnonymousColumnSpanBlock();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":124635
  },
  {
    "code":"void TestRenderViewHost::SimulateWasHidden() {\n  GetWidget()->WasHidden();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":138846
  },
  {
    "code":"void ImageLoader::Trace(blink::Visitor* visitor) {\n  visitor->Trace(image_content_);\n  visitor->Trace(image_resource_for_image_document_);\n  visitor->Trace(element_);\n  visitor->Trace(decode_requests_);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":160323
  },
  {
    "code":" void WebstoreStandaloneInstaller::OnInstallPromptDone(\n     ExtensionInstallPrompt::Result result) {\n   if (result == ExtensionInstallPrompt::Result::USER_CANCELED) {\n    CompleteInstall(webstore_install::USER_CANCELLED, kUserCancelledError);\n     return;\n   }\n  if (result == ExtensionInstallPrompt::Result::ABORTED ||\n      !CheckRequestorAlive()) {\n    CompleteInstall(webstore_install::ABORTED, std::string());\n    return;\n  }\n  DCHECK(result == ExtensionInstallPrompt::Result::ACCEPTED);\n  std::unique_ptr<WebstoreInstaller::Approval> approval = CreateApproval();\n  ExtensionService* extension_service =\n      ExtensionSystem::Get(profile_)->extension_service();\n  const Extension* installed_extension =\n      extension_service->GetExtensionById(id_, true );\n  if (installed_extension) {\n    std::string install_message;\n    webstore_install::Result install_result = webstore_install::SUCCESS;\n    bool done = true;\n     if (ExtensionPrefs::Get(profile_)->IsExtensionBlacklisted(id_)) {\n       install_result = webstore_install::BLACKLISTED;\n      install_message = kExtensionIsBlacklisted;\n     } else if (!extension_service->IsExtensionEnabled(id_)) {\n      extension_service->EnableExtension(id_);\n    }  \n    if (done) {\n      CompleteInstall(install_result, install_message);\n      return;\n    }\n  }\n  scoped_refptr<WebstoreInstaller> installer =\n      new WebstoreInstaller(profile_, this, GetWebContents(), id_,\n                            std::move(approval), install_source_);\n  installer->Start();\n}\n",
    "vul":1,
    "flaw_line_no":[
      4,
      24,
      29
    ],
    "bigvul_id":186051
  },
  {
    "code":"int rds_get_mr(struct rds_sock *rs, char __user *optval, int optlen)\n{\n  struct rds_get_mr_args args;\n  if (optlen != sizeof(struct rds_get_mr_args))\n    return -EINVAL;\n  if (copy_from_user(&args, (struct rds_get_mr_args __user *)optval,\n         sizeof(struct rds_get_mr_args)))\n    return -EFAULT;\n  return __rds_rdma_map(rs, &args, NULL, NULL);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":84078
  },
  {
    "code":"void WebGL2RenderingContextBase::texImage2D(GLenum target,\n                                            GLint level,\n                                            GLint internalformat,\n                                            GLsizei width,\n                                            GLsizei height,\n                                            GLint border,\n                                            GLenum format,\n                                            GLenum type,\n                                            GLintptr offset) {\n  if (isContextLost())\n    return;\n  if (!ValidateTexture2DBinding(\"texImage2D\", target))\n    return;\n  if (!bound_pixel_unpack_buffer_) {\n    SynthesizeGLError(GL_INVALID_OPERATION, \"texImage2D\",\n                      \"no bound PIXEL_UNPACK_BUFFER\");\n    return;\n  }\n  if (unpack_flip_y_ || unpack_premultiply_alpha_) {\n    SynthesizeGLError(\n        GL_INVALID_OPERATION, \"texImage2D\",\n        \"FLIP_Y or PREMULTIPLY_ALPHA isn't allowed while uploading from PBO\");\n    return;\n  }\n  if (!ValidateTexFunc(\"texImage2D\", kTexImage, kSourceUnpackBuffer, target,\n                       level, internalformat, width, height, 1, border, format,\n                       type, 0, 0, 0))\n    return;\n  if (!ValidateValueFitNonNegInt32(\"texImage2D\", \"offset\", offset))\n    return;\n  ContextGL()->TexImage2D(\n      target, level, ConvertTexInternalFormat(internalformat, type), width,\n      height, border, format, type, reinterpret_cast<const void*>(offset));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":166616
  },
  {
    "code":"static int x509_v3_key_usage(const uint8_t *cert, int offset, \n        X509_CTX *x509_ctx)\n{\n    int ret = X509_OK;\n    if ((offset = asn1_is_key_usage(cert, offset)) == 0)\n        goto end_key_usage;\n    x509_ctx->key_usage_present = true;\n    x509_ctx->key_usage_is_critical = asn1_is_critical_ext(cert, &offset);\n    if (asn1_next_obj(cert, &offset, ASN1_OCTET_STRING) < 0 ||\n            asn1_get_bit_string_as_int(cert, &offset, &x509_ctx->key_usage))\n    {\n        ret = X509_NOT_OK;       \n    }\nend_key_usage:\n    return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":78915
  },
  {
    "code":"static void doubleArrayAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObject* imp = V8TestObject::toNative(info.Holder());\n    v8SetReturnValue(info, v8Array(imp->doubleArray(), info.GetIsolate()));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":130730
  },
  {
    "code":"static void bdev_inode_switch_bdi(struct inode *inode,\n      struct backing_dev_info *dst)\n{\n  struct backing_dev_info *old = inode->i_data.backing_dev_info;\n  bool wakeup_bdi = false;\n  if (unlikely(dst == old))    \n    return;\n  bdi_lock_two(&old->wb, &dst->wb);\n  spin_lock(&inode->i_lock);\n  inode->i_data.backing_dev_info = dst;\n  if (inode->i_state & I_DIRTY) {\n    if (bdi_cap_writeback_dirty(dst) && !wb_has_dirty_io(&dst->wb))\n      wakeup_bdi = true;\n    list_move(&inode->i_wb_list, &dst->wb.b_dirty);\n  }\n  spin_unlock(&inode->i_lock);\n  spin_unlock(&old->wb.list_lock);\n  spin_unlock(&dst->wb.list_lock);\n  if (wakeup_bdi)\n    bdi_wakeup_thread_delayed(dst);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":46248
  },
  {
    "code":"AffineTransform AffineTransform::inverse() const\n{\n    double determinant = det();\n    if (determinant == 0.0)\n        return AffineTransform();\n    AffineTransform result;\n    if (isIdentityOrTranslation()) {\n        result.m_transform[4] = -m_transform[4];\n        result.m_transform[5] = -m_transform[5];\n        return result;\n    }\n    result.m_transform[0] = m_transform[3] \/ determinant;\n    result.m_transform[1] = -m_transform[1] \/ determinant;\n    result.m_transform[2] = -m_transform[2] \/ determinant;\n    result.m_transform[3] = m_transform[0] \/ determinant;\n    result.m_transform[4] = (m_transform[2] * m_transform[5]\n                           - m_transform[3] * m_transform[4]) \/ determinant;\n    result.m_transform[5] = (m_transform[1] * m_transform[4]\n                           - m_transform[0] * m_transform[5]) \/ determinant;\n    return result;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":129648
  },
  {
    "code":"mrb_f_block_given_p_m(mrb_state *mrb, mrb_value self)\n{\n  mrb_callinfo *ci = &mrb->c->ci[-1];\n  mrb_callinfo *cibase = mrb->c->cibase;\n  mrb_value *bp;\n  struct RProc *p;\n  if (ci <= cibase) {\n    return mrb_false_value();\n  }\n  p = ci->proc;\n  while (p) {\n    if (MRB_PROC_SCOPE_P(p)) break;\n    p = p->upper;\n  }\n  if (p == NULL) return mrb_false_value();\n  while (cibase < ci) {\n    if (ci->proc == p) break;\n    ci--;\n  }\n  if (ci == cibase) {\n    return mrb_false_value();\n  }\n  else if (ci->env) {\n    struct REnv *e = ci->env;\n    int bidx;\n    if (e->stack == mrb->c->stbase)\n      return mrb_false_value();\n    bidx = MRB_ENV_BIDX(e);\n    if (bidx >= MRB_ENV_STACK_LEN(e))\n      return mrb_false_value();\n    bp = &e->stack[bidx];\n  }\n  else {\n    bp = ci[1].stackent+1;\n    if (ci->argc >= 0) {\n      bp += ci->argc;\n    }\n    else {\n      bp++;\n    }\n  }\n  if (mrb_nil_p(*bp))\n    return mrb_false_value();\n  return mrb_true_value();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":82176
  },
  {
    "code":"WM_SYMBOL midi *WildMidi_OpenBuffer(uint8_t *midibuffer, uint32_t size) {\n    uint8_t mus_hdr[] = { 'M', 'U', 'S', 0x1A };\n    uint8_t xmi_hdr[] = { 'F', 'O', 'R', 'M' };\n    midi * ret = NULL;\n    if (!WM_Initialized) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_NOT_INIT, NULL, 0);\n        return (NULL);\n    }\n    if (midibuffer == NULL) {\n        _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_INVALID_ARG, \"(NULL midi data buffer)\", 0);\n        return (NULL);\n    }\n    if (size > WM_MAXFILESIZE) {\n         _WM_GLOBAL_ERROR(__FUNCTION__, __LINE__, WM_ERR_LONGFIL, NULL, 0);\n         return (NULL);\n     }\n     if (memcmp(midibuffer,\"HMIMIDIP\", 8) == 0) {\n         ret = (void *) _WM_ParseNewHmp(midibuffer, size);\n     } else if (memcmp(midibuffer, \"HMI-MIDISONG061595\", 18) == 0) {\n        ret = (void *) _WM_ParseNewHmi(midibuffer, size);\n    } else if (memcmp(midibuffer, mus_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewMus(midibuffer, size);\n    } else if (memcmp(midibuffer, xmi_hdr, 4) == 0) {\n        ret = (void *) _WM_ParseNewXmi(midibuffer, size);\n    } else {\n        ret = (void *) _WM_ParseNewMidi(midibuffer, size);\n    }\n    if (ret) {\n        if (add_handle(ret) != 0) {\n            WildMidi_Close(ret);\n            ret = NULL;\n        }\n    }\n    return (ret);\n}\n",
    "vul":1,
    "flaw_line_no":[
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      26,
      28,
      29,
      30,
      31,
      34
    ],
    "bigvul_id":182542
  },
  {
    "code":"int mm_answer_auth2_read_banner(int sock, Buffer *m)\n{\n  char *banner;\n  buffer_clear(m);\n  banner = auth2_read_banner();\n  buffer_put_cstring(m, banner != NULL ? banner : \"\");\n  mm_request_send(sock, MONITOR_ANS_AUTH2_READ_BANNER, m);\n  free(banner);\n  return (0);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":42085
  },
  {
    "code":"static void ext4_put_super(struct super_block *sb)\n{\n  struct ext4_sb_info *sbi = EXT4_SB(sb);\n  struct ext4_super_block *es = sbi->s_es;\n  int i, err;\n  ext4_unregister_li_request(sb);\n  dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);\n  flush_workqueue(sbi->dio_unwritten_wq);\n  destroy_workqueue(sbi->dio_unwritten_wq);\n  lock_super(sb);\n  if (sb->s_dirt)\n    ext4_commit_super(sb, 1);\n  if (sbi->s_journal) {\n    err = jbd2_journal_destroy(sbi->s_journal);\n    sbi->s_journal = NULL;\n    if (err < 0)\n      ext4_abort(sb, \"Couldn't clean up the journal\");\n  }\n  del_timer(&sbi->s_err_report);\n  ext4_release_system_zone(sb);\n  ext4_mb_release(sb);\n  ext4_ext_release(sb);\n  ext4_xattr_put_super(sb);\n  if (!(sb->s_flags & MS_RDONLY)) {\n    EXT4_CLEAR_INCOMPAT_FEATURE(sb, EXT4_FEATURE_INCOMPAT_RECOVER);\n    es->s_state = cpu_to_le16(sbi->s_mount_state);\n    ext4_commit_super(sb, 1);\n  }\n  if (sbi->s_proc) {\n    remove_proc_entry(sb->s_id, ext4_proc_root);\n  }\n  kobject_del(&sbi->s_kobj);\n  for (i = 0; i < sbi->s_gdb_count; i++)\n    brelse(sbi->s_group_desc[i]);\n  ext4_kvfree(sbi->s_group_desc);\n  ext4_kvfree(sbi->s_flex_groups);\n  percpu_counter_destroy(&sbi->s_freeclusters_counter);\n  percpu_counter_destroy(&sbi->s_freeinodes_counter);\n  percpu_counter_destroy(&sbi->s_dirs_counter);\n  percpu_counter_destroy(&sbi->s_dirtyclusters_counter);\n  brelse(sbi->s_sbh);\n#ifdef CONFIG_QUOTA\n  for (i = 0; i < MAXQUOTAS; i++)\n    kfree(sbi->s_qf_names[i]);\n#endif\n  if (!list_empty(&sbi->s_orphan))\n    dump_orphan_list(sb, sbi);\n  J_ASSERT(list_empty(&sbi->s_orphan));\n  invalidate_bdev(sb->s_bdev);\n  if (sbi->journal_bdev && sbi->journal_bdev != sb->s_bdev) {\n    sync_blockdev(sbi->journal_bdev);\n    invalidate_bdev(sbi->journal_bdev);\n    ext4_blkdev_remove(sbi);\n  }\n  if (sbi->s_mmp_tsk)\n    kthread_stop(sbi->s_mmp_tsk);\n  sb->s_fs_info = NULL;\n  unlock_super(sb);\n  kobject_put(&sbi->s_kobj);\n  wait_for_completion(&sbi->s_kobj_unregister);\n  kfree(sbi->s_blockgroup_lock);\n  kfree(sbi);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":20512
  },
  {
    "code":"struct mem_cgroup *parent_mem_cgroup(struct mem_cgroup *memcg)\n{\n  if (!memcg->res.parent)\n    return NULL;\n  return mem_cgroup_from_res_counter(memcg->res.parent, res);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":21168
  },
  {
    "code":"  Ins_SUB( INS_ARG )\n  {\n    DO_SUB\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":10184
  },
  {
    "code":"static inline int nlm_pidbusy(struct nlm_host *host, uint32_t pid)\n{\n  struct nlm_lockowner *lockowner;\n  list_for_each_entry(lockowner, &host->h_lockowners, list) {\n    if (lockowner->pid == pid)\n      return -EBUSY;\n  }\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":34857
  },
  {
    "code":"dissect_SEC_DESC_BUF(tvbuff_t *tvb, int offset, packet_info *pinfo,\n         proto_tree *tree, dcerpc_info *di, guint8 *drep)\n{\n  proto_tree *subtree;\n  guint32 len;\n  subtree = proto_tree_add_subtree(\n    tree, tvb, offset, 0, ett_SEC_DESC_BUF, NULL, \"Security descriptor buffer\");\n  offset = dissect_ndr_uint32(\n    tvb, offset, pinfo, subtree, di, drep,\n    hf_secdescbuf_maxlen, NULL);\n  offset = dissect_ndr_uint32(\n    tvb, offset, pinfo, subtree, di, drep,\n    hf_secdescbuf_undoc, NULL);\n  offset = dissect_ndr_uint32(\n    tvb, offset, pinfo, subtree, di, drep,\n    hf_secdescbuf_len, &len);\n  dissect_nt_sec_desc(\n    tvb, offset, pinfo, subtree, drep, TRUE, len,\n    &spoolss_printer_access_mask_info);\n  offset += len;\n  return offset;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":52024
  },
  {
    "code":"PagePopupBlackBerry* WebPage::popup()\n{\n    return d->m_selectPopup;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":111283
  },
  {
    "code":"SYSCALL_DEFINE1(setgid, gid_t, gid)\n{\n  struct user_namespace *ns = current_user_ns();\n  const struct cred *old;\n  struct cred *new;\n  int retval;\n  kgid_t kgid;\n  kgid = make_kgid(ns, gid);\n  if (!gid_valid(kgid))\n    return -EINVAL;\n  new = prepare_creds();\n  if (!new)\n    return -ENOMEM;\n  old = current_cred();\n  retval = -EPERM;\n  if (nsown_capable(CAP_SETGID))\n    new->gid = new->egid = new->sgid = new->fsgid = kgid;\n  else if (gid_eq(kgid, old->gid) || gid_eq(kgid, old->sgid))\n    new->egid = new->fsgid = kgid;\n  else\n    goto error;\n  return commit_creds(new);\nerror:\n  abort_creds(new);\n  return retval;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":21512
  },
  {
    "code":"  void GoToOffsetWithParams(int offset,\n                            const PageState& state,\n                            const CommonNavigationParams common_params,\n                            CommitNavigationParams commit_params) {\n    EXPECT_TRUE(common_params.transition & ui::PAGE_TRANSITION_FORWARD_BACK);\n    int pending_offset = offset + view()->history_list_offset_;\n    commit_params.page_state = state;\n    commit_params.nav_entry_id = pending_offset + 1;\n    commit_params.pending_history_list_offset = pending_offset;\n    commit_params.current_history_list_offset = view()->history_list_offset_;\n    commit_params.current_history_list_length = view()->history_list_length_;\n    frame()->Navigate(common_params, commit_params);\n    FrameLoadWaiter(frame()).Wait();\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":152577
  },
  {
    "code":"static ssize_t bcm_char_read(struct file *filp, char __user *buf, size_t size,\n           loff_t *f_pos)\n{\n  struct bcm_tarang_data *pTarang = filp->private_data;\n  struct bcm_mini_adapter *Adapter = pTarang->Adapter;\n  struct sk_buff *Packet = NULL;\n  ssize_t PktLen = 0;\n  int wait_ret_val = 0;\n  unsigned long ret = 0;\n  wait_ret_val = wait_event_interruptible(Adapter->process_read_wait_queue,\n            (pTarang->RxAppControlHead ||\n             Adapter->device_removed));\n  if ((wait_ret_val == -ERESTARTSYS)) {\n    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n        \"Exiting as i've been asked to exit!!!\\n\");\n    return wait_ret_val;\n  }\n  if (Adapter->device_removed) {\n    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n        \"Device Removed... Killing the Apps...\\n\");\n    return -ENODEV;\n  }\n  if (FALSE == Adapter->fw_download_done)\n    return -EACCES;\n  down(&Adapter->RxAppControlQueuelock);\n  if (pTarang->RxAppControlHead) {\n    Packet = pTarang->RxAppControlHead;\n    DEQUEUEPACKET(pTarang->RxAppControlHead,\n            pTarang->RxAppControlTail);\n    pTarang->AppCtrlQueueLen--;\n  }\n  up(&Adapter->RxAppControlQueuelock);\n  if (Packet) {\n    PktLen = Packet->len;\n    ret = copy_to_user(buf, Packet->data,\n           min_t(size_t, PktLen, size));\n    if (ret) {\n      dev_kfree_skb(Packet);\n      BCM_DEBUG_PRINT(Adapter, DBG_TYPE_PRINTK, 0, 0,\n          \"Returning from copy to user failure\\n\");\n      return -EFAULT;\n    }\n    BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL,\n        \"Read %zd Bytes From Adapter packet = %p by process %d!\\n\",\n        PktLen, Packet, current->pid);\n    dev_kfree_skb(Packet);\n  }\n  BCM_DEBUG_PRINT(Adapter, DBG_TYPE_OTHERS, OSAL_DBG, DBG_LVL_ALL, \"<\\n\");\n  return PktLen;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":29461
  },
  {
    "code":"size_t ZSTD_resetCStream(ZSTD_CStream* zcs, unsigned long long pledgedSrcSize)\n{\n    ZSTD_CCtx_params params = zcs->requestedParams;\n    DEBUGLOG(4, \"ZSTD_resetCStream: pledgedSrcSize = %u\", (U32)pledgedSrcSize);\n    if (pledgedSrcSize==0) pledgedSrcSize = ZSTD_CONTENTSIZE_UNKNOWN;\n    params.fParams.contentSizeFlag = 1;\n    return ZSTD_resetCStream_internal(zcs, NULL, 0, ZSTD_dct_auto, zcs->cdict, params, pledgedSrcSize);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":90110
  },
  {
    "code":"static void locationReplaceableAttributeGetterCallback(v8::Local<v8::String>, const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TRACE_EVENT_SET_SAMPLING_STATE(\"Blink\", \"DOMGetter\");\n    TestObjectPythonV8Internal::locationReplaceableAttributeGetter(info);\n    TRACE_EVENT_SET_SAMPLING_STATE(\"V8\", \"V8Execution\");\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":131447
  },
  {
    "code":"void GaiaCookieManagerService::ExternalCcResultFetcher::OnURLFetchComplete(\n    const net::URLFetcher* source) {\n  const GURL& url = source->GetOriginalURL();\n  const net::URLRequestStatus& status = source->GetStatus();\n  int response_code = source->GetResponseCode();\n  if (status.is_success() && response_code == net::HTTP_OK &&\n      fetchers_.count(url) > 0) {\n    std::string data;\n    source->GetResponseAsString(&data);\n    if (data.size() > 16)\n      data.resize(16);\n    results_[fetchers_[url].first] = data;\n    DCHECK_EQ(source, fetchers_[url].second);\n    fetchers_.erase(url);\n    delete source;\n    if (fetchers_.empty()) {\n      CleanupTransientState();\n      GetCheckConnectionInfoCompleted(true);\n    }\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":140193
  },
  {
    "code":"static int _nfs4_proc_open(struct nfs4_opendata *data)\n{\n  struct inode *dir = data->dir->d_inode;\n  struct nfs_server *server = NFS_SERVER(dir);\n  struct nfs_openargs *o_arg = &data->o_arg;\n  struct nfs_openres *o_res = &data->o_res;\n  int status;\n  status = nfs4_run_open_task(data, 0);\n  if (!data->rpc_done)\n    return status;\n  if (status != 0) {\n    if (status == -NFS4ERR_BADNAME &&\n        !(o_arg->open_flags & O_CREAT))\n      return -ENOENT;\n    return status;\n  }\n  nfs_fattr_map_and_free_names(server, &data->f_attr);\n  if (o_arg->open_flags & O_CREAT) {\n    update_changeattr(dir, &o_res->cinfo);\n    nfs_post_op_update_inode(dir, o_res->dir_attr);\n  } else\n    nfs_refresh_inode(dir, o_res->dir_attr);\n  if ((o_res->rflags & NFS4_OPEN_RESULT_LOCKTYPE_POSIX) == 0)\n    server->caps &= ~NFS_CAP_POSIX_LOCK;\n  if(o_res->rflags & NFS4_OPEN_RESULT_CONFIRM) {\n    status = _nfs4_proc_open_confirm(data);\n    if (status != 0)\n      return status;\n  }\n  if (!(o_res->f_attr->valid & NFS_ATTR_FATTR))\n    _nfs4_proc_getattr(server, &o_res->fh, o_res->f_attr);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":19828
  },
  {
    "code":"R_API int r_bin_file_ref(RBin *bin, RBinFile *a) {\n  RBinObject *o = r_bin_cur_object (bin);\n  if (a && o) {\n    o->referenced--;\n    return true;\n  }\n  return false;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":60136
  },
  {
    "code":"void usb_wakeup_notification(struct usb_device *hdev,\n    unsigned int portnum)\n{\n  struct usb_hub *hub;\n  if (!hdev)\n    return;\n  hub = usb_hub_to_struct_hub(hdev);\n  if (hub) {\n    set_bit(portnum, hub->wakeup_bits);\n    kick_hub_wq(hub);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":56840
  },
  {
    "code":"ErrorState* GLES2DecoderImpl::GetErrorState() {\n  return error_state_.get();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":154159
  },
  {
    "code":"SkBitmap ChromeContentUtilityClient::DecodeImage(\n    const std::vector<unsigned char>& encoded_data, bool shrink_to_fit) {\n  SkBitmap decoded_image;\n  if (encoded_data.empty())\n    return decoded_image;\n  decoded_image = content::DecodeImage(&encoded_data[0],\n                                       gfx::Size(),\n                                       encoded_data.size());\n  int64_t struct_size = sizeof(ChromeUtilityHostMsg_DecodeImage_Succeeded);\n  int64_t image_size = decoded_image.computeSize64();\n  int halves = 0;\n  while (struct_size + (image_size >> 2*halves) > max_ipc_message_size_)\n    halves++;\n  if (halves) {\n    if (shrink_to_fit) {\n      decoded_image = skia::ImageOperations::Resize(\n          decoded_image, skia::ImageOperations::RESIZE_LANCZOS3,\n          decoded_image.width() >> halves, decoded_image.height() >> halves);\n    } else {\n      decoded_image.reset();\n      LOG(ERROR) << \"Decoded image too large for IPC message\";\n    }\n  }\n  return decoded_image;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":133830
  },
  {
    "code":"void trace_buffered_event_enable(void)\n{\n  struct ring_buffer_event *event;\n  struct page *page;\n  int cpu;\n  WARN_ON_ONCE(!mutex_is_locked(&event_mutex));\n  if (trace_buffered_event_ref++)\n    return;\n  for_each_tracing_cpu(cpu) {\n    page = alloc_pages_node(cpu_to_node(cpu),\n          GFP_KERNEL | __GFP_NORETRY, 0);\n    if (!page)\n      goto failed;\n    event = page_address(page);\n    memset(event, 0, sizeof(*event));\n    per_cpu(trace_buffered_event, cpu) = event;\n    preempt_disable();\n    if (cpu == smp_processor_id() &&\n        this_cpu_read(trace_buffered_event) !=\n        per_cpu(trace_buffered_event, cpu))\n      WARN_ON_ONCE(1);\n    preempt_enable();\n  }\n  return;\n failed:\n  trace_buffered_event_disable();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":81377
  },
  {
    "code":"static void spl_ptr_heap_zval_dtor(spl_ptr_heap_element elem TSRMLS_DC) { \n  if (elem) {\n    zval_ptr_dtor((zval **)&elem);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":14920
  },
  {
    "code":"static void x86_pmu_disable(struct pmu *pmu)\n{\n  struct cpu_hw_events *cpuc = &__get_cpu_var(cpu_hw_events);\n  if (!x86_pmu_initialized())\n    return;\n  if (!cpuc->enabled)\n    return;\n  cpuc->n_added = 0;\n  cpuc->enabled = 0;\n  barrier();\n  x86_pmu.disable_all();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":25784
  },
  {
    "code":"bool OSExchangeDataProviderAura::GetString(base::string16* data) const {\n  if ((formats_ & OSExchangeData::STRING) == 0)\n    return false;\n  *data = string_;\n   return true;\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":134615
  },
  {
    "code":"void vrend_bind_shader(struct vrend_context *ctx,\n                       uint32_t handle, uint32_t type)\n{\n   struct vrend_shader_selector *sel;\n   if (type > PIPE_SHADER_GEOMETRY)\n      return;\n   if (handle == 0) {\n      ctx->sub->shader_dirty = true;\n      vrend_shader_state_reference(&ctx->sub->shaders[type], NULL);\n      return;\n   }\n   sel = vrend_object_lookup(ctx->sub->object_hash, handle, VIRGL_OBJECT_SHADER);\n   if (!sel)\n      return;\n   if (sel->type != type)\n      return;\n   if (ctx->sub->shaders[sel->type] != sel)\n      ctx->sub->shader_dirty = true;\n   vrend_shader_state_reference(&ctx->sub->shaders[sel->type], sel);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":8823
  },
  {
    "code":"TimeRanges* HTMLMediaElement::played() {\n  if (playing_) {\n    double time = currentTime();\n    if (time > last_seek_time_)\n      AddPlayedRange(last_seek_time_, time);\n  }\n  if (!played_time_ranges_)\n    played_time_ranges_ = TimeRanges::Create();\n  return played_time_ranges_->Copy();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":142963
  },
  {
    "code":"ZEND_API ulong zend_ts_get_hash_value(TsHashTable *ht, char *arKey, uint nKeyLength)\n{\n  ulong retval;\n  begin_read(ht);\n  retval = zend_get_hash_value(arKey, nKeyLength);\n  end_read(ht);\n  return retval;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":7439
  },
  {
    "code":"i915_gem_execbuffer_retire_commands(struct drm_device *dev,\n            struct drm_file *file,\n            struct intel_ring_buffer *ring)\n{\n  struct drm_i915_gem_request *request;\n  u32 invalidate;\n  invalidate = I915_GEM_DOMAIN_COMMAND;\n  if (INTEL_INFO(dev)->gen >= 4)\n    invalidate |= I915_GEM_DOMAIN_SAMPLER;\n  if (ring->flush(ring, invalidate, 0)) {\n    i915_gem_next_request_seqno(ring);\n    return;\n  }\n  request = kzalloc(sizeof(*request), GFP_KERNEL);\n  if (request == NULL || i915_add_request(ring, file, request)) {\n    i915_gem_next_request_seqno(ring);\n    kfree(request);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":19791
  },
  {
    "code":"static void nfs_delegation_clear_all(struct nfs_client *clp)\n{\n  nfs_delegation_mark_reclaim(clp);\n  nfs_delegation_reap_unclaimed(clp);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":22968
  },
  {
    "code":"rdpsnd_record(const void *data, unsigned int size)\n{\n  UNUSED(data);\n  UNUSED(size);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":93075
  },
  {
    "code":"AcpiNsExecModuleCode (\n    ACPI_OPERAND_OBJECT     *MethodObj,\n    ACPI_EVALUATE_INFO      *Info)\n{\n    ACPI_OPERAND_OBJECT     *ParentObj;\n    ACPI_NAMESPACE_NODE     *ParentNode;\n    ACPI_OBJECT_TYPE        Type;\n    ACPI_STATUS             Status;\n    ACPI_FUNCTION_TRACE (NsExecModuleCode);\n    ParentNode = ACPI_CAST_PTR (\n        ACPI_NAMESPACE_NODE, MethodObj->Method.NextObject);\n    Type = AcpiNsGetType (ParentNode);\n    if ((Type == ACPI_TYPE_DEVICE) && ParentNode->Object)\n    {\n        MethodObj->Method.Dispatch.Handler =\n            ParentNode->Object->Device.Handler;\n    }\n    MethodObj->Method.NextObject = NULL;\n    memset (Info, 0, sizeof (ACPI_EVALUATE_INFO));\n    Info->PrefixNode = ParentNode;\n    ParentObj = AcpiNsGetAttachedObject (ParentNode);\n    if (ParentObj)\n    {\n        AcpiUtAddReference (ParentObj);\n    }\n    Status = AcpiNsAttachObject (ParentNode, MethodObj, ACPI_TYPE_METHOD);\n    if (ACPI_FAILURE (Status))\n    {\n        goto Exit;\n    }\n    Status = AcpiNsEvaluate (Info);\n    ACPI_DEBUG_PRINT ((ACPI_DB_INIT_NAMES,\n        \"Executed module-level code at %p\\n\",\n        MethodObj->Method.AmlStart));\n    if (Info->ReturnObject)\n    {\n        AcpiUtRemoveReference (Info->ReturnObject);\n    }\n    AcpiNsDetachObject (ParentNode);\n    if (ParentObj)\n    {\n        Status = AcpiNsAttachObject (ParentNode, ParentObj, Type);\n    }\n    else\n    {\n        ParentNode->Type = (UINT8) Type;\n    }\nExit:\n    if (ParentObj)\n    {\n        AcpiUtRemoveReference (ParentObj);\n    }\n    return_VOID;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":61970
  },
  {
    "code":"void ChromeExtensionsDispatcherDelegate::InitOriginPermissions(\n    const extensions::Extension* extension,\n    bool is_extension_active) {\n  if (is_extension_active &&\n      extension->permissions_data()->HasAPIPermission(\n          extensions::APIPermission::kManagement)) {\n    blink::WebSecurityPolicy::addOriginAccessWhitelistEntry(\n        extension->url(),\n        blink::WebString::fromUTF8(content::kChromeUIScheme),\n        blink::WebString::fromUTF8(chrome::kChromeUIExtensionIconHost),\n        false);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":145192
  },
  {
    "code":"static int atusb_read_reg(struct atusb *atusb, uint8_t reg)\n {\n   struct usb_device *usb_dev = atusb->usb_dev;\n   int ret;\n   uint8_t value;\n   dev_dbg(&usb_dev->dev, \"atusb: reg = 0x%x\\n\", reg);\n   ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),\n         ATUSB_REG_READ, ATUSB_REQ_FROM_DEV,\n        0, reg, &value, 1, 1000);\n  return ret >= 0 ? value : ret;\n }\n",
    "vul":1,
    "flaw_line_no":[
      6,
      7,
      8,
      9,
      10
    ],
    "bigvul_id":181564
  },
  {
    "code":"ProfilingProcessHost::~ProfilingProcessHost() {\n  if (is_registered_)\n    Unregister();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":163049
  },
  {
    "code":"void DatabaseImpl::SetIndexesReady(int64_t transaction_id,\n                                   int64_t object_store_id,\n                                   const std::vector<int64_t>& index_ids) {\n  idb_runner_->PostTask(\n      FROM_HERE,\n      base::Bind(&IDBThreadHelper::SetIndexesReady, base::Unretained(helper_),\n                 transaction_id, object_store_id, index_ids));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":149321
  },
  {
    "code":"void GLES2DecoderImpl::DoUniform3fv(\n    GLint fake_location, GLsizei count, const GLfloat* value) {\n  GLenum type = 0;\n  GLint real_location = -1;\n  if (!PrepForSetUniformByLocation(fake_location,\n                                   \"glUniform3fv\",\n                                   Program::kUniform3f,\n                                   &real_location,\n                                   &type,\n                                   &count)) {\n    return;\n  }\n  if (type == GL_BOOL_VEC3) {\n    GLsizei num_values = count * 3;\n    scoped_ptr<GLint[]> temp(new GLint[num_values]);\n    for (GLsizei ii = 0; ii < num_values; ++ii) {\n      temp[ii] = static_cast<GLint>(value[ii] != 0.0f);\n    }\n    glUniform3iv(real_location, count, temp.get());\n  } else {\n    glUniform3fv(real_location, count, value);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":129327
  },
  {
    "code":"ZEND_API int add_get_index_long(zval *arg, ulong index, long l, void **dest) \n{\n  zval *tmp;\n  MAKE_STD_ZVAL(tmp);\n  ZVAL_LONG(tmp, l);\n  return zend_hash_index_update(Z_ARRVAL_P(arg), index, (void *) &tmp, sizeof(zval *), dest);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":13729
  },
  {
    "code":"rdp_parse_brush(STREAM s, BRUSH * brush, uint32 present)\n{\n  if (present & 1)\n    in_uint8(s, brush->xorigin);\n  if (present & 2)\n    in_uint8(s, brush->yorigin);\n  if (present & 4)\n    in_uint8(s, brush->style);\n  if (present & 8)\n    in_uint8(s, brush->pattern[0]);\n  if (present & 16)\n    in_uint8a(s, &brush->pattern[1], 7);\n  return s_check(s);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":92983
  },
  {
    "code":"String Document::OutgoingReferrer() const {\n  const Document* referrer_document = this;\n  if (GetSecurityOrigin()->IsOpaque())\n    return String();\n  if (LocalFrame* frame = frame_) {\n    while (frame->GetDocument()->IsSrcdocDocument()) {\n      frame = To<LocalFrame>(frame->Tree().Parent());\n      DCHECK(frame);\n    }\n    referrer_document = frame->GetDocument();\n  }\n  return referrer_document->url_.StrippedForUseAsReferrer();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":141173
  },
  {
    "code":"ImageView::Alignment ImageView::GetVerticalAlignment() {\n  return vert_alignment_;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":98426
  },
  {
    "code":"void CopyLocalFileOnBlockingPool(\n    const FilePath& src_file_path,\n    const FilePath& dest_file_path,\n    GDataFileError* error) {\n  DCHECK(error);\n  *error = file_util::CopyFile(src_file_path, dest_file_path) ?\n      GDATA_FILE_OK : GDATA_FILE_ERROR_FAILED;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":125345
  },
  {
    "code":"copy_msqid_to_user(void __user *buf, struct msqid64_ds *in, int version)\n{\n  switch(version) {\n  case IPC_64:\n    return copy_to_user(buf, in, sizeof(*in));\n  case IPC_OLD:\n  {\n    struct msqid_ds out;\n    memset(&out, 0, sizeof(out));\n    ipc64_perm_to_ipc_perm(&in->msg_perm, &out.msg_perm);\n    out.msg_stime    = in->msg_stime;\n    out.msg_rtime    = in->msg_rtime;\n    out.msg_ctime    = in->msg_ctime;\n    if (in->msg_cbytes > USHRT_MAX)\n      out.msg_cbytes  = USHRT_MAX;\n    else\n      out.msg_cbytes  = in->msg_cbytes;\n    out.msg_lcbytes    = in->msg_cbytes;\n    if (in->msg_qnum > USHRT_MAX)\n      out.msg_qnum  = USHRT_MAX;\n    else\n      out.msg_qnum  = in->msg_qnum;\n    if (in->msg_qbytes > USHRT_MAX)\n      out.msg_qbytes  = USHRT_MAX;\n    else\n      out.msg_qbytes  = in->msg_qbytes;\n    out.msg_lqbytes    = in->msg_qbytes;\n    out.msg_lspid    = in->msg_lspid;\n    out.msg_lrpid    = in->msg_lrpid;\n    return copy_to_user(buf, &out, sizeof(out));\n  }\n  default:\n    return -EINVAL;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":29504
  },
  {
    "code":"static int unlink_urbs (struct usbnet *dev, struct sk_buff_head *q)\n{\n  unsigned long    flags;\n  struct sk_buff    *skb;\n  int      count = 0;\n  spin_lock_irqsave (&q->lock, flags);\n  while (!skb_queue_empty(q)) {\n    struct skb_data    *entry;\n    struct urb    *urb;\n    int      retval;\n    skb_queue_walk(q, skb) {\n      entry = (struct skb_data *) skb->cb;\n      if (entry->state != unlink_start)\n        goto found;\n    }\n    break;\nfound:\n    entry->state = unlink_start;\n    urb = entry->urb;\n    usb_get_urb(urb);\n    spin_unlock_irqrestore(&q->lock, flags);\n    retval = usb_unlink_urb (urb);\n    if (retval != -EINPROGRESS && retval != 0)\n      netdev_dbg(dev->net, \"unlink urb err, %d\\n\", retval);\n    else\n      count++;\n    usb_put_urb(urb);\n    spin_lock_irqsave(&q->lock, flags);\n  }\n  spin_unlock_irqrestore (&q->lock, flags);\n  return count;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":94888
  },
  {
    "code":"void Browser::SyncHistoryWithTabs(int index) {\n  SessionService* session_service =\n      SessionServiceFactory::GetForProfileIfExisting(profile());\n  if (session_service) {\n    for (int i = index; i < tab_count(); ++i) {\n      WebContents* web_contents = chrome::GetWebContentsAt(this, i);\n      if (web_contents) {\n        SessionTabHelper* session_tab_helper =\n            SessionTabHelper::FromWebContents(web_contents);\n        session_service->SetTabIndexInWindow(\n            session_id(), session_tab_helper->session_id(), i);\n        session_service->SetPinnedState(\n            session_id(),\n            session_tab_helper->session_id(),\n            tab_strip_model_->IsTabPinned(i));\n      }\n    }\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":126242
  },
  {
    "code":"void ResourceMessageFilter::DoOnGetRootWindowRect(gfx::NativeViewId view,\n                                                  IPC::Message* reply_msg) {\n  gfx::Rect rect;\n  XID window;\n  if (Singleton<GtkNativeViewManager>()->GetXIDForId(&window, view)) {\n    if (window) {\n      const XID toplevel = GetTopLevelWindow(window);\n      int x, y;\n      unsigned width, height;\n      if (x11_util::GetWindowGeometry(&x, &y, &width, &height, toplevel))\n        rect = gfx::Rect(x, y, width, height);\n    }\n  }\n  ViewHostMsg_GetRootWindowRect::WriteReplyParams(reply_msg, rect);\n   ChromeThread::PostTask(\n      ChromeThread::IO, FROM_HERE,\n      NewRunnableMethod(\n          this, &ResourceMessageFilter::SendDelayedReply, reply_msg));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":99222
  },
  {
    "code":"static ssize_t ib_ucm_send_private_data(struct ib_ucm_file *file,\n          const char __user *inbuf, int in_len,\n          int (*func)(struct ib_cm_id *cm_id,\n                const void *private_data,\n                u8 private_data_len))\n{\n  struct ib_ucm_private_data cmd;\n  struct ib_ucm_context *ctx;\n  const void *private_data = NULL;\n  int result;\n  if (copy_from_user(&cmd, inbuf, sizeof(cmd)))\n    return -EFAULT;\n  result = ib_ucm_alloc_data(&private_data, cmd.data, cmd.len);\n  if (result)\n    return result;\n  ctx = ib_ucm_ctx_get(file, cmd.id);\n  if (!IS_ERR(ctx)) {\n    result = func(ctx->cm_id, private_data, cmd.len);\n    ib_ucm_ctx_put(ctx);\n  } else\n    result = PTR_ERR(ctx);\n  kfree(private_data);\n  return result;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":52813
  },
  {
    "code":"e1000e_intmgr_timer_resume(E1000IntrDelayTimer *timer)\n{\n    if (timer->running) {\n        e1000e_intrmgr_rearm_timer(timer);\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":5980
  },
  {
    "code":"static byte parseHexChar(char ch) {\n if (isdigit(ch))\n return ch - '0';\n else if ('A' <= ch && ch <= 'F')\n return ch - 'A' + 10;\n else if ('a' <= ch && ch <= 'f')\n return ch - 'a' + 10;\n else {\n        ALOGE(\"invalid character in bssid %c\", ch);\n return 0;\n }\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":172314
  },
  {
    "code":"static void VoidMethodSerializedScriptValueArgMethod(const v8::FunctionCallbackInfo<v8::Value>& info) {\n  ExceptionState exception_state(info.GetIsolate(), ExceptionState::kExecutionContext, \"TestObject\", \"voidMethodSerializedScriptValueArg\");\n  TestObject* impl = V8TestObject::ToImpl(info.Holder());\n  if (UNLIKELY(info.Length() < 1)) {\n    exception_state.ThrowTypeError(ExceptionMessages::NotEnoughArguments(1, info.Length()));\n    return;\n  }\n  scoped_refptr<SerializedScriptValue> serialized_script_value_arg;\n  serialized_script_value_arg = NativeValueTraits<SerializedScriptValue>::NativeValue(info.GetIsolate(), info[0], SerializedScriptValue::SerializeOptions(SerializedScriptValue::kNotForStorage), exception_state);\n  if (exception_state.HadException())\n    return;\n  impl->voidMethodSerializedScriptValueArg(std::move(serialized_script_value_arg));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":148149
  },
  {
    "code":"IMPEG2D_ERROR_CODES_T impeg2d_dec_pic_hdr(dec_state_t *ps_dec)\n{\n stream_t *ps_stream;\n    ps_stream = &ps_dec->s_bit_stream;\n    impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);\n    impeg2d_bit_stream_get(ps_stream,10);\n    ps_dec->e_pic_type = (e_pic_type_t)impeg2d_bit_stream_get(ps_stream,3);\n if((ps_dec->e_pic_type < I_PIC) || (ps_dec->e_pic_type > D_PIC))\n {\n        impeg2d_next_code(ps_dec, PICTURE_START_CODE);\n return IMPEG2D_INVALID_PIC_TYPE;\n }\n    impeg2d_bit_stream_get(ps_stream,16);\n if(ps_dec->e_pic_type == P_PIC || ps_dec->e_pic_type == B_PIC)\n {\n        ps_dec->u2_full_pel_forw_vector = impeg2d_bit_stream_get_bit(ps_stream);\n        ps_dec->u2_forw_f_code          = impeg2d_bit_stream_get(ps_stream,3);\n }\n if(ps_dec->e_pic_type == B_PIC)\n {\n        ps_dec->u2_full_pel_back_vector = impeg2d_bit_stream_get_bit(ps_stream);\n        ps_dec->u2_back_f_code          = impeg2d_bit_stream_get(ps_stream,3);\n }\n if(ps_dec->u2_is_mpeg2 == 0)\n {\n        ps_dec->au2_f_code[0][0] = ps_dec->au2_f_code[0][1] = ps_dec->u2_forw_f_code;\n        ps_dec->au2_f_code[1][0] = ps_dec->au2_f_code[1][1] = ps_dec->u2_back_f_code;\n }\n    while (impeg2d_bit_stream_nxt(ps_stream,1) == 1)\n     {\n         impeg2d_bit_stream_get(ps_stream,9);\n     }\n    impeg2d_bit_stream_get_bit(ps_stream);\n    impeg2d_next_start_code(ps_dec);\n return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;\n}\n",
    "vul":1,
    "flaw_line_no":[
      29,
      31
    ],
    "bigvul_id":187967
  },
  {
    "code":"ImageBitmap* WebGLRenderingContextBase::TransferToImageBitmapBase(\n    ScriptState* script_state) {\n  WebFeature feature = WebFeature::kOffscreenCanvasTransferToImageBitmapWebGL;\n  UseCounter::Count(ExecutionContext::From(script_state), feature);\n  if (!GetDrawingBuffer())\n    return nullptr;\n  std::unique_ptr<viz::SingleReleaseCallback> image_release_callback;\n  scoped_refptr<StaticBitmapImage> image =\n      GetDrawingBuffer()->TransferToStaticBitmapImage(&image_release_callback);\n  GetDrawingBuffer()->SwapPreviousFrameCallback(\n      std::move(image_release_callback));\n  return ImageBitmap::Create(image);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":166652
  },
  {
    "code":"bool Document::parseQualifiedName(const AtomicString& qualifiedName, AtomicString& prefix, AtomicString& localName, ExceptionState& exceptionState)\n{\n    unsigned length = qualifiedName.length();\n    if (!length) {\n        exceptionState.throwDOMException(InvalidCharacterError, \"The qualified name provided is empty.\");\n        return false;\n    }\n    ParseQualifiedNameResult returnValue;\n    if (qualifiedName.is8Bit())\n        returnValue = parseQualifiedNameInternal(qualifiedName, qualifiedName.characters8(), length, prefix, localName);\n    else\n        returnValue = parseQualifiedNameInternal(qualifiedName, qualifiedName.characters16(), length, prefix, localName);\n    if (returnValue.status == QNValid)\n        return true;\n    StringBuilder message;\n    message.append(\"The qualified name provided ('\");\n    message.append(qualifiedName);\n    message.append(\"') \");\n    if (returnValue.status == QNMultipleColons) {\n        message.append(\"contains multiple colons.\");\n    } else if (returnValue.status == QNInvalidStartChar) {\n        message.append(\"contains the invalid name-start character '\");\n        message.append(returnValue.character);\n        message.append(\"'.\");\n    } else if (returnValue.status == QNInvalidChar) {\n        message.append(\"contains the invalid character '\");\n        message.append(returnValue.character);\n        message.append(\"'.\");\n    } else if (returnValue.status == QNEmptyPrefix) {\n        message.append(\"has an empty namespace prefix.\");\n    } else {\n        DCHECK_EQ(returnValue.status, QNEmptyLocalName);\n        message.append(\"has an empty local name.\");\n    }\n    if (returnValue.status == QNInvalidStartChar || returnValue.status == QNInvalidChar)\n        exceptionState.throwDOMException(InvalidCharacterError, message.toString());\n    else\n        exceptionState.throwDOMException(NamespaceError, message.toString());\n    return false;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":143237
  },
  {
    "code":"void TabStrip::GetAccessibleNodeData(ui::AXNodeData* node_data) {\n  node_data->role = ax::mojom::Role::kTabList;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":153387
  },
  {
    "code":"MetalayerMode::MetalayerMode(Delegate* delegate)\n    : CommonPaletteTool(delegate), weak_factory_(this) {\n  Shell::Get()->AddPreTargetHandler(this);\n  Shell::Get()->voice_interaction_controller()->AddObserver(this);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":167038
  },
  {
    "code":"static int async_chainiv_givencrypt_tail(struct skcipher_givcrypt_request *req)\n{\n  struct crypto_ablkcipher *geniv = skcipher_givcrypt_reqtfm(req);\n  struct async_chainiv_ctx *ctx = crypto_ablkcipher_ctx(geniv);\n  struct ablkcipher_request *subreq = skcipher_givcrypt_reqctx(req);\n  unsigned int ivsize = crypto_ablkcipher_ivsize(geniv);\n  memcpy(req->giv, ctx->iv, ivsize);\n  memcpy(subreq->info, ctx->iv, ivsize);\n  ctx->err = crypto_ablkcipher_encrypt(subreq);\n  if (ctx->err)\n    goto out;\n  memcpy(ctx->iv, subreq->info, ivsize);\nout:\n  return async_chainiv_schedule_work(ctx);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":45604
  },
  {
    "code":"SecurityFunctionTableA* SEC_ENTRY InitSecurityInterfaceA(void)\n{\n  return &SSPI_SecurityFunctionTableA;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":58586
  },
  {
    "code":"static int64_t guess_correct_pts(AVCodecContext *ctx,\n                                 int64_t reordered_pts, int64_t dts)\n{\n    int64_t pts = AV_NOPTS_VALUE;\n    if (dts != AV_NOPTS_VALUE) {\n        ctx->pts_correction_num_faulty_dts += dts <= ctx->pts_correction_last_dts;\n        ctx->pts_correction_last_dts = dts;\n    } else if (reordered_pts != AV_NOPTS_VALUE)\n        ctx->pts_correction_last_dts = reordered_pts;\n    if (reordered_pts != AV_NOPTS_VALUE) {\n        ctx->pts_correction_num_faulty_pts += reordered_pts <= ctx->pts_correction_last_pts;\n        ctx->pts_correction_last_pts = reordered_pts;\n    } else if(dts != AV_NOPTS_VALUE)\n        ctx->pts_correction_last_pts = dts;\n    if ((ctx->pts_correction_num_faulty_pts<=ctx->pts_correction_num_faulty_dts || dts == AV_NOPTS_VALUE)\n       && reordered_pts != AV_NOPTS_VALUE)\n        pts = reordered_pts;\n    else\n        pts = dts;\n    return pts;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":67051
  },
  {
    "code":" BlockEntry::~BlockEntry() {}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":174023
  },
  {
    "code":"HB_Error  HB_GPOS_Query_Features( HB_GPOSHeader*  gpos,\n          HB_UShort        script_index,\n          HB_UShort        language_index,\n          HB_UInt**       feature_tag_list )\n{\n  HB_UShort           n;\n  HB_Error            error;\n  HB_UInt*           ftl;\n  HB_ScriptList*     sl;\n  HB_ScriptRecord*   sr;\n  HB_ScriptTable*    s;\n  HB_LangSysRecord*  lsr;\n  HB_LangSys*        ls;\n  HB_UShort*          fi;\n  HB_FeatureList*    fl;\n  HB_FeatureRecord*  fr;\n  if ( !gpos || !feature_tag_list )\n    return ERR(HB_Err_Invalid_Argument);\n  sl = &gpos->ScriptList;\n  sr = sl->ScriptRecord;\n  fl = &gpos->FeatureList;\n  fr = fl->FeatureRecord;\n  if ( script_index >= sl->ScriptCount )\n    return ERR(HB_Err_Invalid_Argument);\n  s   = &sr[script_index].Script;\n  lsr = s->LangSysRecord;\n  if ( language_index == 0xFFFF )\n    ls = &s->DefaultLangSys;\n  else\n  {\n    if ( language_index >= s->LangSysCount )\n      return ERR(HB_Err_Invalid_Argument);\n    ls = &lsr[language_index].LangSys;\n  }\n  fi = ls->FeatureIndex;\n  if ( ALLOC_ARRAY( ftl, ls->FeatureCount + 1, HB_UInt ) )\n    return error;\n  for ( n = 0; n < ls->FeatureCount; n++ )\n  {\n    if ( fi[n] >= fl->FeatureCount )\n    {\n      FREE( ftl );\n      return ERR(HB_Err_Invalid_SubTable_Format);\n    }\n    ftl[n] = fr[fi[n]].FeatureTag;\n  }\n  ftl[n] = 0;\n  *feature_tag_list = ftl;\n  return HB_Err_Ok;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":13559
  },
  {
    "code":"int read_super(char *source)\n{\n  squashfs_super_block_3 sBlk_3;\n  struct squashfs_super_block sBlk_4;\n  read_fs_bytes(fd, SQUASHFS_START, sizeof(struct squashfs_super_block),\n    &sBlk_4);\n  swap = sBlk_4.s_magic != SQUASHFS_MAGIC;\n  SQUASHFS_INSWAP_SUPER_BLOCK(&sBlk_4);\n  if(sBlk_4.s_magic == SQUASHFS_MAGIC && sBlk_4.s_major == 4 &&\n      sBlk_4.s_minor == 0) {\n    s_ops.read_filesystem_tables = read_filesystem_tables_4;\n    s_ops.squashfs_opendir = squashfs_opendir_4;\n    s_ops.read_fragment = read_fragment_4;\n    s_ops.read_block_list = read_block_list_2;\n    s_ops.read_inode = read_inode_4;\n    memcpy(&sBlk, &sBlk_4, sizeof(sBlk_4));\n    comp = lookup_compressor_id(sBlk.s.compression);\n    return TRUE;\n  }\n  read_fs_bytes(fd, SQUASHFS_START, sizeof(squashfs_super_block_3),\n    &sBlk_3);\n  swap = 0;\n  if(sBlk_3.s_magic != SQUASHFS_MAGIC) {\n    if(sBlk_3.s_magic == SQUASHFS_MAGIC_SWAP) {\n      squashfs_super_block_3 sblk;\n      ERROR(\"Reading a different endian SQUASHFS filesystem \"\n        \"on %s\\n\", source);\n      SQUASHFS_SWAP_SUPER_BLOCK_3(&sblk, &sBlk_3);\n      memcpy(&sBlk_3, &sblk, sizeof(squashfs_super_block_3));\n      swap = 1;\n    } else  {\n      ERROR(\"Can't find a SQUASHFS superblock on %s\\n\",\n        source);\n      goto failed_mount;\n    }\n  }\n  sBlk.s.s_magic = sBlk_3.s_magic;\n  sBlk.s.inodes = sBlk_3.inodes;\n  sBlk.s.mkfs_time = sBlk_3.mkfs_time;\n  sBlk.s.block_size = sBlk_3.block_size;\n  sBlk.s.fragments = sBlk_3.fragments;\n  sBlk.s.block_log = sBlk_3.block_log;\n  sBlk.s.flags = sBlk_3.flags;\n  sBlk.s.s_major = sBlk_3.s_major;\n  sBlk.s.s_minor = sBlk_3.s_minor;\n  sBlk.s.root_inode = sBlk_3.root_inode;\n  sBlk.s.bytes_used = sBlk_3.bytes_used;\n  sBlk.s.inode_table_start = sBlk_3.inode_table_start;\n  sBlk.s.directory_table_start = sBlk_3.directory_table_start;\n  sBlk.s.fragment_table_start = sBlk_3.fragment_table_start;\n  sBlk.s.lookup_table_start = sBlk_3.lookup_table_start;\n  sBlk.no_uids = sBlk_3.no_uids;\n  sBlk.no_guids = sBlk_3.no_guids;\n  sBlk.uid_start = sBlk_3.uid_start;\n  sBlk.guid_start = sBlk_3.guid_start;\n  sBlk.s.xattr_id_table_start = SQUASHFS_INVALID_BLK;\n  if(sBlk.s.s_major == 1 || sBlk.s.s_major == 2) {\n    sBlk.s.bytes_used = sBlk_3.bytes_used_2;\n    sBlk.uid_start = sBlk_3.uid_start_2;\n    sBlk.guid_start = sBlk_3.guid_start_2;\n    sBlk.s.inode_table_start = sBlk_3.inode_table_start_2;\n    sBlk.s.directory_table_start = sBlk_3.directory_table_start_2;\n    if(sBlk.s.s_major == 1) {\n      sBlk.s.block_size = sBlk_3.block_size_1;\n      sBlk.s.fragment_table_start = sBlk.uid_start;\n      s_ops.read_filesystem_tables = read_filesystem_tables_1;\n      s_ops.squashfs_opendir = squashfs_opendir_1;\n      s_ops.read_block_list = read_block_list_1;\n      s_ops.read_inode = read_inode_1;\n    } else {\n      sBlk.s.fragment_table_start =\n        sBlk_3.fragment_table_start_2;\n      s_ops.read_filesystem_tables = read_filesystem_tables_2;\n      s_ops.squashfs_opendir = squashfs_opendir_1;\n      s_ops.read_fragment = read_fragment_2;\n      s_ops.read_block_list = read_block_list_2;\n      s_ops.read_inode = read_inode_2;\n    }\n  } else if(sBlk.s.s_major == 3) {\n    s_ops.read_filesystem_tables = read_filesystem_tables_3;\n    s_ops.squashfs_opendir = squashfs_opendir_3;\n    s_ops.read_fragment = read_fragment_3;\n    s_ops.read_block_list = read_block_list_2;\n    s_ops.read_inode = read_inode_3;\n  } else {\n    ERROR(\"Filesystem on %s is (%d:%d), \", source, sBlk.s.s_major,\n      sBlk.s.s_minor);\n    ERROR(\"which is a later filesystem version than I support!\\n\");\n    goto failed_mount;\n  }\n  comp = lookup_compressor(\"gzip\");\n  return TRUE;\nfailed_mount:\n  return FALSE;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":74299
  },
  {
    "code":"static bool vmx_get_nmi_mask(struct kvm_vcpu *vcpu)\n{\n  struct vcpu_vmx *vmx = to_vmx(vcpu);\n  bool masked;\n  if (vmx->loaded_vmcs->nmi_known_unmasked)\n    return false;\n  masked = vmcs_read32(GUEST_INTERRUPTIBILITY_INFO) & GUEST_INTR_STATE_NMI;\n  vmx->loaded_vmcs->nmi_known_unmasked = !masked;\n  return masked;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":63041
  },
  {
    "code":" AccessibilityButtonState AXObject::checkboxOrRadioValue() const {\n   const AtomicString& checkedAttribute =\n       getAOMPropertyOrARIAAttribute(AOMStringProperty::kChecked);\n  if (equalIgnoringCase(checkedAttribute, \"true\"))\n     return ButtonStateOn;\n  if (equalIgnoringCase(checkedAttribute, \"mixed\")) {\n     AccessibilityRole role = ariaRoleAttribute();\n     if (role == CheckBoxRole || role == MenuItemCheckBoxRole)\n      return ButtonStateMixed;\n  }\n  return ButtonStateOff;\n}\n",
    "vul":1,
    "flaw_line_no":[
      4,
      5,
      6,
      7,
      8,
      9,
      11
    ],
    "bigvul_id":185802
  },
  {
    "code":"static void rtnl_fdb_notify(struct net_device *dev, u8 *addr, int type)\n{\n  struct net *net = dev_net(dev);\n  struct sk_buff *skb;\n  int err = -ENOBUFS;\n  skb = nlmsg_new(rtnl_fdb_nlmsg_size(), GFP_ATOMIC);\n  if (!skb)\n    goto errout;\n  err = nlmsg_populate_fdb_fill(skb, dev, addr, 0, 0, type, NTF_SELF);\n  if (err < 0) {\n    kfree_skb(skb);\n    goto errout;\n  }\n  rtnl_notify(skb, net, 0, RTNLGRP_NEIGH, NULL, GFP_ATOMIC);\n  return;\nerrout:\n  rtnl_set_sk_err(net, RTNLGRP_NEIGH, err);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":31043
  },
  {
    "code":"void HTMLInputElement::listAttributeTargetChanged()\n{\n    m_inputTypeView->listAttributeTargetChanged();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":122331
  },
  {
    "code":"choose_volume(struct archive_read *a, struct iso9660 *iso9660)\n{\n  struct file_info *file;\n  int64_t skipsize;\n  struct vd *vd;\n  const void *block;\n  char seenJoliet;\n  vd = &(iso9660->primary);\n  if (!iso9660->opt_support_joliet)\n    iso9660->seenJoliet = 0;\n  if (iso9660->seenJoliet &&\n    vd->location > iso9660->joliet.location)\n    vd = &(iso9660->joliet);\n  skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;\n  skipsize = __archive_read_consume(a, skipsize);\n  if (skipsize < 0)\n    return ((int)skipsize);\n  iso9660->current_position = skipsize;\n  block = __archive_read_ahead(a, vd->size, NULL);\n  if (block == NULL) {\n    archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n        \"Failed to read full block when scanning \"\n        \"ISO9660 directory list\");\n    return (ARCHIVE_FATAL);\n  }\n  seenJoliet = iso9660->seenJoliet;\n  iso9660->seenJoliet = 0;\n  file = parse_file_info(a, NULL, block, vd->size);\n  if (file == NULL)\n    return (ARCHIVE_FATAL);\n  iso9660->seenJoliet = seenJoliet;\n  if (vd == &(iso9660->primary) && iso9660->seenRockridge\n      && iso9660->seenJoliet)\n    iso9660->seenJoliet = 0;\n  if (vd == &(iso9660->primary) && !iso9660->seenRockridge\n      && iso9660->seenJoliet) {\n    vd = &(iso9660->joliet);\n    skipsize = LOGICAL_BLOCK_SIZE * (int64_t)vd->location;\n    skipsize -= iso9660->current_position;\n    skipsize = __archive_read_consume(a, skipsize);\n    if (skipsize < 0)\n      return ((int)skipsize);\n    iso9660->current_position += skipsize;\n    block = __archive_read_ahead(a, vd->size, NULL);\n    if (block == NULL) {\n      archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,\n          \"Failed to read full block when scanning \"\n          \"ISO9660 directory list\");\n      return (ARCHIVE_FATAL);\n    }\n    iso9660->seenJoliet = 0;\n    file = parse_file_info(a, NULL, block, vd->size);\n    if (file == NULL)\n      return (ARCHIVE_FATAL);\n    iso9660->seenJoliet = seenJoliet;\n  }\n  if (add_entry(a, iso9660, file) != ARCHIVE_OK)\n    return (ARCHIVE_FATAL);\n  if (iso9660->seenRockridge) {\n    a->archive.archive_format = ARCHIVE_FORMAT_ISO9660_ROCKRIDGE;\n    a->archive.archive_format_name =\n        \"ISO9660 with Rockridge extensions\";\n  }\n  return (ARCHIVE_OK);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":87242
  },
  {
    "code":"static irda_queue_t *dequeue_first(irda_queue_t **queue)\n{\n  irda_queue_t *ret;\n  pr_debug(\"dequeue_first()\\n\");\n  ret =  *queue;\n  if ( *queue == NULL ) {\n  } else if ( (*queue)->q_next == *queue ) {\n    *queue = NULL;\n  } else {\n    (*queue)->q_prev->q_next = (*queue)->q_next;\n    (*queue)->q_next->q_prev = (*queue)->q_prev;\n    *queue = (*queue)->q_next;\n  }\n  return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":68150
  },
  {
    "code":"    RenderFrameImpl* (*create_render_frame_impl)(RenderViewImpl*, int32)) {\n  CHECK(!g_create_render_frame_impl);\n  g_create_render_frame_impl = create_render_frame_impl;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":118484
  },
  {
    "code":"fbPictureInit (ScreenPtr pScreen, PictFormatPtr formats, int nformats)\n{\n   srcRepeat = FALSE;\n     if (maskTransform)\n   maskRepeat = FALSE;\n    if (!miComputeCompositeRegion (&region, pSrc, pMask, pDst, xSrc, ySrc,\n           xMask, yMask, xDst, yDst, width, height))\n        return;\n    n = REGION_NUM_RECTS (&region);\n    pbox = REGION_RECTS (&region);\n    while (n--)\n    {\n  h = pbox->y2 - pbox->y1;\n  y_src = pbox->y1 - yDst + ySrc;\n  y_msk = pbox->y1 - yDst + yMask;\n  y_dst = pbox->y1;\n  while (h)\n  {\n      h_this = h;\n      w = pbox->x2 - pbox->x1;\n      x_src = pbox->x1 - xDst + xSrc;\n      x_msk = pbox->x1 - xDst + xMask;\n      x_dst = pbox->x1;\n      if (maskRepeat)\n      {\n    y_msk = mod (y_msk - pMask->pDrawable->y, pMask->pDrawable->height);\n    if (h_this > pMask->pDrawable->height - y_msk)\n        h_this = pMask->pDrawable->height - y_msk;\n    y_msk += pMask->pDrawable->y;\n      }\n      if (srcRepeat)\n      {\n    y_src = mod (y_src - pSrc->pDrawable->y, pSrc->pDrawable->height);\n    if (h_this > pSrc->pDrawable->height - y_src)\n        h_this = pSrc->pDrawable->height - y_src;\n    y_src += pSrc->pDrawable->y;\n      }\n      while (w)\n      {\n    w_this = w;\n    if (maskRepeat)\n    {\n        x_msk = mod (x_msk - pMask->pDrawable->x, pMask->pDrawable->width);\n        if (w_this > pMask->pDrawable->width - x_msk)\n      w_this = pMask->pDrawable->width - x_msk;\n        x_msk += pMask->pDrawable->x;\n    }\n    if (srcRepeat)\n    {\n        x_src = mod (x_src - pSrc->pDrawable->x, pSrc->pDrawable->width);\n        if (w_this > pSrc->pDrawable->width - x_src)\n      w_this = pSrc->pDrawable->width - x_src;\n        x_src += pSrc->pDrawable->x;\n    }\n    (*func) (op, pSrc, pMask, pDst,\n       x_src, y_src, x_msk, y_msk, x_dst, y_dst,\n       w_this, h_this);\n    w -= w_this;\n    x_src += w_this;\n    x_msk += w_this;\n    x_dst += w_this;\n      }\n      h -= h_this;\n      y_src += h_this;\n      y_msk += h_this;\n      y_dst += h_this;\n  }\n  pbox++;\n    }\n    REGION_UNINIT (pDst->pDrawable->pScreen, &region);\n }\n",
    "vul":1,
    "flaw_line_no":[
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      64,
      65,
      66,
      67,
      68,
      69,
      70
    ],
    "bigvul_id":178302
  },
  {
    "code":"void QQuickWebView::mouseDoubleClickEvent(QMouseEvent* event)\n{\n    Q_D(QQuickWebView);\n    forceActiveFocus();\n    d->handleMouseEvent(event);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":116272
  },
  {
    "code":"static void do_cgm_set(const char *name, const char *lxcpath, const char *filename, const char *value, int outp)\n{\n  char *controller, *key, *cgroup = NULL;\n  int retval = 0;  \n  int ret;\n  char *cglast;\n  controller = alloca(strlen(filename)+1);\n  strcpy(controller, filename);\n  key = strchr(controller, '.');\n  if (!key) {\n    ret = write(outp, &retval, sizeof(retval));\n    if (ret != sizeof(retval))\n      WARN(\"Failed to warn cgm_set of error; parent may hang\");\n    exit(1);\n  }\n  *key = '\\0';\n  if (!cgm_dbus_connect()) {\n    ERROR(\"Error connecting to cgroup manager\");\n    ret = write(outp, &retval, sizeof(retval));\n    if (ret != sizeof(retval))\n      WARN(\"Failed to warn cgm_set of error; parent may hang\");\n    exit(1);\n  }\n  cgroup = try_get_abs_cgroup(name, lxcpath, controller);\n  if (!cgroup) {\n    cgm_dbus_disconnect();\n    ret = write(outp, &retval, sizeof(retval));\n    if (ret != sizeof(retval))\n      WARN(\"Failed to warn cgm_set of error; parent may hang\");\n    exit(1);\n  }\n  cglast = strrchr(cgroup, '\/');\n  if (!cglast) {\n    cgm_dbus_disconnect();\n    free_abs_cgroup(cgroup);\n    ret = write(outp, &retval, sizeof(retval));\n    if (ret != sizeof(retval))\n      WARN(\"Failed to warn cgm_set of error; parent may hang\");\n    exit(1);\n  }\n  *cglast = '\\0';\n  if (!lxc_cgmanager_enter(getpid(), controller, cgroup, abs_cgroup_supported())) {\n    ERROR(\"Failed to enter container cgroup %s:%s\", controller, cgroup);\n    ret = write(outp, &retval, sizeof(retval));\n    if (ret != sizeof(retval))\n      WARN(\"Failed to warn cgm_set of error; parent may hang\");\n    cgm_dbus_disconnect();\n    free_abs_cgroup(cgroup);\n    exit(1);\n  }\n  if (cgmanager_set_value_sync(NULL, cgroup_manager, controller, cglast+1, filename, value) != 0) {\n    NihError *nerr;\n    nerr = nih_error_get();\n    ERROR(\"Error setting cgroup value %s for %s:%s\", filename, controller, cgroup);\n    ERROR(\"call to cgmanager_set_value_sync failed: %s\", nerr->message);\n    nih_free(nerr);\n    free_abs_cgroup(cgroup);\n    cgm_dbus_disconnect();\n    ret = write(outp, &retval, sizeof(retval));\n    if (ret != sizeof(retval))\n      WARN(\"Failed to warn cgm_set of error; parent may hang\");\n    exit(1);\n  }\n  free_abs_cgroup(cgroup);\n  cgm_dbus_disconnect();\n  retval = 1;\n  ret = write(outp, &retval, sizeof(retval));\n  if (ret != sizeof(retval)) {\n    exit(1);\n  }\n  exit(0);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":44541
  },
  {
    "code":"rdp_out_share_caps(STREAM s)\n{\n  out_uint16_le(s, RDP_CAPSET_SHARE);\n  out_uint16_le(s, RDP_CAPLEN_SHARE);\n  out_uint16(s, 0);  \n  out_uint16(s, 0);  \n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":93014
  },
  {
    "code":"bool jsvIsBasic(const JsVar *v) { return jsvIsNumeric(v) || jsvIsString(v);} \n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":82455
  },
  {
    "code":"struct dst_entry *inet_csk_update_pmtu(struct sock *sk, u32 mtu)\n{\n  struct dst_entry *dst = __sk_dst_check(sk, 0);\n  struct inet_sock *inet = inet_sk(sk);\n  if (!dst) {\n    dst = inet_csk_rebuild_route(sk, &inet->cork.fl);\n    if (!dst)\n      goto out;\n  }\n  dst->ops->update_pmtu(dst, sk, NULL, mtu);\n  dst = __sk_dst_check(sk, 0);\n  if (!dst)\n    dst = inet_csk_rebuild_route(sk, &inet->cork.fl);\nout:\n  return dst;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":66128
  },
  {
    "code":"static int sha224_ssse3_final(struct shash_desc *desc, u8 *hash)\n{\n  u8 D[SHA256_DIGEST_SIZE];\n  sha256_ssse3_final(desc, D);\n  memcpy(hash, D, SHA224_DIGEST_SIZE);\n  memset(D, 0, SHA256_DIGEST_SIZE);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":47040
  },
  {
    "code":"static int check_oflag_copied(BlockDriverState *bs, BdrvCheckResult *res,\n                              BdrvCheckMode fix)\n{\n    BDRVQcowState *s = bs->opaque;\n    uint64_t *l2_table = qemu_blockalign(bs, s->cluster_size);\n    int ret;\n    int refcount;\n    int i, j;\n    for (i = 0; i < s->l1_size; i++) {\n        uint64_t l1_entry = s->l1_table[i];\n        uint64_t l2_offset = l1_entry & L1E_OFFSET_MASK;\n        bool l2_dirty = false;\n        if (!l2_offset) {\n            continue;\n        }\n        refcount = get_refcount(bs, l2_offset >> s->cluster_bits);\n        if (refcount < 0) {\n            continue;\n        }\n        if ((refcount == 1) != ((l1_entry & QCOW_OFLAG_COPIED) != 0)) {\n            fprintf(stderr, \"%s OFLAG_COPIED L2 cluster: l1_index=%d \"\n                    \"l1_entry=%\" PRIx64 \" refcount=%d\\n\",\n                    fix & BDRV_FIX_ERRORS ? \"Repairing\" :\n                                            \"ERROR\",\n                    i, l1_entry, refcount);\n            if (fix & BDRV_FIX_ERRORS) {\n                s->l1_table[i] = refcount == 1\n                               ? l1_entry |  QCOW_OFLAG_COPIED\n                               : l1_entry & ~QCOW_OFLAG_COPIED;\n                ret = qcow2_write_l1_entry(bs, i);\n                if (ret < 0) {\n                    res->check_errors++;\n                    goto fail;\n                }\n                res->corruptions_fixed++;\n            } else {\n                res->corruptions++;\n            }\n        }\n        ret = bdrv_pread(bs->file, l2_offset, l2_table,\n                         s->l2_size * sizeof(uint64_t));\n        if (ret < 0) {\n            fprintf(stderr, \"ERROR: Could not read L2 table: %s\\n\",\n                    strerror(-ret));\n            res->check_errors++;\n            goto fail;\n        }\n        for (j = 0; j < s->l2_size; j++) {\n            uint64_t l2_entry = be64_to_cpu(l2_table[j]);\n            uint64_t data_offset = l2_entry & L2E_OFFSET_MASK;\n            int cluster_type = qcow2_get_cluster_type(l2_entry);\n            if ((cluster_type == QCOW2_CLUSTER_NORMAL) ||\n                ((cluster_type == QCOW2_CLUSTER_ZERO) && (data_offset != 0))) {\n                refcount = get_refcount(bs, data_offset >> s->cluster_bits);\n                if (refcount < 0) {\n                    continue;\n                }\n                if ((refcount == 1) != ((l2_entry & QCOW_OFLAG_COPIED) != 0)) {\n                    fprintf(stderr, \"%s OFLAG_COPIED data cluster: \"\n                            \"l2_entry=%\" PRIx64 \" refcount=%d\\n\",\n                            fix & BDRV_FIX_ERRORS ? \"Repairing\" :\n                                                    \"ERROR\",\n                            l2_entry, refcount);\n                    if (fix & BDRV_FIX_ERRORS) {\n                        l2_table[j] = cpu_to_be64(refcount == 1\n                                    ? l2_entry |  QCOW_OFLAG_COPIED\n                                    : l2_entry & ~QCOW_OFLAG_COPIED);\n                        l2_dirty = true;\n                        res->corruptions_fixed++;\n                    } else {\n                        res->corruptions++;\n                    }\n                }\n            }\n        }\n        if (l2_dirty) {\n            ret = qcow2_pre_write_overlap_check(bs, QCOW2_OL_ACTIVE_L2,\n                                                l2_offset, s->cluster_size);\n            if (ret < 0) {\n                fprintf(stderr, \"ERROR: Could not write L2 table; metadata \"\n                        \"overlap check failed: %s\\n\", strerror(-ret));\n                res->check_errors++;\n                goto fail;\n            }\n            ret = bdrv_pwrite(bs->file, l2_offset, l2_table, s->cluster_size);\n            if (ret < 0) {\n                fprintf(stderr, \"ERROR: Could not write L2 table: %s\\n\",\n                        strerror(-ret));\n                res->check_errors++;\n                goto fail;\n            }\n        }\n    }\n    ret = 0;\nfail:\n    qemu_vfree(l2_table);\n    return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":16800
  },
  {
    "code":"static av_cold int dfa_decode_init(AVCodecContext *avctx)\n{\n    DfaContext *s = avctx->priv_data;\n    avctx->pix_fmt = AV_PIX_FMT_PAL8;\n    if (!avctx->width || !avctx->height)\n        return AVERROR_INVALIDDATA;\n    av_assert0(av_image_check_size(avctx->width, avctx->height, 0, avctx) >= 0);\n    s->frame_buf = av_mallocz(avctx->width * avctx->height);\n    if (!s->frame_buf)\n        return AVERROR(ENOMEM);\n    return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":64095
  },
  {
    "code":"void DocumentLoader::WillCommitNavigation() {\n  if (GetFrameLoader().StateMachine()->CreatingInitialEmptyDocument())\n    return;\n  probe::willCommitLoad(frame_, this);\n  frame_->GetIdlenessDetector()->WillCommitLoad();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":136640
  },
  {
    "code":"void ChromeRenderMessageFilter::OnGetExtensionMessageBundleOnFileThread(\n    const FilePath& extension_path,\n    const std::string& extension_id,\n    const std::string& default_locale,\n    IPC::Message* reply_msg) {\n  DCHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));\n  scoped_ptr<extensions::MessageBundle::SubstitutionMap> dictionary_map(\n      extension_file_util::LoadMessageBundleSubstitutionMap(\n          extension_path,\n          extension_id,\n          default_locale));\n  ExtensionHostMsg_GetMessageBundle::WriteReplyParams(\n      reply_msg, *dictionary_map);\n  Send(reply_msg);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":108433
  },
  {
    "code":"char *jas_stream_gets(jas_stream_t *stream, char *buf, int bufsize)\n{\n  int c;\n  char *bufptr;\n  assert(bufsize > 0);\n  JAS_DBGLOG(100, (\"jas_stream_gets(%p, %p, %d)\\n\", stream, buf, bufsize));\n  bufptr = buf;\n  while (bufsize > 1) {\n    if ((c = jas_stream_getc(stream)) == EOF) {\n      break;\n    }\n    *bufptr++ = c;\n    --bufsize;\n    if (c == '\\n') {\n      break;\n    }\n  }\n  *bufptr = '\\0';\n  return buf;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":72794
  },
  {
    "code":"IntRect WebGLRenderingContextBase::GetImageDataSize(ImageData* pixels) {\n  DCHECK(pixels);\n  return GetTextureSourceSize(pixels);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":146310
  },
  {
    "code":"static int nft_dump_stats(struct sk_buff *skb, struct nft_stats __percpu *stats)\n{\n  struct nft_stats *cpu_stats, total;\n  struct nlattr *nest;\n  unsigned int seq;\n  u64 pkts, bytes;\n  int cpu;\n  memset(&total, 0, sizeof(total));\n  for_each_possible_cpu(cpu) {\n    cpu_stats = per_cpu_ptr(stats, cpu);\n    do {\n      seq = u64_stats_fetch_begin_irq(&cpu_stats->syncp);\n      pkts = cpu_stats->pkts;\n      bytes = cpu_stats->bytes;\n    } while (u64_stats_fetch_retry_irq(&cpu_stats->syncp, seq));\n    total.pkts += pkts;\n    total.bytes += bytes;\n  }\n  nest = nla_nest_start(skb, NFTA_CHAIN_COUNTERS);\n  if (nest == NULL)\n    goto nla_put_failure;\n  if (nla_put_be64(skb, NFTA_COUNTER_PACKETS, cpu_to_be64(total.pkts)) ||\n      nla_put_be64(skb, NFTA_COUNTER_BYTES, cpu_to_be64(total.bytes)))\n    goto nla_put_failure;\n  nla_nest_end(skb, nest);\n  return 0;\nnla_put_failure:\n  return -ENOSPC;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":58020
  },
  {
    "code":"cc::Layer* HTMLMediaElement::CcLayer() const {\n  return cc_layer_;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":142756
  },
  {
    "code":"int kvm_dev_ioctl_check_extension(long ext)\n{\n  int r;\n  switch (ext) {\n  case KVM_CAP_IRQCHIP:\n  case KVM_CAP_HLT:\n  case KVM_CAP_MMU_SHADOW_CACHE_CONTROL:\n  case KVM_CAP_SET_TSS_ADDR:\n  case KVM_CAP_EXT_CPUID:\n  case KVM_CAP_EXT_EMUL_CPUID:\n  case KVM_CAP_CLOCKSOURCE:\n  case KVM_CAP_PIT:\n  case KVM_CAP_NOP_IO_DELAY:\n  case KVM_CAP_MP_STATE:\n  case KVM_CAP_SYNC_MMU:\n  case KVM_CAP_USER_NMI:\n  case KVM_CAP_REINJECT_CONTROL:\n  case KVM_CAP_IRQ_INJECT_STATUS:\n  case KVM_CAP_IRQFD:\n  case KVM_CAP_IOEVENTFD:\n  case KVM_CAP_PIT2:\n  case KVM_CAP_PIT_STATE2:\n  case KVM_CAP_SET_IDENTITY_MAP_ADDR:\n  case KVM_CAP_XEN_HVM:\n  case KVM_CAP_ADJUST_CLOCK:\n  case KVM_CAP_VCPU_EVENTS:\n  case KVM_CAP_HYPERV:\n  case KVM_CAP_HYPERV_VAPIC:\n  case KVM_CAP_HYPERV_SPIN:\n  case KVM_CAP_PCI_SEGMENT:\n  case KVM_CAP_DEBUGREGS:\n  case KVM_CAP_X86_ROBUST_SINGLESTEP:\n  case KVM_CAP_XSAVE:\n  case KVM_CAP_ASYNC_PF:\n  case KVM_CAP_GET_TSC_KHZ:\n  case KVM_CAP_KVMCLOCK_CTRL:\n  case KVM_CAP_READONLY_MEM:\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\n  case KVM_CAP_ASSIGN_DEV_IRQ:\n  case KVM_CAP_PCI_2_3:\n#endif\n    r = 1;\n    break;\n  case KVM_CAP_COALESCED_MMIO:\n    r = KVM_COALESCED_MMIO_PAGE_OFFSET;\n    break;\n  case KVM_CAP_VAPIC:\n    r = !kvm_x86_ops->cpu_has_accelerated_tpr();\n    break;\n  case KVM_CAP_NR_VCPUS:\n    r = KVM_SOFT_MAX_VCPUS;\n    break;\n  case KVM_CAP_MAX_VCPUS:\n    r = KVM_MAX_VCPUS;\n    break;\n  case KVM_CAP_NR_MEMSLOTS:\n    r = KVM_USER_MEM_SLOTS;\n    break;\n  case KVM_CAP_PV_MMU:  \n    r = 0;\n    break;\n#ifdef CONFIG_KVM_DEVICE_ASSIGNMENT\n  case KVM_CAP_IOMMU:\n    r = iommu_present(&pci_bus_type);\n    break;\n#endif\n  case KVM_CAP_MCE:\n    r = KVM_MAX_MCE_BANKS;\n    break;\n  case KVM_CAP_XCRS:\n    r = cpu_has_xsave;\n    break;\n  case KVM_CAP_TSC_CONTROL:\n    r = kvm_has_tsc_control;\n    break;\n  case KVM_CAP_TSC_DEADLINE_TIMER:\n    r = boot_cpu_has(X86_FEATURE_TSC_DEADLINE_TIMER);\n    break;\n  default:\n    r = 0;\n    break;\n  }\n  return r;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":28862
  },
  {
    "code":"TabAppendedNotificationObserver::~TabAppendedNotificationObserver() {}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":126110
  },
  {
    "code":"static int closeUnixFile(sqlite3_file *id){\n  unixFile *pFile = (unixFile*)id;\n#if SQLITE_MAX_MMAP_SIZE>0\n  unixUnmapfile(pFile);\n#endif\n  if( pFile->h>=0 ){\n    robust_close(pFile, pFile->h, __LINE__);\n    pFile->h = -1;\n  }\n#if OS_VXWORKS\n  if( pFile->pId ){\n    if( pFile->ctrlFlags & UNIXFILE_DELETE ){\n      osUnlink(pFile->pId->zCanonicalName);\n    }\n    vxworksReleaseFileId(pFile->pId);\n    pFile->pId = 0;\n  }\n#endif\n#ifdef SQLITE_UNLINK_AFTER_CLOSE\n  if( pFile->ctrlFlags & UNIXFILE_DELETE ){\n    osUnlink(pFile->zPath);\n    sqlite3_free(*(char**)&pFile->zPath);\n    pFile->zPath = 0;\n  }\n#endif\n  OSTRACE((\"CLOSE   %-3d\\n\", pFile->h));\n  OpenCounter(-1);\n  sqlite3_free(pFile->pPreallocatedUnused);\n  memset(pFile, 0, sizeof(unixFile));\n  return SQLITE_OK;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":164531
  },
  {
    "code":" GetUpdatesCallerInfo::GetUpdatesSource GetSourceFromReason(\n     sync_api::ConfigureReason reason) {\n   switch (reason) {\n    case sync_api::CONFIGURE_REASON_RECONFIGURATION:\n      return GetUpdatesCallerInfo::RECONFIGURATION;\n    case sync_api::CONFIGURE_REASON_MIGRATION:\n      return GetUpdatesCallerInfo::MIGRATION;\n    case sync_api::CONFIGURE_REASON_NEW_CLIENT:\n      return GetUpdatesCallerInfo::NEW_CLIENT;\n    case sync_api::CONFIGURE_REASON_NEWLY_ENABLED_DATA_TYPE:\n      return GetUpdatesCallerInfo::NEWLY_SUPPORTED_DATATYPE;\n    default:\n      NOTREACHED();\n  }\n  return GetUpdatesCallerInfo::UNKNOWN;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":116084
  },
  {
    "code":"static __init int vmx_disabled_by_bios(void)\n{\n  u64 msr;\n  rdmsrl(MSR_IA32_FEATURE_CONTROL, msr);\n  if (msr & FEATURE_CONTROL_LOCKED) {\n    if (!(msr & FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX)\n      && tboot_enabled())\n      return 1;\n    if (!(msr & FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX)\n      && (msr & FEATURE_CONTROL_VMXON_ENABLED_INSIDE_SMX)\n      && !tboot_enabled()) {\n      printk(KERN_WARNING \"kvm: disable TXT in the BIOS or \"\n        \"activate TXT before enabling KVM\\n\");\n      return 1;\n    }\n    if (!(msr & FEATURE_CONTROL_VMXON_ENABLED_OUTSIDE_SMX)\n      && !tboot_enabled())\n      return 1;\n  }\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":37237
  },
  {
    "code":"void RenderFrameHostImpl::CommitNavigation(\n    int64_t navigation_id,\n    network::ResourceResponse* response,\n    network::mojom::URLLoaderClientEndpointsPtr url_loader_client_endpoints,\n    const CommonNavigationParams& common_params,\n    const RequestNavigationParams& request_params,\n    bool is_view_source,\n    base::Optional<SubresourceLoaderParams> subresource_loader_params,\n    base::Optional<std::vector<mojom::TransferrableURLLoaderPtr>>\n        subresource_overrides,\n    const base::UnguessableToken& devtools_navigation_token) {\n  TRACE_EVENT2(\"navigation\", \"RenderFrameHostImpl::CommitNavigation\",\n               \"frame_tree_node\", frame_tree_node_->frame_tree_node_id(), \"url\",\n               common_params.url.possibly_invalid_spec());\n  DCHECK(!IsRendererDebugURL(common_params.url));\n  DCHECK(\n      (response && url_loader_client_endpoints) ||\n      common_params.url.SchemeIs(url::kDataScheme) ||\n      FrameMsg_Navigate_Type::IsSameDocument(common_params.navigation_type) ||\n      !IsURLHandledByNetworkStack(common_params.url));\n  const bool is_first_navigation = !has_committed_any_navigation_;\n  has_committed_any_navigation_ = true;\n  UpdatePermissionsForNavigation(common_params, request_params);\n  ResetWaitingState();\n  if (is_view_source && IsCurrent()) {\n    DCHECK(!GetParent());\n    render_view_host()->Send(new FrameMsg_EnableViewSourceMode(routing_id_));\n  }\n  const network::ResourceResponseHead head =\n      response ? response->head : network::ResourceResponseHead();\n  const bool is_same_document =\n      FrameMsg_Navigate_Type::IsSameDocument(common_params.navigation_type);\n  std::unique_ptr<URLLoaderFactoryBundleInfo> subresource_loader_factories;\n  if (base::FeatureList::IsEnabled(network::features::kNetworkService) &&\n      (!is_same_document || is_first_navigation)) {\n    recreate_default_url_loader_factory_after_network_service_crash_ = false;\n    subresource_loader_factories =\n        std::make_unique<URLLoaderFactoryBundleInfo>();\n    BrowserContext* browser_context = GetSiteInstance()->GetBrowserContext();\n    if (subresource_loader_params &&\n        subresource_loader_params->appcache_loader_factory_info.is_valid()) {\n      subresource_loader_factories->appcache_factory_info() =\n          std::move(subresource_loader_params->appcache_loader_factory_info);\n    }\n    network::mojom::URLLoaderFactoryPtrInfo default_factory_info;\n    std::string scheme = common_params.url.scheme();\n    const auto& schemes = URLDataManagerBackend::GetWebUISchemes();\n    if (base::ContainsValue(schemes, scheme)) {\n      network::mojom::URLLoaderFactoryPtr factory_for_webui =\n          CreateWebUIURLLoaderBinding(this, scheme);\n      if ((enabled_bindings_ & kWebUIBindingsPolicyMask) &&\n          !GetContentClient()->browser()->IsWebUIAllowedToMakeNetworkRequests(\n              url::Origin::Create(common_params.url.GetOrigin()))) {\n        default_factory_info = factory_for_webui.PassInterface();\n      } else {\n        subresource_loader_factories->scheme_specific_factory_infos().emplace(\n            scheme, factory_for_webui.PassInterface());\n      }\n    }\n    if (!default_factory_info) {\n      recreate_default_url_loader_factory_after_network_service_crash_ = true;\n      bool bypass_redirect_checks =\n          CreateNetworkServiceDefaultFactoryAndObserve(\n              GetOriginForURLLoaderFactory(common_params.url,\n                                           GetSiteInstance()),\n              mojo::MakeRequest(&default_factory_info));\n      subresource_loader_factories->set_bypass_redirect_checks(\n          bypass_redirect_checks);\n    }\n    DCHECK(default_factory_info);\n    subresource_loader_factories->default_factory_info() =\n        std::move(default_factory_info);\n    non_network_url_loader_factories_.clear();\n    if (common_params.url.SchemeIsFile()) {\n      auto file_factory = std::make_unique<FileURLLoaderFactory>(\n          browser_context->GetPath(),\n          BrowserContext::GetSharedCorsOriginAccessList(browser_context),\n          base::CreateSequencedTaskRunnerWithTraits(\n              {base::MayBlock(), base::TaskPriority::BEST_EFFORT,\n               base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN}));\n      non_network_url_loader_factories_.emplace(url::kFileScheme,\n                                                std::move(file_factory));\n    }\n#if defined(OS_ANDROID)\n    if (common_params.url.SchemeIs(url::kContentScheme)) {\n      auto content_factory = std::make_unique<ContentURLLoaderFactory>(\n          base::CreateSequencedTaskRunnerWithTraits(\n              {base::MayBlock(), base::TaskPriority::BEST_EFFORT,\n               base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN}));\n      non_network_url_loader_factories_.emplace(url::kContentScheme,\n                                                std::move(content_factory));\n    }\n#endif\n    StoragePartition* partition =\n        BrowserContext::GetStoragePartition(browser_context, GetSiteInstance());\n    std::string storage_domain;\n    if (site_instance_) {\n      std::string partition_name;\n      bool in_memory;\n      GetContentClient()->browser()->GetStoragePartitionConfigForSite(\n          browser_context, site_instance_->GetSiteURL(), true, &storage_domain,\n          &partition_name, &in_memory);\n    }\n    non_network_url_loader_factories_.emplace(\n        url::kFileSystemScheme,\n        content::CreateFileSystemURLLoaderFactory(\n            this, false, partition->GetFileSystemContext(),\n            storage_domain));\n    GetContentClient()\n        ->browser()\n        ->RegisterNonNetworkSubresourceURLLoaderFactories(\n            process_->GetID(), routing_id_, &non_network_url_loader_factories_);\n    for (auto& factory : non_network_url_loader_factories_) {\n      network::mojom::URLLoaderFactoryPtrInfo factory_proxy_info;\n      auto factory_request = mojo::MakeRequest(&factory_proxy_info);\n      GetContentClient()->browser()->WillCreateURLLoaderFactory(\n          browser_context, this, GetProcess()->GetID(),\n          false ,\n          GetOriginForURLLoaderFactory(common_params.url, GetSiteInstance())\n              .value_or(url::Origin()),\n          &factory_request, nullptr ,\n          nullptr );\n      devtools_instrumentation::WillCreateURLLoaderFactory(\n          this, false , false ,\n          &factory_request);\n      factory.second->Clone(std::move(factory_request));\n      subresource_loader_factories->scheme_specific_factory_infos().emplace(\n          factory.first, std::move(factory_proxy_info));\n    }\n    subresource_loader_factories->initiator_specific_factory_infos() =\n        CreateInitiatorSpecificURLLoaderFactories(\n            initiators_requiring_separate_url_loader_factory_);\n  }\n  DCHECK(!base::FeatureList::IsEnabled(network::features::kNetworkService) ||\n         is_same_document || !is_first_navigation ||\n         subresource_loader_factories);\n  if (is_same_document) {\n    DCHECK(same_document_navigation_request_);\n    GetNavigationControl()->CommitSameDocumentNavigation(\n        common_params, request_params,\n        base::BindOnce(&RenderFrameHostImpl::OnSameDocumentCommitProcessed,\n                       base::Unretained(this),\n                       same_document_navigation_request_->navigation_handle()\n                           ->GetNavigationId(),\n                       common_params.should_replace_current_entry));\n  } else {\n    blink::mojom::ControllerServiceWorkerInfoPtr controller;\n    blink::mojom::ServiceWorkerObjectAssociatedPtrInfo remote_object;\n    blink::mojom::ServiceWorkerState sent_state;\n    if (subresource_loader_params &&\n        subresource_loader_params->controller_service_worker_info) {\n      controller =\n          std::move(subresource_loader_params->controller_service_worker_info);\n      if (controller->object_info) {\n        controller->object_info->request = mojo::MakeRequest(&remote_object);\n        sent_state = controller->object_info->state;\n      }\n    }\n    std::unique_ptr<URLLoaderFactoryBundleInfo> factory_bundle_for_prefetch;\n    network::mojom::URLLoaderFactoryPtr prefetch_loader_factory;\n    if (subresource_loader_factories) {\n      auto bundle = base::MakeRefCounted<URLLoaderFactoryBundle>(\n          std::move(subresource_loader_factories));\n      subresource_loader_factories = CloneFactoryBundle(bundle);\n      factory_bundle_for_prefetch = CloneFactoryBundle(bundle);\n    } else if (base::FeatureList::IsEnabled(\n                   blink::features::kServiceWorkerServicification) &&\n               (!is_same_document || is_first_navigation)) {\n      DCHECK(!base::FeatureList::IsEnabled(network::features::kNetworkService));\n      factory_bundle_for_prefetch =\n          std::make_unique<URLLoaderFactoryBundleInfo>();\n      network::mojom::URLLoaderFactoryPtrInfo factory_info;\n      CreateNetworkServiceDefaultFactoryInternal(\n          url::Origin(), mojo::MakeRequest(&factory_info));\n      factory_bundle_for_prefetch->default_factory_info() =\n          std::move(factory_info);\n    }\n    if (factory_bundle_for_prefetch) {\n      DCHECK(base::FeatureList::IsEnabled(network::features::kNetworkService) ||\n             base::FeatureList::IsEnabled(\n                 blink::features::kServiceWorkerServicification));\n      auto* storage_partition = static_cast<StoragePartitionImpl*>(\n          BrowserContext::GetStoragePartition(\n              GetSiteInstance()->GetBrowserContext(), GetSiteInstance()));\n      base::PostTaskWithTraits(\n          FROM_HERE, {BrowserThread::IO},\n          base::BindOnce(&PrefetchURLLoaderService::GetFactory,\n                         storage_partition->GetPrefetchURLLoaderService(),\n                         mojo::MakeRequest(&prefetch_loader_factory),\n                         frame_tree_node_->frame_tree_node_id(),\n                         std::move(factory_bundle_for_prefetch)));\n    }\n    auto find_request = navigation_requests_.find(navigation_id);\n    NavigationRequest* request = find_request != navigation_requests_.end()\n                                     ? find_request->second.get()\n                                     : nullptr;\n    if (IsPerNavigationMojoInterfaceEnabled() && navigation_request_ &&\n        navigation_request_->GetCommitNavigationClient()) {\n      navigation_request_->GetCommitNavigationClient()->CommitNavigation(\n          head, common_params, request_params,\n          std::move(url_loader_client_endpoints),\n          std::move(subresource_loader_factories),\n          std::move(subresource_overrides), std::move(controller),\n          std::move(prefetch_loader_factory), devtools_navigation_token,\n          base::BindOnce(&RenderFrameHostImpl::OnCrossDocumentCommitProcessed,\n                         base::Unretained(this), navigation_id));\n    } else {\n      GetNavigationControl()->CommitNavigation(\n          head, common_params, request_params,\n          std::move(url_loader_client_endpoints),\n          std::move(subresource_loader_factories),\n          std::move(subresource_overrides), std::move(controller),\n          std::move(prefetch_loader_factory), devtools_navigation_token,\n          request ? base::BindOnce(\n                        &RenderFrameHostImpl::OnCrossDocumentCommitProcessed,\n                        base::Unretained(this), navigation_id)\n                  : content::mojom::FrameNavigationControl::\n                        CommitNavigationCallback());\n    }\n    if (remote_object.is_valid()) {\n      base::PostTaskWithTraits(\n          FROM_HERE, {BrowserThread::IO},\n          base::BindOnce(\n              &ServiceWorkerObjectHost::AddRemoteObjectPtrAndUpdateState,\n              subresource_loader_params->controller_service_worker_object_host,\n              std::move(remote_object), sent_state));\n    }\n    if (IsURLHandledByNetworkStack(common_params.url))\n      last_navigation_previews_state_ = common_params.previews_state;\n  }\n  is_loading_ = true;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":166117
  },
  {
    "code":"void kvm_define_shared_msr(unsigned slot, u32 msr)\n{\n  BUG_ON(slot >= KVM_NR_SHARED_MSRS);\n  if (slot >= shared_msrs_global.nr)\n    shared_msrs_global.nr = slot + 1;\n  shared_msrs_global.msrs[slot] = msr;\n  smp_wmb();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":35784
  },
  {
    "code":"BOOLEAN BTM_SetSecurityLevel (BOOLEAN is_originator, char *p_name, UINT8 service_id,\n                              UINT16 sec_level, UINT16 psm, UINT32 mx_proto_id,\n                              UINT32 mx_chan_id)\n{\n#if (L2CAP_UCD_INCLUDED == TRUE)\n    CONNECTION_TYPE conn_type;\n if (is_originator)\n        conn_type = CONN_ORIENT_ORIG;\n else\n        conn_type = CONN_ORIENT_TERM;\n return(btm_sec_set_security_level (conn_type, p_name, service_id,\n                                       sec_level, psm, mx_proto_id, mx_chan_id));\n#else\n return(btm_sec_set_security_level (is_originator, p_name, service_id,\n                                       sec_level, psm, mx_proto_id, mx_chan_id));\n#endif\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":174572
  },
  {
    "code":"static int chksum_digest(struct shash_desc *desc, const u8 *data,\n       unsigned int length, u8 *out)\n{\n  struct chksum_ctx *mctx = crypto_shash_ctx(desc->tfm);\n  return __chksum_finup(&mctx->key, data, length, out);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":47199
  },
  {
    "code":"void free_camera_metadata(camera_metadata_t *metadata) {\n    free(metadata);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":171100
  },
  {
    "code":"static struct swap_info_struct *alloc_swap_info(void)\n{\n  struct swap_info_struct *p;\n  unsigned int type;\n  p = kzalloc(sizeof(*p), GFP_KERNEL);\n  if (!p)\n    return ERR_PTR(-ENOMEM);\n  spin_lock(&swap_lock);\n  for (type = 0; type < nr_swapfiles; type++) {\n    if (!(swap_info[type]->flags & SWP_USED))\n      break;\n  }\n  if (type >= MAX_SWAPFILES) {\n    spin_unlock(&swap_lock);\n    kfree(p);\n    return ERR_PTR(-EPERM);\n  }\n  if (type >= nr_swapfiles) {\n    p->type = type;\n    swap_info[type] = p;\n    smp_wmb();\n    nr_swapfiles++;\n  } else {\n    kfree(p);\n    p = swap_info[type];\n  }\n  INIT_LIST_HEAD(&p->first_swap_extent.list);\n  p->flags = SWP_USED;\n  p->next = -1;\n  spin_unlock(&swap_lock);\n  return p;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":21377
  },
  {
    "code":"decode_NXAST_RAW_DEC_TTL_CNT_IDS(const struct nx_action_cnt_ids *nac_ids,\n                                 enum ofp_version ofp_version OVS_UNUSED,\n                                 struct ofpbuf *out)\n{\n    struct ofpact_cnt_ids *ids;\n    size_t ids_size;\n    int i;\n    ids = ofpact_put_DEC_TTL(out);\n    ids->ofpact.raw = NXAST_RAW_DEC_TTL_CNT_IDS;\n    ids->n_controllers = ntohs(nac_ids->n_controllers);\n    ids_size = ntohs(nac_ids->len) - sizeof *nac_ids;\n    if (!is_all_zeros(nac_ids->zeros, sizeof nac_ids->zeros)) {\n        return OFPERR_NXBRC_MUST_BE_ZERO;\n    }\n    if (ids_size < ids->n_controllers * sizeof(ovs_be16)) {\n        VLOG_WARN_RL(&rl, \"Nicira action dec_ttl_cnt_ids only has %\"PRIuSIZE\" \"\n                     \"bytes allocated for controller ids.  %\"PRIuSIZE\" bytes \"\n                     \"are required for %\"PRIu16\" controllers.\",\n                     ids_size, ids->n_controllers * sizeof(ovs_be16),\n                     ids->n_controllers);\n        return OFPERR_OFPBAC_BAD_LEN;\n    }\n    for (i = 0; i < ids->n_controllers; i++) {\n        uint16_t id = ntohs(((ovs_be16 *)(nac_ids + 1))[i]);\n        ofpbuf_put(out, &id, sizeof id);\n        ids = out->header;\n    }\n    ofpact_finish_DEC_TTL(out, &ids);\n    return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":76796
  },
  {
    "code":"static void rt_mutex_init_task(struct task_struct *p)\n{\n  raw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n  p->pi_waiters = RB_ROOT;\n  p->pi_waiters_leftmost = NULL;\n  p->pi_top_task = NULL;\n  p->pi_blocked_on = NULL;\n#endif\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":59303
  },
  {
    "code":"AP_DECLARE(void **) ap_get_request_note(request_rec *r, apr_size_t note_num)\n{\n    core_request_config *req_cfg;\n    if (note_num >= num_request_notes) {\n        return NULL;\n    }\n    req_cfg = (core_request_config *)\n        ap_get_core_module_config(r->request_config);\n    if (!req_cfg) {\n        return NULL;\n    }\n    return &(req_cfg->notes[note_num]);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":64195
  },
  {
    "code":"void BrowserView::UpdateUIForContents(WebContents* contents) {\n  bool needs_layout = MaybeShowBookmarkBar(contents);\n  needs_layout |= MaybeShowInfoBar(contents);\n  if (needs_layout)\n    Layout();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":168384
  },
  {
    "code":"PageClickTracker::PageClickTracker(RenderView* render_view)\n    : render_view_(render_view),\n      was_focused_(false) {\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":97811
  },
  {
    "code":"static void clear_dead_task(struct k_itimer *timer, union cpu_time_count now)\n{\n  put_task_struct(timer->it.cpu.task);\n  timer->it.cpu.task = NULL;\n  timer->it.cpu.expires = cpu_time_sub(timer->it_clock,\n               timer->it.cpu.expires,\n               now);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":24668
  },
  {
    "code":"void GLES2Implementation::DeleteFramebuffersHelper(GLsizei n,\n                                                   const GLuint* framebuffers) {\n  helper_->DeleteFramebuffersImmediate(n, framebuffers);\n  IdAllocator* id_allocator = GetIdAllocator(IdNamespaces::kFramebuffers);\n  for (GLsizei ii = 0; ii < n; ++ii) {\n    id_allocator->FreeID(framebuffers[ii]);\n    if (framebuffers[ii] == bound_framebuffer_) {\n      bound_framebuffer_ = 0;\n    }\n    if (framebuffers[ii] == bound_read_framebuffer_) {\n      bound_read_framebuffer_ = 0;\n    }\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":153609
  },
  {
    "code":"  virtual void Run() {\n    ShellIntegration::SetAsDefaultBrowser();\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":100187
  },
  {
    "code":"loop_get_status64(struct loop_device *lo, struct loop_info64 __user *arg) {\n  struct loop_info64 info64;\n  int err = 0;\n  if (!arg)\n    err = -EINVAL;\n  if (!err)\n    err = loop_get_status(lo, &info64);\n  if (!err && copy_to_user(arg, &info64, sizeof(info64)))\n    err = -EFAULT;\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":84724
  },
  {
    "code":"ebt_check_watcher(struct ebt_entry_watcher *w, struct xt_tgchk_param *par,\n      unsigned int *cnt)\n{\n  const struct ebt_entry *e = par->entryinfo;\n  struct xt_target *watcher;\n  size_t left = ((char *)e + e->target_offset) - (char *)w;\n  int ret;\n  if (left < sizeof(struct ebt_entry_watcher) ||\n     left - sizeof(struct ebt_entry_watcher) < w->watcher_size)\n    return -EINVAL;\n  watcher = xt_request_find_target(NFPROTO_BRIDGE, w->u.name, 0);\n  if (IS_ERR(watcher))\n    return PTR_ERR(watcher);\n  w->u.watcher = watcher;\n  par->target   = watcher;\n  par->targinfo = w->data;\n  ret = xt_check_target(par, w->watcher_size,\n        e->ethproto, e->invflags & EBT_IPROTO);\n  if (ret < 0) {\n    module_put(watcher->me);\n    return ret;\n  }\n  (*cnt)++;\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":27686
  },
  {
    "code":"static void cleanup_coins(Coin* coins, size_t num)\n{\n  size_t i;\n  for(i = 0; i < num; i++) coin_cleanup(&coins[i]);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":87461
  },
  {
    "code":"bool ID3::isValid() const {\n return mIsValid;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":171077
  },
  {
    "code":"static int em_not(struct x86_emulate_ctxt *ctxt)\n{\n  ctxt->dst.val = ~ctxt->dst.val;\n  return X86EMUL_CONTINUE;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":21769
  },
  {
    "code":"unsigned lodepng_huffman_code_lengths(unsigned* lengths, const unsigned* frequencies,\n                                      size_t numcodes, unsigned maxbitlen)\n{\n  unsigned i, j;\n  size_t sum = 0, numpresent = 0;\n  unsigned error = 0;\n  Coin* coins; \n  Coin* prev_row; \n  size_t numcoins;\n  size_t coinmem;\n  if(numcodes == 0) return 80; \n  for(i = 0; i < numcodes; i++)\n  {\n    if(frequencies[i] > 0)\n    {\n      numpresent++;\n      sum += frequencies[i];\n    }\n  }\n  for(i = 0; i < numcodes; i++) lengths[i] = 0;\n  if(numpresent == 0)\n  {\n    lengths[0] = lengths[1] = 1; \n  }\n  else if(numpresent == 1)\n  {\n    for(i = 0; i < numcodes; i++)\n    {\n      if(frequencies[i])\n      {\n        lengths[i] = 1;\n        lengths[i == 0 ? 1 : 0] = 1;\n        break;\n      }\n    }\n  }\n  else\n  {\n    coinmem = numpresent * 2; \n    coins = (Coin*)calloc(sizeof(Coin), coinmem);\n    prev_row = (Coin*)calloc(sizeof(Coin), coinmem);\n    if(!coins || !prev_row)\n    {\n      free(coins);\n      free(prev_row);\n      return 83; \n    }\n    init_coins(coins, coinmem);\n    init_coins(prev_row, coinmem);\n    error = append_symbol_coins(coins, frequencies, numcodes, sum);\n    numcoins = numpresent;\n    qsort(coins, numcoins, sizeof(Coin), coin_compare);\n    if(!error)\n    {\n      unsigned numprev = 0;\n      for(j = 1; j <= maxbitlen && !error; j++) \n      {\n        unsigned tempnum;\n        Coin* tempcoins;\n        tempcoins = prev_row; prev_row = coins; coins = tempcoins;\n        tempnum = numprev; numprev = numcoins; numcoins = tempnum;\n        cleanup_coins(coins, numcoins);\n        init_coins(coins, numcoins);\n        numcoins = 0;\n        for(i = 0; i + 1 < numprev; i += 2)\n        {\n          Coin* coin = &coins[numcoins++];\n          coin_copy(coin, &prev_row[i]);\n          add_coins(coin, &prev_row[i + 1]);\n        }\n        if(j < maxbitlen)\n        {\n          error = append_symbol_coins(coins + numcoins, frequencies, numcodes, sum);\n          numcoins += numpresent;\n        }\n        qsort(coins, numcoins, sizeof(Coin), coin_compare);\n      }\n    }\n    if(!error)\n    {\n      for(i = 0; i < numpresent - 1; i++)\n      {\n        Coin* coin = &coins[i];\n        for(j = 0; j < coin->symbols.size; j++) lengths[coin->symbols.data[j]]++;\n      }\n    }\n    cleanup_coins(coins, coinmem);\n    free(coins);\n    cleanup_coins(prev_row, coinmem);\n    free(prev_row);\n  }\n  return error;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":87554
  },
  {
    "code":"void LockContentsView::SetDisplayStyle(DisplayStyle style) {\n  const bool show_expanded_view =\n      style == DisplayStyle::kExclusivePublicAccountExpandedView;\n  expanded_view_->SetVisible(show_expanded_view);\n  main_view_->SetVisible(!show_expanded_view);\n  top_header_->SetVisible(!show_expanded_view);\n  Layout();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":144217
  },
  {
    "code":"static void btif_rc_upstreams_rsp_evt(UINT16 event, tAVRC_RESPONSE *pavrc_resp, UINT8 ctype, UINT8 label)\n{\n    BTIF_TRACE_EVENT(\"%s pdu: %s handle: 0x%x ctype:%x label:%x\", __FUNCTION__,\n        dump_rc_pdu(pavrc_resp->pdu), btif_rc_cb.rc_handle, ctype, label);\n#if (AVRC_ADV_CTRL_INCLUDED == TRUE)\n switch (event)\n {\n case AVRC_PDU_REGISTER_NOTIFICATION:\n {\n if(AVRC_RSP_CHANGED==ctype)\n                 btif_rc_cb.rc_volume=pavrc_resp->reg_notif.param.volume;\n             HAL_CBACK(bt_rc_callbacks, volume_change_cb, pavrc_resp->reg_notif.param.volume,ctype)\n }\n break;\n case AVRC_PDU_SET_ABSOLUTE_VOLUME:\n {\n            BTIF_TRACE_DEBUG(\"Set absolute volume change event received: volume %d,ctype %d\",\n                pavrc_resp->volume.volume,ctype);\n if(AVRC_RSP_ACCEPT==ctype)\n                btif_rc_cb.rc_volume=pavrc_resp->volume.volume;\n            HAL_CBACK(bt_rc_callbacks,volume_change_cb,pavrc_resp->volume.volume,ctype)\n }\n break;\n default:\n return;\n }\n#endif\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":171978
  },
  {
    "code":"void DevToolsWindow::SetIsDocked(bool dock_requested) {\n  if (life_stage_ == kClosing)\n    return;\n  DCHECK(can_dock_ || !dock_requested);\n  if (!can_dock_)\n    dock_requested = false;\n  bool was_docked = is_docked_;\n  is_docked_ = dock_requested;\n  if (life_stage_ != kLoadCompleted) {\n    life_stage_ = life_stage_ == kOnLoadFired ? kLoadCompleted : kIsDockedSet;\n    if (life_stage_ == kLoadCompleted)\n      LoadCompleted();\n    return;\n  }\n  if (dock_requested == was_docked)\n    return;\n  if (dock_requested && !was_docked) {\n    TabStripModel* tab_strip_model = browser_->tab_strip_model();\n    tab_strip_model->DetachWebContentsAt(\n        tab_strip_model->GetIndexOfWebContents(main_web_contents_));\n    browser_ = NULL;\n  } else if (!dock_requested && was_docked) {\n    UpdateBrowserWindow();\n  }\n  Show(DevToolsToggleAction::Show());\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":151109
  },
  {
    "code":"void OneClickSigninSyncStarter::SigninDialogDelegate::OnCancelSignin() {\n  sync_starter_->CancelSigninAndDelete();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":120873
  },
  {
    "code":"    DrawingBufferClientRestorePixelPackParameters() {\n  if (!ContextGL())\n    return;\n  ContextGL()->PixelStorei(GL_PACK_ROW_LENGTH, pack_row_length_);\n  ContextGL()->PixelStorei(GL_PACK_SKIP_ROWS, pack_skip_rows_);\n  ContextGL()->PixelStorei(GL_PACK_SKIP_PIXELS, pack_skip_pixels_);\n  WebGLRenderingContextBase::DrawingBufferClientRestorePixelPackParameters();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":159433
  },
  {
    "code":"static inline void init_rss_vec(int *rss)\n{\n  memset(rss, 0, sizeof(int) * NR_MM_COUNTERS);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":21242
  },
  {
    "code":"static void l2tp_eth_delete(struct l2tp_session *session)\n{\n  struct l2tp_eth_sess *spriv;\n  struct net_device *dev;\n  if (session) {\n    spriv = l2tp_session_priv(session);\n    dev = spriv->dev;\n    if (dev) {\n      unregister_netdev(dev);\n      spriv->dev = NULL;\n    }\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":24302
  },
  {
    "code":"png_handle_hIST(png_structrp png_ptr, png_inforp info_ptr, png_uint_32 length)\n{\n   unsigned int num, i;\n   png_uint_16 readbuf[PNG_MAX_PALETTE_LENGTH];\n   png_debug(1, \"in png_handle_hIST\");\n   if ((png_ptr->mode & PNG_HAVE_IHDR) == 0)\n      png_chunk_error(png_ptr, \"missing IHDR\");\n   else if ((png_ptr->mode & PNG_HAVE_IDAT) != 0 ||\n       (png_ptr->mode & PNG_HAVE_PLTE) == 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"out of place\");\n      return;\n   }\n   else if (info_ptr != NULL && (info_ptr->valid & PNG_INFO_hIST) != 0)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"duplicate\");\n      return;\n   }\n   num = length \/ 2 ;\n   if (num != (unsigned int) png_ptr->num_palette ||\n       num > (unsigned int) PNG_MAX_PALETTE_LENGTH)\n   {\n      png_crc_finish(png_ptr, length);\n      png_chunk_benign_error(png_ptr, \"invalid\");\n      return;\n   }\n   for (i = 0; i < num; i++)\n   {\n      png_byte buf[2];\n      png_crc_read(png_ptr, buf, 2);\n      readbuf[i] = png_get_uint_16(buf);\n   }\n   if (png_crc_finish(png_ptr, 0) != 0)\n      return;\n   png_set_hIST(png_ptr, info_ptr, readbuf);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":79735
  },
  {
    "code":"kadm5_get_principal(void *server_handle, krb5_principal principal,\n                    kadm5_principal_ent_t entry,\n                    long in_mask)\n{\n    krb5_db_entry               *kdb;\n    osa_princ_ent_rec           adb;\n    krb5_error_code             ret = 0;\n    long                        mask;\n    int i;\n    kadm5_server_handle_t handle = server_handle;\n    CHECK_HANDLE(server_handle);\n    krb5_clear_error_message(handle->context);\n    mask = in_mask;\n    memset(entry, 0, sizeof(*entry));\n    if (principal == NULL)\n        return EINVAL;\n    if ((ret = kdb_get_entry(handle, principal, &kdb, &adb)))\n        return ret;\n    if ((mask & KADM5_POLICY) &&\n        adb.policy && (adb.aux_attributes & KADM5_POLICY)) {\n        if ((entry->policy = strdup(adb.policy)) == NULL) {\n            ret = ENOMEM;\n            goto done;\n        }\n    }\n    if (mask & KADM5_AUX_ATTRIBUTES)\n        entry->aux_attributes = adb.aux_attributes;\n    if ((mask & KADM5_PRINCIPAL) &&\n        (ret = krb5_copy_principal(handle->context, kdb->princ,\n                                   &entry->principal))) {\n        goto done;\n    }\n    if (mask & KADM5_PRINC_EXPIRE_TIME)\n        entry->princ_expire_time = kdb->expiration;\n    if ((mask & KADM5_LAST_PWD_CHANGE) &&\n        (ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,\n                                               &(entry->last_pwd_change)))) {\n        goto done;\n    }\n    if (mask & KADM5_PW_EXPIRATION)\n        entry->pw_expiration = kdb->pw_expiration;\n    if (mask & KADM5_MAX_LIFE)\n        entry->max_life = kdb->max_life;\n    if ((mask & KADM5_MOD_NAME) || (mask & KADM5_MOD_TIME)) {\n        ret = krb5_dbe_lookup_mod_princ_data(handle->context, kdb,\n                                             &(entry->mod_date),\n                                             &(entry->mod_name));\n        if (ret) {\n            goto done;\n        }\n        if (! (mask & KADM5_MOD_TIME))\n            entry->mod_date = 0;\n        if (! (mask & KADM5_MOD_NAME)) {\n            krb5_free_principal(handle->context, entry->mod_name);\n            entry->mod_name = NULL;\n        }\n    }\n    if (mask & KADM5_ATTRIBUTES)\n        entry->attributes = kdb->attributes;\n    if (mask & KADM5_KVNO)\n        for (entry->kvno = 0, i=0; i<kdb->n_key_data; i++)\n            if ((krb5_kvno) kdb->key_data[i].key_data_kvno > entry->kvno)\n                entry->kvno = kdb->key_data[i].key_data_kvno;\n    if (mask & KADM5_MKVNO) {\n        ret = krb5_dbe_get_mkvno(handle->context, kdb, &entry->mkvno);\n        if (ret)\n            goto done;\n    }\n    if (mask & KADM5_MAX_RLIFE)\n        entry->max_renewable_life = kdb->max_renewable_life;\n    if (mask & KADM5_LAST_SUCCESS)\n        entry->last_success = kdb->last_success;\n    if (mask & KADM5_LAST_FAILED)\n        entry->last_failed = kdb->last_failed;\n    if (mask & KADM5_FAIL_AUTH_COUNT)\n        entry->fail_auth_count = kdb->fail_auth_count;\n    if (mask & KADM5_TL_DATA) {\n        krb5_tl_data *tl, *tl2;\n        entry->tl_data = NULL;\n        tl = kdb->tl_data;\n        while (tl) {\n            if (tl->tl_data_type > 255) {\n                if ((tl2 = dup_tl_data(tl)) == NULL) {\n                    ret = ENOMEM;\n                    goto done;\n                }\n                tl2->tl_data_next = entry->tl_data;\n                entry->tl_data = tl2;\n                entry->n_tl_data++;\n            }\n            tl = tl->tl_data_next;\n        }\n    }\n    if (mask & KADM5_KEY_DATA) {\n        entry->n_key_data = kdb->n_key_data;\n        if(entry->n_key_data) {\n            entry->key_data = k5calloc(entry->n_key_data,\n                                       sizeof(krb5_key_data), &ret);\n            if (entry->key_data == NULL)\n                goto done;\n        } else\n            entry->key_data = NULL;\n        for (i = 0; i < entry->n_key_data; i++)\n            ret = krb5_copy_key_data_contents(handle->context,\n                                              &kdb->key_data[i],\n                                              &entry->key_data[i]);\n        if (ret)\n            goto done;\n    }\n    ret = KADM5_OK;\ndone:\n    if (ret && entry->principal) {\n        krb5_free_principal(handle->context, entry->principal);\n        entry->principal = NULL;\n    }\n    kdb_free_entry(handle, kdb, &adb);\n    return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":36143
  },
  {
    "code":"parse_SET_VLAN_PCP(char *arg, struct ofpbuf *ofpacts,\n                   enum ofputil_protocol *usable_protocols OVS_UNUSED)\n{\n    return parse_set_vlan_pcp(arg, ofpacts, false);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":77080
  },
  {
    "code":"static int padlock_sha256_final_nano(struct shash_desc *desc, u8 *out)\n{\n  struct sha256_state *state =\n    (struct sha256_state *)shash_desc_ctx(desc);\n  unsigned int partial, padlen;\n  __be64 bits;\n  static const u8 padding[64] = { 0x80, };\n  bits = cpu_to_be64(state->count << 3);\n  partial = state->count & 0x3f;\n  padlen = (partial < 56) ? (56 - partial) : ((64+56) - partial);\n  padlock_sha256_update_nano(desc, padding, padlen);\n  padlock_sha256_update_nano(desc, (const u8 *)&bits, sizeof(bits));\n  padlock_output_block((uint32_t *)(state->state), (uint32_t *)out, 8);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":47456
  },
  {
    "code":" virtual bool connect(\n const char *uri, const KeyedVector<String8, String8> *headers) {\n Parcel data, reply;\n        data.writeInterfaceToken(\n IMediaHTTPConnection::getInterfaceDescriptor());\n String16 tmp(uri);\n        data.writeString16(tmp);\n        tmp = String16(\"\");\n if (headers != NULL) {\n for (size_t i = 0; i < headers->size(); ++i) {\n String16 key(headers->keyAt(i).string());\n String16 val(headers->valueAt(i).string());\n                tmp.append(key);\n                tmp.append(String16(\": \"));\n                tmp.append(val);\n                tmp.append(String16(\"\\r\\n\"));\n }\n }\n        data.writeString16(tmp);\n        remote()->transact(CONNECT, data, &reply);\n int32_t exceptionCode = reply.readExceptionCode();\n if (exceptionCode) {\n return UNKNOWN_ERROR;\n }\n        sp<IBinder> binder = reply.readStrongBinder();\n        mMemory = interface_cast<IMemory>(binder);\n return mMemory != NULL;\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":170781
  },
  {
    "code":"Address BaseArena::lazySweep(size_t allocationSize, size_t gcInfoIndex) {\n  if (!m_firstUnsweptPage)\n    return nullptr;\n  RELEASE_ASSERT(getThreadState()->isSweepingInProgress());\n  if (getThreadState()->sweepForbidden())\n    return nullptr;\n  TRACE_EVENT0(\"blink_gc\", \"BaseArena::lazySweepPages\");\n  ThreadState::SweepForbiddenScope sweepForbidden(getThreadState());\n  ScriptForbiddenIfMainThreadScope scriptForbidden;\n  double startTime = WTF::currentTimeMS();\n  Address result = lazySweepPages(allocationSize, gcInfoIndex);\n  getThreadState()->accumulateSweepingTime(WTF::currentTimeMS() - startTime);\n  ThreadHeap::reportMemoryUsageForTracing();\n  return result;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":160376
  },
  {
    "code":"tracing_saved_cmdlines_size_read(struct file *filp, char __user *ubuf,\n         size_t cnt, loff_t *ppos)\n{\n  char buf[64];\n  int r;\n  arch_spin_lock(&trace_cmdline_lock);\n  r = scnprintf(buf, sizeof(buf), \"%u\\n\", savedcmd->cmdline_num);\n  arch_spin_unlock(&trace_cmdline_lock);\n  return simple_read_from_buffer(ubuf, cnt, ppos, buf, r);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":81509
  },
  {
    "code":"void nl80211_send_remain_on_channel(struct cfg80211_registered_device *rdev,\n            struct net_device *netdev, u64 cookie,\n            struct ieee80211_channel *chan,\n            enum nl80211_channel_type channel_type,\n            unsigned int duration, gfp_t gfp)\n{\n  nl80211_send_remain_on_chan_event(NL80211_CMD_REMAIN_ON_CHANNEL,\n            rdev, netdev, cookie, chan,\n            channel_type, duration, gfp);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":26744
  },
  {
    "code":"SProcScreenSaverDispatch(ClientPtr client)\n{\n    REQUEST(xReq);\n    if (stuff->data < NUM_REQUESTS)\n        return (*SwappedVector[stuff->data]) (client);\n    return BadRequest;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":17409
  },
  {
    "code":"void Document::activeChainNodeDetached(Element& element)\n{\n    if (!m_activeHoverElement)\n        return;\n    if (element != m_activeHoverElement)\n        return;\n    Node* activeNode = ComposedTreeTraversal::parent(element);\n    while (activeNode && activeNode->isElementNode() && !activeNode->layoutObject())\n        activeNode = ComposedTreeTraversal::parent(*activeNode);\n    m_activeHoverElement = activeNode && activeNode->isElementNode() ? toElement(activeNode) : 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":135128
  },
  {
    "code":"void JBIG2Bitmap::expand(int newH, Guint pixel) {\n  if (newH <= h || line <= 0 || newH >= (INT_MAX - 1) \/ line) {\n    error(errSyntaxError, -1, \"invalid width\/height\");\n    gfree(data);\n    data = NULL;\n    return;\n  }\n  data = (Guchar *)grealloc(data, newH * line + 1);\n  if (pixel) {\n    memset(data + h * line, 0xff, (newH - h) * line);\n  } else {\n    memset(data + h * line, 0x00, (newH - h) * line);\n  }\n  h = newH;\n  data[h * line] = 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":14692
  },
  {
    "code":"void Browser::TabClosingAt(TabStripModel* tab_strip_model,\n                           TabContentsWrapper* contents,\n                           int index) {\n  NotificationService::current()->Notify(\n      NotificationType::TAB_CLOSING,\n      Source<NavigationController>(&contents->controller()),\n      NotificationService::NoDetails());\n  contents->tab_contents()->set_delegate(NULL);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":107814
  },
  {
    "code":"void RenderBlockFlow::adjustForBorderFit(LayoutUnit x, LayoutUnit& left, LayoutUnit& right) const\n{\n    RenderBlock::adjustForBorderFit(x, left, right);\n    if (m_floatingObjects && style()->visibility() == VISIBLE) {\n        const FloatingObjectSet& floatingObjectSet = m_floatingObjects->set();\n        FloatingObjectSetIterator end = floatingObjectSet.end();\n        for (FloatingObjectSetIterator it = floatingObjectSet.begin(); it != end; ++it) {\n            FloatingObject* floatingObject = *it;\n            if (floatingObject->shouldPaint()) {\n                LayoutUnit floatLeft = xPositionForFloatIncludingMargin(floatingObject) - floatingObject->renderer()->x();\n                LayoutUnit floatRight = floatLeft + floatingObject->renderer()->width();\n                left = min(left, floatLeft);\n                right = max(right, floatRight);\n            }\n        }\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":124673
  },
  {
    "code":"void RenderWidgetHostImpl::SetPageFocus(bool focused) {\n  is_focused_ = focused;\n  if (!focused) {\n    if (IsMouseLocked())\n      view_->UnlockMouse();\n    if (IsKeyboardLocked())\n      UnlockKeyboard();\n    if (auto* touch_emulator = GetExistingTouchEmulator())\n      touch_emulator->CancelTouch();\n  } else if (keyboard_lock_allowed_) {\n    LockKeyboard();\n  }\n  GetWidgetInputHandler()->SetFocus(focused);\n  if (RenderViewHost::From(this) && delegate_)\n    delegate_->ReplicatePageFocus(focused);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":158368
  },
  {
    "code":"TestServiceProvider::TestServiceProvider() {\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":145722
  },
  {
    "code":"static int cma_bind_loopback(struct rdma_id_private *id_priv)\n{\n  struct cma_device *cma_dev, *cur_dev;\n  struct ib_port_attr port_attr;\n  union ib_gid gid;\n  u16 pkey;\n  int ret;\n  u8 p;\n  cma_dev = NULL;\n  mutex_lock(&lock);\n  list_for_each_entry(cur_dev, &dev_list, list) {\n    if (cma_family(id_priv) == AF_IB &&\n        rdma_node_get_transport(cur_dev->device->node_type) != RDMA_TRANSPORT_IB)\n      continue;\n    if (!cma_dev)\n      cma_dev = cur_dev;\n    for (p = 1; p <= cur_dev->device->phys_port_cnt; ++p) {\n      if (!ib_query_port(cur_dev->device, p, &port_attr) &&\n          port_attr.state == IB_PORT_ACTIVE) {\n        cma_dev = cur_dev;\n        goto port_found;\n      }\n    }\n  }\n  if (!cma_dev) {\n    ret = -ENODEV;\n    goto out;\n  }\n  p = 1;\nport_found:\n  ret = ib_get_cached_gid(cma_dev->device, p, 0, &gid);\n  if (ret)\n    goto out;\n  ret = ib_get_cached_pkey(cma_dev->device, p, 0, &pkey);\n  if (ret)\n    goto out;\n  id_priv->id.route.addr.dev_addr.dev_type =\n    (rdma_port_get_link_layer(cma_dev->device, p) == IB_LINK_LAYER_INFINIBAND) ?\n    ARPHRD_INFINIBAND : ARPHRD_ETHER;\n  rdma_addr_set_sgid(&id_priv->id.route.addr.dev_addr, &gid);\n  ib_addr_set_pkey(&id_priv->id.route.addr.dev_addr, pkey);\n  id_priv->id.port_num = p;\n  cma_attach_to_dev(id_priv, cma_dev);\n  cma_set_loopback(cma_src_addr(id_priv));\nout:\n  mutex_unlock(&lock);\n  return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":38457
  },
  {
    "code":"void power_pmu_cancel_txn(struct pmu *pmu)\n{\n  struct cpu_hw_events *cpuhw = &__get_cpu_var(cpu_hw_events);\n  cpuhw->group_flag &= ~PERF_EVENT_TXN;\n  perf_pmu_enable(pmu);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":22694
  },
  {
    "code":"static void unsignedLongLongAttributeAttributeGetter(const v8::PropertyCallbackInfo<v8::Value>& info)\n{\n    TestObjectPython* imp = V8TestObjectPython::toNative(info.Holder());\n    v8SetReturnValue(info, static_cast<double>(imp->unsignedLongLongAttribute()));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":131832
  },
  {
    "code":"static int tcp_copy_to_iovec(struct sock *sk, struct sk_buff *skb, int hlen)\n{\n  struct tcp_sock *tp = tcp_sk(sk);\n  int chunk = skb->len - hlen;\n  int err;\n  local_bh_enable();\n  if (skb_csum_unnecessary(skb))\n    err = skb_copy_datagram_iovec(skb, hlen, tp->ucopy.iov, chunk);\n  else\n    err = skb_copy_and_csum_datagram_iovec(skb, hlen,\n                   tp->ucopy.iov);\n  if (!err) {\n    tp->ucopy.len -= chunk;\n    tp->copied_seq += chunk;\n    tcp_rcv_space_adjust(sk);\n  }\n  local_bh_disable();\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":41133
  },
  {
    "code":"FrameLoadType FrameLoader::loadType() const\n{\n    return m_loadType;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":97444
  },
  {
    "code":"CMYKGrayEncoder::~CMYKGrayEncoder() {\n  if (str->isEncoder())\n    delete str;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":4066
  },
  {
    "code":"void WebGL2RenderingContextBase::uniformMatrix3x4fv(\n    const WebGLUniformLocation* location,\n    GLboolean transpose,\n    Vector<GLfloat>& value,\n    GLuint src_offset,\n    GLuint src_length) {\n  if (isContextLost() ||\n      !ValidateUniformMatrixParameters(\"uniformMatrix3x4fv\", location,\n                                       transpose, value.data(), value.size(),\n                                       12, src_offset, src_length))\n    return;\n  ContextGL()->UniformMatrix3x4fv(\n      location->Location(),\n      (src_length ? src_length : (value.size() - src_offset)) \/ 12, transpose,\n      value.data() + src_offset);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":146228
  },
  {
    "code":"static int hostap_80211_header_parse(const struct sk_buff *skb,\n             unsigned char *haddr)\n{\n  memcpy(haddr, skb_mac_header(skb) + 10, ETH_ALEN); \n  return ETH_ALEN;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":24097
  },
  {
    "code":"void webkit_gc_collect_javascript_objects()\n{\n    gcController().garbageCollectNow();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":98375
  },
  {
    "code":"static u8 nfc_llcp_nr(struct sk_buff *pdu)\n{\n  return pdu->data[2] & 0xf;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":89700
  },
  {
    "code":"static void vmci_transport_set_max_buffer_size(struct vsock_sock *vsk,\n                 u64 val)\n{\n  if (val < vmci_trans(vsk)->queue_pair_size)\n    vmci_trans(vsk)->queue_pair_size = val;\n  vmci_trans(vsk)->queue_pair_max_size = val;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":30434
  },
  {
    "code":"void AutomationProvider::StopAsync(int tab_handle) {\n  RenderViewHost* view = GetViewForTab(tab_handle);\n  if (!view) {\n    DLOG(WARNING) << \"StopAsync: no view for handle \" << tab_handle;\n    return;\n  }\n  view->Stop();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":107274
  },
  {
    "code":"smp_fetch_cookie_cnt(const struct arg *args, struct sample *smp, const char *kw, void *private)\n{\n  struct http_txn *txn;\n  struct hdr_idx *idx;\n  struct hdr_ctx ctx;\n  const struct http_msg *msg;\n  const char *hdr_name;\n  int hdr_name_len;\n  int cnt;\n  char *val_beg, *val_end;\n  char *sol;\n  if (!args || args->type != ARGT_STR)\n    return 0;\n  CHECK_HTTP_MESSAGE_FIRST();\n  txn = smp->strm->txn;\n  idx = &smp->strm->txn->hdr_idx;\n  if ((smp->opt & SMP_OPT_DIR) == SMP_OPT_DIR_REQ) {\n    msg = &txn->req;\n    hdr_name = \"Cookie\";\n    hdr_name_len = 6;\n  } else {\n    msg = &txn->rsp;\n    hdr_name = \"Set-Cookie\";\n    hdr_name_len = 10;\n  }\n  sol = msg->chn->buf->p;\n  val_end = val_beg = NULL;\n  ctx.idx = 0;\n  cnt = 0;\n  while (1) {\n    if (!val_beg) {\n      if (!http_find_header2(hdr_name, hdr_name_len, sol, idx, &ctx))\n        break;\n      if (ctx.vlen < args->data.str.len + 1)\n        continue;\n      val_beg = ctx.line + ctx.val;\n      val_end = val_beg + ctx.vlen;\n    }\n    smp->data.type = SMP_T_STR;\n    smp->flags |= SMP_F_CONST;\n    while ((val_beg = extract_cookie_value(val_beg, val_end,\n                   args->data.str.str, args->data.str.len,\n                   (smp->opt & SMP_OPT_DIR) == SMP_OPT_DIR_REQ,\n                   &smp->data.u.str.str,\n                   &smp->data.u.str.len))) {\n      cnt++;\n    }\n  }\n  smp->data.type = SMP_T_SINT;\n  smp->data.u.sint = cnt;\n  smp->flags |= SMP_F_VOL_HDR;\n  return 1;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":6902
  },
  {
    "code":"static LZWInfo *AcquireLZWInfo(Image *image,const size_t data_size)\n{\n  LZWInfo\n    *lzw_info;\n  register ssize_t\n    i;\n  size_t\n    one;\n  lzw_info=(LZWInfo *) AcquireMagickMemory(sizeof(*lzw_info));\n  if (lzw_info == (LZWInfo *) NULL)\n    return((LZWInfo *) NULL);\n  (void) ResetMagickMemory(lzw_info,0,sizeof(*lzw_info));\n  lzw_info->image=image;\n  lzw_info->data_size=data_size;\n  one=1;\n  lzw_info->maximum_data_value=(one << data_size)-1;\n  lzw_info->clear_code=lzw_info->maximum_data_value+1;\n  lzw_info->end_code=lzw_info->maximum_data_value+2;\n  lzw_info->table[0]=(size_t *) AcquireQuantumMemory(MaximumLZWCode,\n    sizeof(*lzw_info->table));\n  lzw_info->table[1]=(size_t *) AcquireQuantumMemory(MaximumLZWCode,\n    sizeof(*lzw_info->table));\n  if ((lzw_info->table[0] == (size_t *) NULL) ||\n      (lzw_info->table[1] == (size_t *) NULL))\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  for (i=0; i <= (ssize_t) lzw_info->maximum_data_value; i++)\n  {\n    lzw_info->table[0][i]=0;\n    lzw_info->table[1][i]=(size_t) i;\n  }\n  ResetLZWInfo(lzw_info);\n  lzw_info->code_info.buffer[0]='\\0';\n  lzw_info->code_info.buffer[1]='\\0';\n  lzw_info->code_info.count=2;\n  lzw_info->code_info.bit=8*lzw_info->code_info.count;\n  lzw_info->code_info.eof=MagickFalse;\n  lzw_info->genesis=MagickTrue;\n  lzw_info->stack=(LZWStack *) AcquireMagickMemory(sizeof(*lzw_info->stack));\n  if (lzw_info->stack == (LZWStack *) NULL)\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  lzw_info->stack->codes=(size_t *) AcquireQuantumMemory(2UL*\n    MaximumLZWCode,sizeof(*lzw_info->stack->codes));\n  if (lzw_info->stack->codes == (size_t *) NULL)\n    {\n      lzw_info=RelinquishLZWInfo(lzw_info);\n      return((LZWInfo *) NULL);\n    }\n  lzw_info->stack->index=lzw_info->stack->codes;\n  lzw_info->stack->top=lzw_info->stack->codes+2*MaximumLZWCode;\n  return(lzw_info);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":71553
  },
  {
    "code":"PHP_FUNCTION(imagecolorallocate)\n{\n  zval *IM;\n  long red, green, blue;\n  gdImagePtr im;\n  int ct = (-1);\n  if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"rlll\", &IM, &red, &green, &blue) == FAILURE) {\n    return;\n  }\n  ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, \"Image\", le_gd);\n  ct = gdImageColorAllocate(im, red, green, blue);\n  if (ct < 0) {\n    RETURN_FALSE;\n  }\n  RETURN_LONG(ct);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":15129
  },
  {
    "code":"static int WM_GetOutput_Gauss(midi * handle, int8_t *buffer, uint32_t size) {\n    uint32_t buffer_used = 0;\n    uint32_t i;\n    struct _mdi *mdi = (struct _mdi *) handle;\n    uint32_t real_samples_to_mix = 0;\n    uint32_t data_pos;\n    int32_t premix, left_mix, right_mix;\n    struct _note *note_data = NULL;\n    uint32_t count;\n    int16_t *sptr;\n    double y, xd;\n    double *gptr, *gend;\n    int left, right, temp_n;\n    int ii, jj;\n    struct _event *event = mdi->current_event;\n    int32_t *tmp_buffer;\n    int32_t *out_buffer;\n    _WM_Lock(&mdi->lock);\n    buffer_used = 0;\n    memset(buffer, 0, size);\n    if ( (size \/ 2) > mdi->mix_buffer_size) {\n        if ( (size \/ 2) <= ( mdi->mix_buffer_size * 2 )) {\n            mdi->mix_buffer_size += MEM_CHUNK;\n        } else {\n            mdi->mix_buffer_size = size \/ 2;\n        }\n        mdi->mix_buffer = realloc(mdi->mix_buffer, mdi->mix_buffer_size * sizeof(int32_t));\n    }\n    tmp_buffer = mdi->mix_buffer;\n    memset(tmp_buffer, 0, ((size \/ 2) * sizeof(int32_t)));\n    out_buffer = tmp_buffer;\n    do {\n        if (__builtin_expect((!mdi->samples_to_mix), 0)) {\n            while ((!mdi->samples_to_mix) && (event->do_event)) {\n                event->do_event(mdi, &event->event_data);\n                if ((mdi->extra_info.mixer_options & WM_MO_LOOP) && (event[0].do_event == *_WM_do_meta_endoftrack)) {\n                    _WM_ResetToStart(mdi);\n                    event = mdi->current_event;\n                } else {\n                    mdi->samples_to_mix = event->samples_to_next;\n                    event++;\n                    mdi->current_event = event;\n                }\n            }\n            if (!mdi->samples_to_mix) {\n                if (mdi->extra_info.current_sample\n                    >= mdi->extra_info.approx_total_samples) {\n                    break;\n                } else if ((mdi->extra_info.approx_total_samples\n                            - mdi->extra_info.current_sample) > (size >> 2)) {\n                    mdi->samples_to_mix = size >> 2;\n                } else {\n                    mdi->samples_to_mix = mdi->extra_info.approx_total_samples\n                    - mdi->extra_info.current_sample;\n                }\n            }\n        }\n        if (__builtin_expect((mdi->samples_to_mix > (size >> 2)), 1)) {\n            real_samples_to_mix = size >> 2;\n        } else {\n            real_samples_to_mix = mdi->samples_to_mix;\n            if (real_samples_to_mix == 0) {\n                continue;\n            }\n        }\n        count = real_samples_to_mix;\n        do {\n            note_data = mdi->note;\n            left_mix = right_mix = 0;\n            if (__builtin_expect((note_data != NULL), 1)) {\n                while (note_data) {\n                    data_pos = note_data->sample_pos >> FPBITS;\n                    left = data_pos;\n                    right = (note_data->sample->data_length >> FPBITS) - left\n                            - 1;\n                    temp_n = (right << 1) - 1;\n                    if (temp_n <= 0)\n                        temp_n = 1;\n                    if (temp_n > (left << 1) + 1)\n                        temp_n = (left << 1) + 1;\n                    if (temp_n < gauss_n) {\n                        xd = note_data->sample_pos & FPMASK;\n                        xd \/= (1L << FPBITS);\n                        xd += temp_n >> 1;\n                        y = 0;\n                        sptr = note_data->sample->data\n                                + (note_data->sample_pos >> FPBITS)\n                                - (temp_n >> 1);\n                        for (ii = temp_n; ii;) {\n                            for (jj = 0; jj <= ii; jj++)\n                                y += sptr[jj] * newt_coeffs[ii][jj];\n                            y *= xd - --ii;\n                        }\n                        y += *sptr;\n                    } else { \n                        y = 0;\n                        gptr = &gauss_table[(note_data->sample_pos & FPMASK) *\n                                     (gauss_n + 1)];\n                        gend = gptr + gauss_n;\n                        sptr = note_data->sample->data\n                                + (note_data->sample_pos >> FPBITS)\n                                - (gauss_n >> 1);\n                        do {\n                            y += *(sptr++) * *(gptr++);\n                        } while (gptr <= gend);\n                    }\n                    premix = (int32_t)((y * (note_data->env_level >> 12)) \/ 1024);\n                    left_mix += (premix * (int32_t)note_data->left_mix_volume) \/ 1024;\n                    right_mix += (premix * (int32_t)note_data->right_mix_volume) \/ 1024;\n                    note_data->sample_pos += note_data->sample_inc;\n                    if (__builtin_expect(\n                                         (note_data->sample_pos > note_data->sample->loop_end),\n                                         0)) {\n                        if (note_data->modes & SAMPLE_LOOP) {\n                            note_data->sample_pos =\n                            note_data->sample->loop_start\n                            + ((note_data->sample_pos\n                                - note_data->sample->loop_start)\n                               % note_data->sample->loop_size);\n                        } else if (__builtin_expect(\n                                                    (note_data->sample_pos\n                                                     >= note_data->sample->data_length),\n                                                    0)) {\n                            goto _END_THIS_NOTE;\n                        }\n                    }\n                    if (__builtin_expect((note_data->env_inc == 0), 0)) {\n                        note_data = note_data->next;\n                        continue;\n                    }\n                    note_data->env_level += note_data->env_inc;\n                    if (note_data->env_inc < 0) {\n                        if (note_data->env_level\n                            > note_data->sample->env_target[note_data->env]) {\n                            note_data = note_data->next;\n                            continue;\n                        }\n                    } else if (note_data->env_inc > 0) {\n                        if (note_data->env_level\n                            < note_data->sample->env_target[note_data->env]) {\n                            note_data = note_data->next;\n                            continue;\n                        }\n                    }\n                    note_data->env_level =\n                    note_data->sample->env_target[note_data->env];\n                    switch (note_data->env) {\n                        case 0:\n                            if (!(note_data->modes & SAMPLE_ENVELOPE)) {\n                                note_data->env_inc = 0;\n                                note_data = note_data->next;\n                                continue;\n                            }\n                            break;\n                        case 2:\n                            if (note_data->modes & SAMPLE_SUSTAIN ) {\n                                note_data->env_inc = 0;\n                                note_data = note_data->next;\n                                continue;\n                            } else if (note_data->modes & SAMPLE_CLAMPED) {\n                                note_data->env = 5;\n                                if (note_data->env_level\n                                    > note_data->sample->env_target[5]) {\n                                    note_data->env_inc =\n                                    -note_data->sample->env_rate[5];\n                                } else {\n                                    note_data->env_inc =\n                                    note_data->sample->env_rate[5];\n                                }\n                                continue;\n                            }\n                            break;\n                        case 5:\n                            if (__builtin_expect((note_data->env_level == 0), 1)) {\n                                goto _END_THIS_NOTE;\n                            }\n                            if (note_data->modes & SAMPLE_LOOP)\n                                note_data->modes ^= SAMPLE_LOOP;\n                            note_data->env_inc = 0;\n                            note_data = note_data->next;\n                            continue;\n                        case 6:\n                        _END_THIS_NOTE:\n                            if (__builtin_expect((note_data->replay != NULL), 1)) {\n                                note_data->active = 0;\n                                {\n                                    struct _note *prev_note = NULL;\n                                    struct _note *nte_array = mdi->note;\n                                    if (nte_array != note_data) {\n                                        do {\n                                            prev_note = nte_array;\n                                            nte_array = nte_array->next;\n                                        } while (nte_array != note_data);\n                                    }\n                                    if (prev_note) {\n                                        prev_note->next = note_data->replay;\n                                    } else {\n                                        mdi->note = note_data->replay;\n                                    }\n                                    note_data->replay->next = note_data->next;\n                                    note_data = note_data->replay;\n                                    note_data->active = 1;\n                                }\n                            } else {\n                                note_data->active = 0;\n                                {\n                                    struct _note *prev_note = NULL;\n                                    struct _note *nte_array = mdi->note;\n                                    if (nte_array != note_data) {\n                                        do {\n                                            prev_note = nte_array;\n                                            nte_array = nte_array->next;\n                                        } while ((nte_array != note_data)\n                                                 && (nte_array));\n                                    }\n                                    if (prev_note) {\n                                        prev_note->next = note_data->next;\n                                    } else {\n                                        mdi->note = note_data->next;\n                                    }\n                                    note_data = note_data->next;\n                                }\n                            }\n                            continue;\n                    }\n                    note_data->env++;\n                    if (note_data->is_off == 1) {\n                        _WM_do_note_off_extra(note_data);\n                    } else {\n                        if (note_data->env_level\n                            >= note_data->sample->env_target[note_data->env]) {\n                            note_data->env_inc =\n                            -note_data->sample->env_rate[note_data->env];\n                        } else {\n                            note_data->env_inc =\n                            note_data->sample->env_rate[note_data->env];\n                        }\n                    }\n                    note_data = note_data->next;\n                    continue;\n                }\n            }\n            *tmp_buffer++ = left_mix;\n            *tmp_buffer++ = right_mix;\n        } while (--count);\n        buffer_used += real_samples_to_mix * 4;\n        size -= (real_samples_to_mix << 2);\n        mdi->extra_info.current_sample += real_samples_to_mix;\n        mdi->samples_to_mix -= real_samples_to_mix;\n    } while (size);\n    tmp_buffer = out_buffer;\n    if (mdi->extra_info.mixer_options & WM_MO_REVERB) {\n        _WM_do_reverb(mdi->reverb, tmp_buffer, (buffer_used \/ 2));\n    }\n    for (i = 0; i < buffer_used; i += 4) {\n        left_mix = *tmp_buffer++;\n        right_mix = *tmp_buffer++;\n#ifdef WORDS_BIGENDIAN\n        (*buffer++) = ((left_mix >> 8) & 0x7f) | ((left_mix >> 24) & 0x80);\n        (*buffer++) = left_mix & 0xff;\n        (*buffer++) = ((right_mix >> 8) & 0x7f) | ((right_mix >> 24) & 0x80);\n        (*buffer++) = right_mix & 0xff;\n#else\n        (*buffer++) = left_mix & 0xff;\n        (*buffer++) = ((left_mix >> 8) & 0x7f) | ((left_mix >> 24) & 0x80);\n        (*buffer++) = right_mix & 0xff;\n        (*buffer++) = ((right_mix >> 8) & 0x7f) | ((right_mix >> 24) & 0x80);\n#endif\n    }\n    _WM_Unlock(&mdi->lock);\n    return (buffer_used);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":85094
  },
  {
    "code":"void MainResourceLoader::didCancel(const ResourceError& error)\n{\n    m_dataLoadTimer.stop();\n    RefPtr<MainResourceLoader> protect(this);\n    if (m_waitingForContentPolicy) {\n        frameLoader()->policyChecker()->cancelCheck();\n        ASSERT(m_waitingForContentPolicy);\n        m_waitingForContentPolicy = false;\n        deref(); \n    }\n    frameLoader()->receivedMainResourceError(error, true);\n    ResourceLoader::didCancel(error);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":108300
  },
  {
    "code":"CronTab::nextRunTime( long timestamp ) {\n  long runtime = CRONTAB_INVALID;\n  struct tm *tm;\n  if ( ! this->valid ) {\n    this->lastRunTime = CRONTAB_INVALID;\n    return ( this->lastRunTime );\n  }\n  timestamp += ( 60 - ( timestamp % 60 ) );\n  const time_t _timestamp = (time_t)timestamp;\n  tm = localtime( &_timestamp );\n  int fields[CRONTAB_FIELDS];\n  fields[CRONTAB_MINUTES_IDX]  = tm->tm_min;\n  fields[CRONTAB_HOURS_IDX]  = tm->tm_hour;\n  fields[CRONTAB_DOM_IDX]    = tm->tm_mday;\n  fields[CRONTAB_MONTHS_IDX]  = tm->tm_mon + 1;\n  fields[CRONTAB_DOW_IDX]    = tm->tm_wday;\n  int match[CRONTAB_FIELDS + 1];\n  match[CRONTAB_YEARS_IDX] = tm->tm_year + 1900;\n  match[CRONTAB_DOW_IDX] = -1;\n  if ( this->matchFields( fields, match, CRONTAB_FIELDS - 2 ) ) {\n    struct tm matchTime;\n    matchTime.tm_sec  = 0;\n    matchTime.tm_min  = match[CRONTAB_MINUTES_IDX];\n    matchTime.tm_hour  = match[CRONTAB_HOURS_IDX];\n    matchTime.tm_mday  = match[CRONTAB_DOM_IDX];\n    matchTime.tm_mon  = match[CRONTAB_MONTHS_IDX] - 1;\n    matchTime.tm_year  = match[CRONTAB_YEARS_IDX] - 1900;\n    matchTime.tm_isdst  = -1; \n    runtime = (long)mktime( &matchTime );\n    if ( runtime < timestamp ) {\n      EXCEPT( \"CronTab: Generated a runtime that is in the past (%d < %d)\"\n        , (int)runtime, (int)timestamp );\n    }\n  } else {\n    EXCEPT( \"CronTab: Failed to find a match for timestamp %d\", \n      (int)timestamp );\n  }\n  this->lastRunTime = runtime;\n  return ( runtime );\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":16545
  },
  {
    "code":"static void sock_def_write_space(struct sock *sk)\n{\n  struct socket_wq *wq;\n  rcu_read_lock();\n  if ((atomic_read(&sk->sk_wmem_alloc) << 1) <= sk->sk_sndbuf) {\n    wq = rcu_dereference(sk->sk_wq);\n    if (wq_has_sleeper(wq))\n      wake_up_interruptible_sync_poll(&wq->wait, POLLOUT |\n            POLLWRNORM | POLLWRBAND);\n    if (sock_writeable(sk))\n      sk_wake_async(sk, SOCK_WAKE_SPACE, POLL_OUT);\n  }\n  rcu_read_unlock();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":20163
  },
  {
    "code":"bool IDNSpoofChecker::SafeToDisplayAsUnicode(base::StringPiece16 label,\n                                             bool is_tld_ascii) {\n  UErrorCode status = U_ZERO_ERROR;\n  int32_t result =\n      uspoof_check(checker_, label.data(),\n                   base::checked_cast<int32_t>(label.size()), NULL, &status);\n  if (U_FAILURE(status) || (result & USPOOF_ALL_CHECKS))\n    return false;\n  icu::UnicodeString label_string(FALSE, label.data(),\n                                  base::checked_cast<int32_t>(label.size()));\n  if (deviation_characters_.containsSome(label_string))\n    return false;\n  result &= USPOOF_RESTRICTION_LEVEL_MASK;\n  if (result == USPOOF_ASCII)\n    return true;\n  if (result == USPOOF_SINGLE_SCRIPT_RESTRICTIVE &&\n      kana_letters_exceptions_.containsNone(label_string) &&\n      combining_diacritics_exceptions_.containsNone(label_string)) {\n    return !is_tld_ascii || !IsMadeOfLatinAlikeCyrillic(label_string);\n  }\n  if (non_ascii_latin_letters_.containsSome(label_string) &&\n      !lgc_letters_n_ascii_.containsAll(label_string))\n    return false;\n  if (!tls_index.initialized())\n    tls_index.Initialize(&OnThreadTermination);\n  icu::RegexMatcher* dangerous_pattern =\n      reinterpret_cast<icu::RegexMatcher*>(tls_index.Get());\n  if (!dangerous_pattern) {\n     dangerous_pattern = new icu::RegexMatcher(\n         icu::UnicodeString(\n             R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}])\"\n            R\"([\\u30ce\\u30f3\\u30bd\\u30be])\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}\\p{scx=hani}]|)\"\n            R\"([^\\p{scx=kana}\\p{scx=hira}]\\u30fc|^\\u30fc|)\"\n            R\"([^\\p{scx=kana}][\\u30fd\\u30fe]|^[\\u30fd\\u30fe]|)\"\n            R\"(^[\\p{scx=kana}]+[\\u3078-\\u307a][\\p{scx=kana}]+$|)\"\n            R\"(^[\\p{scx=hira}]+[\\u30d8-\\u30da][\\p{scx=hira}]+$|)\"\n            R\"([a-z]\\u30fb|\\u30fb[a-z]|)\"\n            R\"(^[\\u0585\\u0581]+[a-z]|[a-z][\\u0585\\u0581]+$|)\"\n            R\"([a-z][\\u0585\\u0581]+[a-z]|)\"\n            R\"(^[og]+[\\p{scx=armn}]|[\\p{scx=armn}][og]+$|)\"\n            R\"([\\p{scx=armn}][og]+[\\p{scx=armn}]|)\"\n            R\"([\\p{sc=cans}].*[a-z]|[a-z].*[\\p{sc=cans}]|)\"\n             R\"([\\p{sc=tfng}].*[a-z]|[a-z].*[\\p{sc=tfng}]|)\"\n             R\"([^\\p{scx=latn}\\p{scx=grek}\\p{scx=cyrl}][\\u0300-\\u0339]|)\"\n             R\"([^\\p{scx=arab}][\\u064b-\\u0655\\u0670]|)\"\n            R\"([^\\p{scx=hebr}]\\u05b4)\",\n             -1, US_INV),\n         0, status);\n     tls_index.Set(dangerous_pattern);\n  }\n  dangerous_pattern->reset(label_string);\n  return !dangerous_pattern->find();\n}\n",
    "vul":1,
    "flaw_line_no":[
      47
    ],
    "bigvul_id":186932
  },
  {
    "code":"IntSize WebPagePrivate::transformedActualVisibleSize() const\n{\n    return IntSize(m_actualVisibleWidth, m_actualVisibleHeight);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":111406
  },
  {
    "code":"v8::Persistent<v8::FunctionTemplate> V8TestSerializedScriptValueInterface::GetTemplate()\n{\n    V8BindingPerIsolateData* data = V8BindingPerIsolateData::current();\n    V8BindingPerIsolateData::TemplateMap::iterator result = data->templateMap().find(&info);\n    if (result != data->templateMap().end())\n        return result->second;\n    v8::HandleScope handleScope;\n    v8::Persistent<v8::FunctionTemplate> templ =\n        ConfigureV8TestSerializedScriptValueInterfaceTemplate(GetRawTemplate());\n    data->templateMap().add(&info, templ);\n    return templ;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":117922
  },
  {
    "code":"static struct page *balloon_retrieve(bool require_lowmem)\n{\n  struct page *page;\n  if (list_empty(&ballooned_pages))\n    return NULL;\n  page = list_entry(ballooned_pages.next, struct page, lru);\n  if (require_lowmem && PageHighMem(page))\n    return NULL;\n  list_del(&page->lru);\n  if (PageHighMem(page))\n    balloon_stats.balloon_high--;\n  else\n    balloon_stats.balloon_low--;\n  return page;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":87387
  },
  {
    "code":"void Document::ApplyFeaturePolicyFromHeader(\n    const String& feature_policy_header) {\n  if (!feature_policy_header.IsEmpty())\n    UseCounter::Count(*this, WebFeature::kFeaturePolicyHeader);\n  Vector<String> messages;\n  auto declared_policy = ParseFeaturePolicyHeader(\n      feature_policy_header, GetSecurityOrigin(), &messages, this);\n  for (auto& message : messages) {\n    AddConsoleMessage(ConsoleMessage::Create(\n        kSecurityMessageSource, mojom::ConsoleMessageLevel::kError,\n        \"Error with Feature-Policy header: \" + message));\n  }\n  if (GetSandboxFlags() != kSandboxNone &&\n      RuntimeEnabledFeatures::FeaturePolicyForSandboxEnabled()) {\n    ApplySandboxFlagsToParsedFeaturePolicy(GetSandboxFlags(), declared_policy);\n  }\n  ApplyFeaturePolicy(declared_policy);\n  if (frame_) {\n    frame_->Client()->DidSetFramePolicyHeaders(GetSandboxFlags(),\n                                               declared_policy);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":140958
  },
  {
    "code":"const char* PropStateToString(int prop_state) {\n  switch (static_cast<IBusPropState>(prop_state)) {\n    case PROP_STATE_UNCHECKED:\n      return \"UNCHECKED\";\n    case PROP_STATE_CHECKED:\n      return \"CHECKED\";\n    case PROP_STATE_INCONSISTENT:\n      return \"INCONSISTENT\";\n  }\n  return \"UNKNOWN\";\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":105739
  },
  {
    "code":"void WebGraphicsContext3DDefaultImpl::shaderSource(WebGLId shader, const char* string)\n{\n    makeContextCurrent();\n    GLint length = string ? strlen(string) : 0;\n    ShaderSourceMap::iterator result = m_shaderSourceMap.find(shader);\n    if (result != m_shaderSourceMap.end()) {\n        ShaderSourceEntry* entry = result->second;\n        ASSERT(entry);\n        if (entry->source) {\n            fastFree(entry->source);\n            entry->source = 0;\n        }\n        if (!tryFastMalloc((length + 1) * sizeof(char)).getValue(entry->source))\n            return; \n        memcpy(entry->source, string, (length + 1) * sizeof(char));\n    } else\n        glShaderSource(shader, 1, &string, &length);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":99022
  },
  {
    "code":"ContentEncoding::~ContentEncoding() {\n ContentCompression** comp_i = compression_entries_;\n ContentCompression** const comp_j = compression_entries_end_;\n while (comp_i != comp_j) {\n ContentCompression* const comp = *comp_i++;\n delete comp;\n }\n delete[] compression_entries_;\n ContentEncryption** enc_i = encryption_entries_;\n ContentEncryption** const enc_j = encryption_entries_end_;\n while (enc_i != enc_j) {\n ContentEncryption* const enc = *enc_i++;\n delete enc;\n }\n delete[] encryption_entries_;\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":174026
  },
  {
    "code":"static int isBranchInstr(mips_instruction * i)\n{\n  switch (MIPSInst_OPCODE(*i)) {\n  case spec_op:\n    switch (MIPSInst_FUNC(*i)) {\n    case jalr_op:\n    case jr_op:\n      return 1;\n    }\n    break;\n  case bcond_op:\n    switch (MIPSInst_RT(*i)) {\n    case bltz_op:\n    case bgez_op:\n    case bltzl_op:\n    case bgezl_op:\n    case bltzal_op:\n    case bgezal_op:\n    case bltzall_op:\n    case bgezall_op:\n      return 1;\n    }\n    break;\n  case j_op:\n  case jal_op:\n  case jalx_op:\n  case beq_op:\n  case bne_op:\n  case blez_op:\n  case bgtz_op:\n  case beql_op:\n  case bnel_op:\n  case blezl_op:\n  case bgtzl_op:\n    return 1;\n  case cop0_op:\n  case cop1_op:\n  case cop2_op:\n  case cop1x_op:\n    if (MIPSInst_RS(*i) == bc_op)\n      return 1;\n    break;\n  }\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":25445
  },
  {
    "code":"void RenderViewTest::SimulateRectTap(const gfx::Rect& rect) {\n  WebGestureEvent gesture_event(\n      WebInputEvent::kGestureTap, WebInputEvent::kNoModifiers,\n      ui::EventTimeStampToSeconds(ui::EventTimeForNow()));\n  gesture_event.x = rect.CenterPoint().x();\n  gesture_event.y = rect.CenterPoint().y();\n  gesture_event.data.tap.tap_count = 1;\n  gesture_event.data.tap.width = rect.width();\n  gesture_event.data.tap.height = rect.height();\n  gesture_event.source_device = blink::kWebGestureDeviceTouchpad;\n  RenderViewImpl* impl = static_cast<RenderViewImpl*>(view_);\n  impl->OnMessageReceived(InputMsg_HandleInputEvent(\n      0, &gesture_event, std::vector<const WebInputEvent*>(), ui::LatencyInfo(),\n      InputEventDispatchType::DISPATCH_TYPE_BLOCKING));\n  impl->FocusChangeComplete();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":137414
  },
  {
    "code":"static struct bpf_reg_state *reg_state(struct bpf_verifier_env *env, int regno)\n{\n  return cur_regs(env) + regno;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":91468
  },
  {
    "code":"void FoFiType1C::eexecWriteCharstring(Type1CEexecBuf *eb,\n              Guchar *s, int n) {\n  Guchar x;\n  int i;\n  for (i = 0; i < n; ++i) {\n    x = s[i] ^ (eb->r1 >> 8);\n    eb->r1 = (x + eb->r1) * 52845 + 22719;\n    if (eb->ascii) {\n      (*eb->outputFunc)(eb->outputStream, &hexChars[x >> 4], 1);\n      (*eb->outputFunc)(eb->outputStream, &hexChars[x & 0x0f], 1);\n      eb->line += 2;\n      if (eb->line == 64) {\n  (*eb->outputFunc)(eb->outputStream, \"\\n\", 1);\n  eb->line = 0;\n      }\n    } else {\n      (*eb->outputFunc)(eb->outputStream, (char *)&x, 1);\n    }\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":2209
  },
  {
    "code":"bool RenderFrameHostImpl::IsBeforeUnloadHangMonitorDisabledForTesting() {\n  return !beforeunload_timeout_;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":138713
  },
  {
    "code":"int RenderBlock::firstLineBoxBaseline() const\n{\n    if (isWritingModeRoot() && !isRubyRun())\n        return -1;\n    if (childrenInline()) {\n        if (firstLineBox())\n            return firstLineBox()->logicalTop() + style(true)->fontMetrics().ascent(firstRootBox()->baselineType());\n        else\n            return -1;\n    }\n    else {\n        for (RenderBox* curr = firstChildBox(); curr; curr = curr->nextSiblingBox()) {\n            if (!curr->isFloatingOrOutOfFlowPositioned()) {\n                int result = curr->firstLineBoxBaseline();\n                if (result != -1)\n                    return curr->logicalTop() + result; \n            }\n        }\n    }\n    return -1;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":124547
  },
  {
    "code":"void WebPagePrivate::scheduleCompositingRun()\n{\n    if (WebPageCompositorClient* compositorClient = compositor()->client()) {\n        double animationTime = compositorClient->requestAnimationFrame();\n        compositorClient->invalidate(animationTime);\n        return;\n    }\n    blitVisibleContents();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":111318
  },
  {
    "code":"int filemap_fdatawait(struct address_space *mapping)\n{\n  loff_t i_size = i_size_read(mapping->host);\n  if (i_size == 0)\n    return 0;\n  return wait_on_page_writeback_range(mapping, 0,\n        (i_size - 1) >> PAGE_CACHE_SHIFT);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":58798
  },
  {
    "code":" virtual status_t setDefaultBufferDataSpace(\n            android_dataspace defaultDataSpace) {\n Parcel data, reply;\n        data.writeInterfaceToken(IGraphicBufferConsumer::getInterfaceDescriptor());\n        data.writeInt32(static_cast<int32_t>(defaultDataSpace));\n status_t result = remote()->transact(SET_DEFAULT_BUFFER_DATA_SPACE,\n                data, &reply);\n if (result != NO_ERROR) {\n return result;\n }\n return reply.readInt32();\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":174085
  },
  {
    "code":"void MultibufferDataSource::MediaIsPlaying() {\n  DCHECK(render_task_runner_->BelongsToCurrentThread());\n  media_has_played_ = true;\n  cancel_on_defer_ = false;\n  preload_ = AUTO;\n  url_data_and_loading_state_.SetLoadingState(\n      UrlData::UrlDataWithLoadingState::LoadingState::kHasPlayed);\n  UpdateBufferSizes();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":157033
  },
  {
    "code":"static int read_config(const char *path)\n{\n  return recursive_action(path, ACTION_RECURSE | ACTION_QUIET,\n        config_file_action, NULL, NULL, 1);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":16751
  },
  {
    "code":"void ChromePasswordManagerClient::DidStartNavigation(\n    content::NavigationHandle* navigation_handle) {\n  log_manager_->SetSuspended(web_contents()->GetWebUI() != nullptr);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":142275
  },
  {
    "code":"void Downmix_foldFromQuad(int16_t *pSrc, int16_t*pDst, size_t numFrames, bool accumulate) {\n if (accumulate) {\n while (numFrames) {\n            pDst[0] = clamp16(pDst[0] + ((pSrc[0] + pSrc[2]) >> 1));\n            pDst[1] = clamp16(pDst[1] + ((pSrc[1] + pSrc[3]) >> 1));\n            pSrc += 4;\n            pDst += 2;\n            numFrames--;\n }\n } else { \n while (numFrames) {\n            pDst[0] = clamp16((pSrc[0] + pSrc[2]) >> 1);\n            pDst[1] = clamp16((pSrc[1] + pSrc[3]) >> 1);\n            pSrc += 4;\n            pDst += 2;\n            numFrames--;\n }\n }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":170538
  },
  {
    "code":"static int getHeightForLineCount(RenderBlock* block, int l, bool includeBottom, int& count)\n{\n    if (block->style()->visibility() == VISIBLE) {\n        if (block->childrenInline()) {\n            for (RootInlineBox* box = block->firstRootBox(); box; box = box->nextRootBox()) {\n                if (++count == l)\n                    return box->lineBottom() + (includeBottom ? (block->borderBottom() + block->paddingBottom()) : LayoutUnit());\n            }\n        }\n        else {\n            RenderBox* normalFlowChildWithoutLines = 0;\n            for (RenderBox* obj = block->firstChildBox(); obj; obj = obj->nextSiblingBox()) {\n                if (shouldCheckLines(obj)) {\n                    int result = getHeightForLineCount(toRenderBlock(obj), l, false, count);\n                    if (result != -1)\n                        return result + obj->y() + (includeBottom ? (block->borderBottom() + block->paddingBottom()) : LayoutUnit());\n                } else if (!obj->isFloatingOrOutOfFlowPositioned())\n                    normalFlowChildWithoutLines = obj;\n            }\n            if (normalFlowChildWithoutLines && l == 0)\n                return normalFlowChildWithoutLines->y() + normalFlowChildWithoutLines->height();\n        }\n    }\n    return -1;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":124550
  },
  {
    "code":"void ChromeClientImpl::Focus() {\n  if (web_view_->Client())\n    web_view_->Client()->DidFocus();\n }\n",
    "vul":1,
    "flaw_line_no":[
      2,
      3
    ],
    "bigvul_id":186701
  },
  {
    "code":"static void jas_icccurv_dump(jas_iccattrval_t *attrval, FILE *out)\n{\n  int i;\n  jas_icccurv_t *curv = &attrval->data.curv;\n  fprintf(out, \"number of entries = %\"PRIuFAST32\"\\n\", curv->numents);\n  if (curv->numents == 1) {\n    fprintf(out, \"gamma = %f\\n\", curv->ents[0] \/ 256.0);\n  } else {\n    for (i = 0; i < JAS_CAST(int, curv->numents); ++i) {\n      if (i < 3 || i >= JAS_CAST(int, curv->numents) - 3) {\n        fprintf(out, \"entry[%d] = %f\\n\", i, curv->ents[i] \/ 65535.0);\n      }\n    }\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":72692
  },
  {
    "code":"status_t OMXNodeInstance::emptyBuffer(\n        OMX::buffer_id buffer,\n        OMX_U32 rangeOffset, OMX_U32 rangeLength,\n        OMX_U32 flags, OMX_TICKS timestamp) {\n Mutex::Autolock autoLock(mLock);\n    OMX_BUFFERHEADERTYPE *header = findBufferHeader(buffer);\n if (rangeOffset > header->nAllocLen\n || rangeLength > header->nAllocLen - rangeOffset) {\n return BAD_VALUE;\n }\n    header->nFilledLen = rangeLength;\n    header->nOffset = rangeOffset;\n BufferMeta *buffer_meta =\n static_cast<BufferMeta *>(header->pAppPrivate);\n    buffer_meta->CopyToOMX(header);\n return emptyBuffer_l(header, flags, timestamp, (intptr_t)buffer);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":170725
  },
  {
    "code":"static MagickBooleanType WriteVIFFImage(const ImageInfo *image_info,\n  Image *image)\n{\n#define VFF_CM_genericRGB  15\n#define VFF_CM_NONE  0\n#define VFF_DEP_IEEEORDER  0x2\n#define VFF_DES_RAW  0\n#define VFF_LOC_IMPLICIT  1\n#define VFF_MAPTYP_NONE  0\n#define VFF_MAPTYP_1_BYTE  1\n#define VFF_MS_NONE  0\n#define VFF_MS_ONEPERBAND  1\n#define VFF_TYP_BIT  0\n#define VFF_TYP_1_BYTE  1\n  typedef struct _ViffInfo\n  {\n    char\n      identifier,\n      file_type,\n      release,\n      version,\n      machine_dependency,\n      reserve[3],\n      comment[512];\n    size_t\n      rows,\n      columns,\n      subrows;\n    int\n      x_offset,\n      y_offset;\n    unsigned int\n      x_bits_per_pixel,\n      y_bits_per_pixel,\n      location_type,\n      location_dimension,\n      number_of_images,\n      number_data_bands,\n      data_storage_type,\n      data_encode_scheme,\n      map_scheme,\n      map_storage_type,\n      map_rows,\n      map_columns,\n      map_subrows,\n      map_enable,\n      maps_per_cycle,\n      color_space_model;\n  } ViffInfo;\n  const char\n    *value;\n  MagickBooleanType\n    status;\n  MagickOffsetType\n    scene;\n  MagickSizeType\n    number_pixels,\n    packets;\n  MemoryInfo\n    *pixel_info;\n  register const IndexPacket\n    *indexes;\n  register const PixelPacket\n    *p;\n  register ssize_t\n    x;\n  register ssize_t\n    i;\n  register unsigned char\n    *q;\n  ssize_t\n    y;\n  unsigned char\n    *pixels;\n  ViffInfo\n    viff_info;\n  assert(image_info != (const ImageInfo *) NULL);\n  assert(image_info->signature == MagickSignature);\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  status=OpenBlob(image_info,image,WriteBinaryBlobMode,&image->exception);\n  if (status == MagickFalse)\n    return(status);\n  (void) ResetMagickMemory(&viff_info,0,sizeof(ViffInfo));\n  scene=0;\n  do\n  {\n    (void) TransformImageColorspace(image,sRGBColorspace);\nDisableMSCWarning(4310)\n    viff_info.identifier=(char) 0xab;\nRestoreMSCWarning\n    viff_info.file_type=1;\n    viff_info.release=1;\n    viff_info.version=3;\n    viff_info.machine_dependency=VFF_DEP_IEEEORDER;  \n    *viff_info.comment='\\0';\n    value=GetImageProperty(image,\"comment\");\n    if (value != (const char *) NULL)\n      (void) CopyMagickString(viff_info.comment,value,MagickMin(strlen(value),\n        511)+1);\n    viff_info.rows=image->columns;\n    viff_info.columns=image->rows;\n    viff_info.subrows=0;\n    viff_info.x_offset=(~0);\n    viff_info.y_offset=(~0);\n    viff_info.x_bits_per_pixel=0;\n    viff_info.y_bits_per_pixel=0;\n    viff_info.location_type=VFF_LOC_IMPLICIT;\n    viff_info.location_dimension=0;\n    viff_info.number_of_images=1;\n    viff_info.data_encode_scheme=VFF_DES_RAW;\n    viff_info.map_scheme=VFF_MS_NONE;\n    viff_info.map_storage_type=VFF_MAPTYP_NONE;\n    viff_info.map_rows=0;\n    viff_info.map_columns=0;\n    viff_info.map_subrows=0;\n    viff_info.map_enable=1;  \n    viff_info.maps_per_cycle=0;\n    number_pixels=(MagickSizeType) image->columns*image->rows;\n    if (image->storage_class == DirectClass)\n      {\n        viff_info.number_data_bands=image->matte ? 4U : 3U;\n        viff_info.color_space_model=VFF_CM_genericRGB;\n        viff_info.data_storage_type=VFF_TYP_1_BYTE;\n        packets=viff_info.number_data_bands*number_pixels;\n      }\n    else\n      {\n        viff_info.number_data_bands=1;\n        viff_info.color_space_model=VFF_CM_NONE;\n        viff_info.data_storage_type=VFF_TYP_1_BYTE;\n        packets=number_pixels;\n        if (IsGrayImage(image,&image->exception) == MagickFalse)\n          {\n            viff_info.map_scheme=VFF_MS_ONEPERBAND;\n            viff_info.map_storage_type=VFF_MAPTYP_1_BYTE;\n            viff_info.map_rows=3;\n            viff_info.map_columns=(unsigned int) image->colors;\n          }\n        else\n          if (image->colors <= 2)\n            {\n              viff_info.data_storage_type=VFF_TYP_BIT;\n              packets=((image->columns+7) >> 3)*image->rows;\n            }\n      }\n    (void) WriteBlob(image,sizeof(viff_info.identifier),(unsigned char *)\n      &viff_info.identifier);\n    (void) WriteBlob(image,sizeof(viff_info.file_type),(unsigned char *)\n      &viff_info.file_type);\n    (void) WriteBlob(image,sizeof(viff_info.release),(unsigned char *)\n      &viff_info.release);\n    (void) WriteBlob(image,sizeof(viff_info.version),(unsigned char *)\n      &viff_info.version);\n    (void) WriteBlob(image,sizeof(viff_info.machine_dependency),\n      (unsigned char *) &viff_info.machine_dependency);\n    (void) WriteBlob(image,sizeof(viff_info.reserve),(unsigned char *)\n      viff_info.reserve);\n    (void) WriteBlob(image,512,(unsigned char *) viff_info.comment);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.rows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.columns);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.subrows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.x_offset);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.y_offset);\n    viff_info.x_bits_per_pixel=(unsigned int) ((63 << 24) | (128 << 16));\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.x_bits_per_pixel);\n    viff_info.y_bits_per_pixel=(unsigned int) ((63 << 24) | (128 << 16));\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.y_bits_per_pixel);\n    (void) WriteBlobMSBLong(image,viff_info.location_type);\n    (void) WriteBlobMSBLong(image,viff_info.location_dimension);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.number_of_images);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.number_data_bands);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.data_storage_type);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.data_encode_scheme);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_scheme);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_storage_type);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_rows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_columns);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_subrows);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.map_enable);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.maps_per_cycle);\n    (void) WriteBlobMSBLong(image,(unsigned int) viff_info.color_space_model);\n    for (i=0; i < 420; i++)\n      (void) WriteBlobByte(image,'\\0');\n    pixel_info=AcquireVirtualMemory((size_t) packets,sizeof(*pixels));\n    if (pixel_info == (MemoryInfo *) NULL)\n      ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n    pixels=(unsigned char *) GetVirtualMemoryBlob(pixel_info);\n    q=pixels;\n    if (image->storage_class == DirectClass)\n      {\n        number_pixels=(MagickSizeType) image->columns*image->rows;\n        for (y=0; y < (ssize_t) image->rows; y++)\n        {\n          p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n          if (p == (const PixelPacket *) NULL)\n            break;\n          for (x=0; x < (ssize_t) image->columns; x++)\n          {\n            *q=ScaleQuantumToChar(GetPixelRed(p));\n            *(q+number_pixels)=ScaleQuantumToChar(GetPixelGreen(p));\n            *(q+number_pixels*2)=ScaleQuantumToChar(GetPixelBlue(p));\n            if (image->matte != MagickFalse)\n              *(q+number_pixels*3)=ScaleQuantumToChar((Quantum)\n                (GetPixelAlpha(p)));\n            p++;\n            q++;\n          }\n          if (image->previous == (Image *) NULL)\n            {\n              status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n              if (status == MagickFalse)\n                break;\n            }\n        }\n      }\n    else\n      if (IsGrayImage(image,&image->exception) == MagickFalse)\n        {\n          unsigned char\n            *viff_colormap;\n          viff_colormap=(unsigned char *) AcquireQuantumMemory(image->colors,\n            3*sizeof(*viff_colormap));\n          if (viff_colormap == (unsigned char *) NULL)\n            ThrowWriterException(ResourceLimitError,\"MemoryAllocationFailed\");\n          q=viff_colormap;\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].red);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].green);\n          for (i=0; i < (ssize_t) image->colors; i++)\n            *q++=ScaleQuantumToChar(image->colormap[i].blue);\n          (void) WriteBlob(image,3*image->colors,viff_colormap);\n          viff_colormap=(unsigned char *) RelinquishMagickMemory(viff_colormap);\n          q=pixels;\n          for (y=0; y < (ssize_t) image->rows; y++)\n          {\n            p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n            if (p == (const PixelPacket *) NULL)\n              break;\n            indexes=GetVirtualIndexQueue(image);\n            for (x=0; x < (ssize_t) image->columns; x++)\n              *q++=(unsigned char) GetPixelIndex(indexes+x);\n            if (image->previous == (Image *) NULL)\n              {\n                status=SetImageProgress(image,SaveImageTag,(MagickOffsetType) y,\n                image->rows);\n                if (status == MagickFalse)\n                  break;\n              }\n          }\n        }\n      else\n        if (image->colors <= 2)\n          {\n            ssize_t\n              x,\n              y;\n            register unsigned char\n              bit,\n              byte;\n            (void) SetImageType(image,BilevelType);\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              indexes=GetVirtualIndexQueue(image);\n              bit=0;\n              byte=0;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                byte>>=1;\n                if (GetPixelLuma(image,p) < (QuantumRange\/2.0))\n                  byte|=0x80;\n                bit++;\n                if (bit == 8)\n                  {\n                    *q++=byte;\n                    bit=0;\n                    byte=0;\n                  }\n              }\n              if (bit != 0)\n                *q++=byte >> (8-bit);\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n        else\n          {\n            for (y=0; y < (ssize_t) image->rows; y++)\n            {\n              p=GetVirtualPixels(image,0,y,image->columns,1,&image->exception);\n              if (p == (const PixelPacket *) NULL)\n                break;\n              for (x=0; x < (ssize_t) image->columns; x++)\n              {\n                *q++=(unsigned char) ClampToQuantum(GetPixelLuma(image,p));\n                p++;\n              }\n              if (image->previous == (Image *) NULL)\n                {\n                  status=SetImageProgress(image,SaveImageTag,(MagickOffsetType)\n                    y,image->rows);\n                  if (status == MagickFalse)\n                    break;\n                }\n            }\n          }\n    (void) WriteBlob(image,(size_t) packets,pixels);\n    pixel_info=RelinquishVirtualMemory(pixel_info);\n    if (GetNextImageInList(image) == (Image *) NULL)\n      break;\n    image=SyncNextImageInList(image);\n    status=SetImageProgress(image,SaveImagesTag,scene++,\n      GetImageListLength(image));\n    if (status == MagickFalse)\n      break;\n  } while (image_info->adjoin != MagickFalse);\n  (void) CloseBlob(image);\n  return(MagickTrue);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":71782
  },
  {
    "code":"static void sctp_v4_pf_init(void)\n{\n  sctp_register_pf(&sctp_pf_inet, PF_INET);\n  sctp_register_af(&sctp_af_inet);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":42945
  },
  {
    "code":"SAPI_API int sapi_get_fd(int *fd TSRMLS_DC)\n{\n  if (sapi_module.get_fd) {\n    return sapi_module.get_fd(fd TSRMLS_CC);\n  } else {\n    return FAILURE;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":56274
  },
  {
    "code":"ID3::ID3(const uint8_t *data, size_t size, bool ignoreV1)\n : mIsValid(false),\n      mData(NULL),\n      mSize(0),\n      mFirstFrameOffset(0),\n      mVersion(ID3_UNKNOWN),\n      mRawSize(0) {\n    sp<MemorySource> source = new (std::nothrow) MemorySource(data, size);\n if (source == NULL)\n return;\n    mIsValid = parseV2(source, 0);\n if (!mIsValid && !ignoreV1) {\n        mIsValid = parseV1(source);\n }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":175750
  },
  {
    "code":"static MagickBooleanType WritePCDTile(Image *image,const char *page_geometry,\n  const size_t tile_columns,const size_t tile_rows,ExceptionInfo *exception)\n{\n  GeometryInfo\n    geometry_info;\n  Image\n    *downsample_image,\n    *tile_image;\n  MagickBooleanType\n    status;\n  MagickStatusType\n    flags;\n  RectangleInfo\n    geometry;\n  register const Quantum\n    *p,\n    *q;\n  register ssize_t\n    i,\n    x;\n  ssize_t\n    y;\n  SetGeometry(image,&geometry);\n  (void) ParseMetaGeometry(page_geometry,&geometry.x,&geometry.y,\n    &geometry.width,&geometry.height);\n  if ((geometry.width % 2) != 0)\n    geometry.width--;\n  if ((geometry.height % 2) != 0)\n    geometry.height--;\n  tile_image=ResizeImage(image,geometry.width,geometry.height,TriangleFilter,\n    exception);\n  if (tile_image == (Image *) NULL)\n    return(MagickFalse);\n  flags=ParseGeometry(page_geometry,&geometry_info);\n  geometry.width=(size_t) geometry_info.rho;\n  geometry.height=(size_t) geometry_info.sigma;\n  if ((flags & SigmaValue) == 0)\n    geometry.height=geometry.width;\n  if ((tile_image->columns != geometry.width) ||\n      (tile_image->rows != geometry.height))\n    {\n      Image\n        *bordered_image;\n      RectangleInfo\n        border_info;\n      border_info.width=(geometry.width-tile_image->columns+1) >> 1;\n      border_info.height=(geometry.height-tile_image->rows+1) >> 1;\n      bordered_image=BorderImage(tile_image,&border_info,image->compose,\n        exception);\n      if (bordered_image == (Image *) NULL)\n        return(MagickFalse);\n      tile_image=DestroyImage(tile_image);\n      tile_image=bordered_image;\n    }\n  if ((tile_image->columns != tile_columns) || (tile_image->rows != tile_rows))\n    {\n      Image\n        *resize_image;\n      resize_image=ResizeImage(tile_image,tile_columns,tile_rows,\n        tile_image->filter,exception);\n      if (resize_image != (Image *) NULL)\n        {\n          tile_image=DestroyImage(tile_image);\n          tile_image=resize_image;\n        }\n    }\n  (void) TransformImageColorspace(tile_image,YCCColorspace,exception);\n  downsample_image=ResizeImage(tile_image,tile_image->columns\/2,\n    tile_image->rows\/2,TriangleFilter,exception);\n  if (downsample_image == (Image *) NULL)\n    return(MagickFalse);\n  for (y=0; y < (ssize_t) tile_image->rows; y+=2)\n  {\n    p=GetVirtualPixels(tile_image,0,y,tile_image->columns,2,exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) (tile_image->columns << 1); x++)\n    {\n      (void) WriteBlobByte(image,ScaleQuantumToChar(GetPixelRed(tile_image,p)));\n      p+=GetPixelChannels(tile_image);\n    }\n    q=GetVirtualPixels(downsample_image,0,y >> 1,downsample_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) downsample_image->columns; x++)\n    {\n      (void) WriteBlobByte(image,ScaleQuantumToChar(\n        GetPixelGreen(tile_image,q)));\n      q+=GetPixelChannels(tile_image);\n    }\n    q=GetVirtualPixels(downsample_image,0,y >> 1,downsample_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0; x < (ssize_t) downsample_image->columns; x++)\n    {\n      (void) WriteBlobByte(image,ScaleQuantumToChar(\n        GetPixelBlue(tile_image,q)));\n      q+=GetPixelChannels(tile_image);\n    }\n    status=SetImageProgress(image,SaveImageTag,y,tile_image->rows);\n    if (status == MagickFalse)\n      break;\n  }\n  for (i=0; i < 0x800; i++)\n    (void) WriteBlobByte(image,'\\0');\n  downsample_image=DestroyImage(downsample_image);\n  tile_image=DestroyImage(tile_image);\n  return(MagickTrue);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":91490
  },
  {
    "code":"png_get_signature(png_structp png_ptr, png_infop info_ptr)\n{\n   if (png_ptr != NULL && info_ptr != NULL)\n      return(info_ptr->signature);\n   else\n      return (NULL);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":143981
  },
  {
    "code":"void Parcel::initState()\n{\n    LOG_ALLOC(\"Parcel %p: initState\", this);\n    mError = NO_ERROR;\n    mData = 0;\n    mDataSize = 0;\n    mDataCapacity = 0;\n    mDataPos = 0;\n    ALOGV(\"initState Setting data size of %p to %zu\", this, mDataSize);\n    ALOGV(\"initState Setting data pos of %p to %zu\", this, mDataPos);\n    mObjects = NULL;\n    mObjectsSize = 0;\n    mObjectsCapacity = 0;\n    mNextObjectHint = 0;\n    mHasFds = false;\n    mFdsKnown = true;\n    mAllowFds = true;\n    mOwner = NULL;\n    mOpenAshmemSize = 0;\n if (gMaxFds == 0) {\n struct rlimit result;\n if (!getrlimit(RLIMIT_NOFILE, &result)) {\n            gMaxFds = (size_t)result.rlim_cur;\n } else {\n            ALOGW(\"Unable to getrlimit: %s\", strerror(errno));\n            gMaxFds = 1024;\n }\n }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":176729
  },
  {
    "code":"static void nr_set_lockdep_key(struct net_device *dev)\n{\n  lockdep_set_class(&dev->addr_list_lock, &nr_netdev_addr_lock_key);\n  netdev_for_each_tx_queue(dev, nr_set_lockdep_one, NULL);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":30527
  },
  {
    "code":"static void srpt_cm_rtu_recv(struct ib_cm_id *cm_id)\n{\n  struct srpt_rdma_ch *ch;\n  int ret;\n  ch = srpt_find_channel(cm_id->context, cm_id);\n  BUG_ON(!ch);\n  if (srpt_test_and_set_ch_state(ch, CH_CONNECTING, CH_LIVE)) {\n    struct srpt_recv_ioctx *ioctx, *ioctx_tmp;\n    ret = srpt_ch_qp_rts(ch, ch->qp);\n    list_for_each_entry_safe(ioctx, ioctx_tmp, &ch->cmd_wait_list,\n           wait_list) {\n      list_del(&ioctx->wait_list);\n      srpt_handle_new_iu(ch, ioctx, NULL);\n    }\n    if (ret)\n      srpt_close_ch(ch);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":50643
  },
  {
    "code":"ofputil_port_stats_to_ofp11(const struct ofputil_port_stats *ops,\n                            struct ofp11_port_stats *ps11)\n{\n    ps11->port_no = ofputil_port_to_ofp11(ops->port_no);\n    memset(ps11->pad, 0, sizeof ps11->pad);\n    ps11->rx_packets = htonll(ops->stats.rx_packets);\n    ps11->tx_packets = htonll(ops->stats.tx_packets);\n    ps11->rx_bytes = htonll(ops->stats.rx_bytes);\n    ps11->tx_bytes = htonll(ops->stats.tx_bytes);\n    ps11->rx_dropped = htonll(ops->stats.rx_dropped);\n    ps11->tx_dropped = htonll(ops->stats.tx_dropped);\n    ps11->rx_errors = htonll(ops->stats.rx_errors);\n    ps11->tx_errors = htonll(ops->stats.tx_errors);\n    ps11->rx_frame_err = htonll(ops->stats.rx_frame_errors);\n    ps11->rx_over_err = htonll(ops->stats.rx_over_errors);\n    ps11->rx_crc_err = htonll(ops->stats.rx_crc_errors);\n    ps11->collisions = htonll(ops->stats.collisions);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":77654
  },
  {
    "code":"xfs_inode_ag_walk_grab(\n  struct xfs_inode  *ip,\n  int      flags)\n{\n  struct inode    *inode = VFS_I(ip);\n  bool      newinos = !!(flags & XFS_AGITER_INEW_WAIT);\n  ASSERT(rcu_read_lock_held());\n  spin_lock(&ip->i_flags_lock);\n  if (!ip->i_ino)\n    goto out_unlock_noent;\n  if ((!newinos && __xfs_iflags_test(ip, XFS_INEW)) ||\n      __xfs_iflags_test(ip, XFS_IRECLAIMABLE | XFS_IRECLAIM))\n    goto out_unlock_noent;\n  spin_unlock(&ip->i_flags_lock);\n  if (XFS_FORCED_SHUTDOWN(ip->i_mount))\n    return -EFSCORRUPTED;\n  if (!igrab(inode))\n    return -ENOENT;\n  return 0;\nout_unlock_noent:\n  spin_unlock(&ip->i_flags_lock);\n  return -ENOENT;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":79958
  },
  {
    "code":"void ImageResource::OnMemoryDump(WebMemoryDumpLevelOfDetail level_of_detail,\n                                 WebProcessMemoryDump* memory_dump) const {\n  Resource::OnMemoryDump(level_of_detail, memory_dump);\n  const String name = GetMemoryDumpName() + \"\/image_content\";\n  auto* dump = memory_dump->CreateMemoryAllocatorDump(name);\n  size_t encoded_size =\n      content_->HasImage() ? content_->GetImage()->Data()->size() : 0;\n  dump->AddScalar(\"size\", \"bytes\", encoded_size);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":162477
  },
  {
    "code":"static void update_exception_bitmap(struct kvm_vcpu *vcpu)\n{\n  u32 eb;\n  eb = (1u << PF_VECTOR) | (1u << UD_VECTOR) | (1u << MC_VECTOR) |\n       (1u << DB_VECTOR) | (1u << AC_VECTOR);\n  if ((vcpu->guest_debug &\n       (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP)) ==\n      (KVM_GUESTDBG_ENABLE | KVM_GUESTDBG_USE_SW_BP))\n    eb |= 1u << BP_VECTOR;\n  if (to_vmx(vcpu)->rmode.vm86_active)\n    eb = ~0;\n  if (enable_ept)\n    eb &= ~(1u << PF_VECTOR); \n  if (is_guest_mode(vcpu))\n    eb |= get_vmcs12(vcpu)->exception_bitmap;\n  vmcs_write32(EXCEPTION_BITMAP, eb);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":63022
  },
  {
    "code":"static int pppol2tp_setsockopt(struct socket *sock, int level, int optname,\n             char __user *optval, unsigned int optlen)\n{\n  struct sock *sk = sock->sk;\n  struct l2tp_session *session;\n  struct l2tp_tunnel *tunnel;\n  struct pppol2tp_session *ps;\n  int val;\n  int err;\n  if (level != SOL_PPPOL2TP)\n    return udp_prot.setsockopt(sk, level, optname, optval, optlen);\n  if (optlen < sizeof(int))\n    return -EINVAL;\n  if (get_user(val, (int __user *)optval))\n    return -EFAULT;\n  err = -ENOTCONN;\n  if (sk->sk_user_data == NULL)\n    goto end;\n  err = -EBADF;\n  session = pppol2tp_sock_to_session(sk);\n  if (session == NULL)\n    goto end;\n  ps = l2tp_session_priv(session);\n  if ((session->session_id == 0) &&\n      (session->peer_session_id == 0)) {\n    err = -EBADF;\n    tunnel = l2tp_sock_to_tunnel(ps->tunnel_sock);\n    if (tunnel == NULL)\n      goto end_put_sess;\n    err = pppol2tp_tunnel_setsockopt(sk, tunnel, optname, val);\n    sock_put(ps->tunnel_sock);\n  } else\n    err = pppol2tp_session_setsockopt(sk, session, optname, val);\n  err = 0;\nend_put_sess:\n  sock_put(sk);\nend:\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":40490
  },
  {
    "code":"  parse_encoding( T1_Face    face,\n                  T1_Loader  loader )\n  {\n    T1_Parser  parser = &loader->parser;\n    FT_Byte*   cur;\n    FT_Byte*   limit  = parser->root.limit;\n    PSAux_Service  psaux = (PSAux_Service)face->psaux;\n    T1_Skip_Spaces( parser );\n    cur = parser->root.cursor;\n    if ( cur >= limit )\n    {\n      FT_ERROR(( \"parse_encoding: out of bounds\\n\" ));\n      parser->root.error = FT_THROW( Invalid_File_Format );\n      return;\n    }\n    if ( ft_isdigit( *cur ) || *cur == '[' )\n    {\n      T1_Encoding  encode          = &face->type1.encoding;\n      FT_Int       count, n;\n      PS_Table     char_table      = &loader->encoding_table;\n      FT_Memory    memory          = parser->root.memory;\n      FT_Error     error;\n      FT_Bool      only_immediates = 0;\n      if ( *cur == '[' )\n      {\n        count           = 256;\n        only_immediates = 1;\n        parser->root.cursor++;\n      }\n      else\n        count = (FT_Int)T1_ToInt( parser );\n      T1_Skip_Spaces( parser );\n      if ( parser->root.cursor >= limit )\n        return;\n      loader->num_chars = encode->num_chars = count;\n      if ( FT_NEW_ARRAY( encode->char_index, count )     ||\n           FT_NEW_ARRAY( encode->char_name,  count )     ||\n           FT_SET_ERROR( psaux->ps_table_funcs->init(\n                           char_table, count, memory ) ) )\n      {\n        parser->root.error = error;\n        return;\n      }\n      for ( n = 0; n < count; n++ )\n      {\n        char*  notdef = (char *)\".notdef\";\n        T1_Add_Table( char_table, n, notdef, 8 );\n      }\n      n = 0;\n      T1_Skip_Spaces( parser );\n      while ( parser->root.cursor < limit )\n      {\n        cur = parser->root.cursor;\n        if ( *cur == 'd' && cur + 3 < limit )\n        {\n          if ( cur[1] == 'e'         &&\n               cur[2] == 'f'         &&\n               IS_PS_DELIM( cur[3] ) )\n          {\n            FT_TRACE6(( \"encoding end\\n\" ));\n            cur += 3;\n            break;\n          }\n        }\n        if ( *cur == ']' )\n        {\n          FT_TRACE6(( \"encoding end\\n\" ));\n          cur++;\n          break;\n        }\n        if ( ft_isdigit( *cur ) || only_immediates )\n        {\n          FT_Int  charcode;\n          if ( only_immediates )\n            charcode = n;\n          else\n          {\n            charcode = (FT_Int)T1_ToInt( parser );\n            T1_Skip_Spaces( parser );\n            if ( cur == parser->root.cursor )\n            {\n              parser->root.error = FT_THROW( Unknown_File_Format );\n              return;\n            }\n          }\n          cur = parser->root.cursor;\n          if ( cur + 2 < limit && *cur == '\/' && n < count )\n          {\n            FT_PtrDist  len;\n            cur++;\n            parser->root.cursor = cur;\n            T1_Skip_PS_Token( parser );\n            if ( parser->root.cursor >= limit )\n              return;\n            if ( parser->root.error )\n              return;\n            len = parser->root.cursor - cur;\n            parser->root.error = T1_Add_Table( char_table, charcode,\n                                               cur, len + 1 );\n            if ( parser->root.error )\n              return;\n            char_table->elements[charcode][len] = '\\0';\n            n++;\n          }\n          else if ( only_immediates )\n          {\n            parser->root.error = FT_THROW( Unknown_File_Format );\n            return;\n          }\n        }\n        else\n        {\n          T1_Skip_PS_Token( parser );\n          if ( parser->root.error )\n            return;\n        }\n        T1_Skip_Spaces( parser );\n      }\n      face->type1.encoding_type = T1_ENCODING_TYPE_ARRAY;\n      parser->root.cursor       = cur;\n    }\n    else\n    {\n      if ( cur + 17 < limit                                            &&\n           ft_strncmp( (const char*)cur, \"StandardEncoding\", 16 ) == 0 )\n        face->type1.encoding_type = T1_ENCODING_TYPE_STANDARD;\n      else if ( cur + 15 < limit                                          &&\n                ft_strncmp( (const char*)cur, \"ExpertEncoding\", 14 ) == 0 )\n        face->type1.encoding_type = T1_ENCODING_TYPE_EXPERT;\n      else if ( cur + 18 < limit                                             &&\n                ft_strncmp( (const char*)cur, \"ISOLatin1Encoding\", 17 ) == 0 )\n        face->type1.encoding_type = T1_ENCODING_TYPE_ISOLATIN1;\n      else\n        parser->root.error = FT_ERR( Ignore );\n    }\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":7066
  },
  {
    "code":"void WebContentsImpl::UpdateZoomIfNecessary(const std::string& scheme,\n                                            const std::string& host) {\n  NavigationEntry* entry = GetController().GetLastCommittedEntry();\n  if (!entry)\n    return;\n  GURL url = HostZoomMap::GetURLFromEntry(entry);\n  if (host != net::GetHostOrSpecFromURL(url) ||\n      (!scheme.empty() && !url.SchemeIs(scheme))) {\n    return;\n  }\n  UpdateZoom();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":157883
  },
  {
    "code":"  void DeregisterSubprocessAllocator(int id) {\n    provider_.DeregisterSubprocessAllocator(id);\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":143834
  },
  {
    "code":"static void assertTruncateConstraintCb(PgHdr *pPg){\n  assert( pPg->flags&PGHDR_DIRTY );\n  assert( !subjRequiresPage(pPg) || pPg->pgno<=pPg->pPager->dbSize );\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":148987
  },
  {
    "code":"int uv_spawn(uv_loop_t* loop,\n             uv_process_t* process,\n             const uv_process_options_t* options) {\n  int signal_pipe[2] = { -1, -1 };\n  int (*pipes)[2];\n  int stdio_count;\n  QUEUE* q;\n  ssize_t r;\n  pid_t pid;\n  int err;\n  int exec_errorno;\n  int i;\n  assert(options->file != NULL);\n  assert(!(options->flags & ~(UV_PROCESS_DETACHED |\n                              UV_PROCESS_SETGID |\n                              UV_PROCESS_SETUID |\n                              UV_PROCESS_WINDOWS_HIDE |\n                              UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS)));\n  uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS);\n  QUEUE_INIT(&process->queue);\n  stdio_count = options->stdio_count;\n  if (stdio_count < 3)\n    stdio_count = 3;\n  err = -ENOMEM;\n  pipes = malloc(stdio_count * sizeof(*pipes));\n  if (pipes == NULL)\n    goto error;\n  for (i = 0; i < stdio_count; i++) {\n    pipes[i][0] = -1;\n    pipes[i][1] = -1;\n  }\n  for (i = 0; i < options->stdio_count; i++) {\n    err = uv__process_init_stdio(options->stdio + i, pipes[i]);\n    if (err)\n      goto error;\n  }\n  err = uv__make_pipe(signal_pipe, 0);\n  if (err)\n    goto error;\n  uv_signal_start(&loop->child_watcher, uv__chld, SIGCHLD);\n  uv_rwlock_wrlock(&loop->cloexec_lock);\n  pid = fork();\n  if (pid == -1) {\n    err = -errno;\n    uv_rwlock_wrunlock(&loop->cloexec_lock);\n    uv__close(signal_pipe[0]);\n    uv__close(signal_pipe[1]);\n    goto error;\n  }\n  if (pid == 0) {\n    uv__process_child_init(options, stdio_count, pipes, signal_pipe[1]);\n    abort();\n  }\n  uv_rwlock_wrunlock(&loop->cloexec_lock);\n  uv__close(signal_pipe[1]);\n  process->status = 0;\n  exec_errorno = 0;\n  do\n    r = read(signal_pipe[0], &exec_errorno, sizeof(exec_errorno));\n  while (r == -1 && errno == EINTR);\n  if (r == 0)\n    ; \n  else if (r == sizeof(exec_errorno))\n    ; \n  else if (r == -1 && errno == EPIPE)\n    ; \n  else\n    abort();\n  uv__close(signal_pipe[0]);\n  for (i = 0; i < options->stdio_count; i++) {\n    err = uv__process_open_stream(options->stdio + i, pipes[i], i == 0);\n    if (err == 0)\n      continue;\n    while (i--)\n      uv__process_close_stream(options->stdio + i);\n    goto error;\n  }\n  if (exec_errorno == 0) {\n    q = uv__process_queue(loop, pid);\n    QUEUE_INSERT_TAIL(q, &process->queue);\n    uv__handle_start(process);\n  }\n  process->pid = pid;\n  process->exit_cb = options->exit_cb;\n  free(pipes);\n  return exec_errorno;\nerror:\n  if (pipes != NULL) {\n    for (i = 0; i < stdio_count; i++) {\n      if (i < options->stdio_count)\n        if (options->stdio[i].flags & (UV_INHERIT_FD | UV_INHERIT_STREAM))\n          continue;\n      if (pipes[i][0] != -1)\n        close(pipes[i][0]);\n      if (pipes[i][1] != -1)\n        close(pipes[i][1]);\n    }\n    free(pipes);\n  }\n  return err;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":44853
  },
  {
    "code":"bool IsEqualForTesting(const SendTabToSelfEntry& entry,\n                       const sync_pb::SendTabToSelfSpecifics& specifics) {\n  return (\n      entry.GetGUID() == specifics.guid() &&\n      entry.GetURL() == specifics.url() &&\n      entry.GetTitle() == specifics.title() &&\n      entry.GetDeviceName() == specifics.device_name() &&\n      entry.GetTargetDeviceSyncCacheGuid() ==\n          specifics.target_device_sync_cache_guid() &&\n      specifics.shared_time_usec() ==\n          entry.GetSharedTime().ToDeltaSinceWindowsEpoch().InMicroseconds() &&\n      specifics.navigation_time_usec() == entry.GetOriginalNavigationTime()\n                                              .ToDeltaSinceWindowsEpoch()\n                                              .InMicroseconds());\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":155095
  },
  {
    "code":"static struct snd_seq_client_port *get_client_port(struct snd_seq_addr *addr,\n               struct snd_seq_client **cp)\n{\n  struct snd_seq_client_port *p;\n  *cp = snd_seq_client_use_ptr(addr->client);\n  if (*cp) {\n    p = snd_seq_port_use_ptr(*cp, addr->port);\n    if (! p) {\n      snd_seq_client_unlock(*cp);\n      *cp = NULL;\n    }\n    return p;\n  }\n  return NULL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":60619
  },
  {
    "code":"xmlXPathNodeSetAddUnique(xmlNodeSetPtr cur, xmlNodePtr val) {\n    if ((cur == NULL) || (val == NULL)) return;\n#if 0\n    if ((val->type == XML_ELEMENT_NODE) && (val->name[0] == ' '))\n  return;  \n#endif\n    if (cur->nodeMax == 0) {\n        cur->nodeTab = (xmlNodePtr *) xmlMalloc(XML_NODESET_DEFAULT *\n               sizeof(xmlNodePtr));\n  if (cur->nodeTab == NULL) {\n      xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n      return;\n  }\n  memset(cur->nodeTab, 0 ,\n         XML_NODESET_DEFAULT * (size_t) sizeof(xmlNodePtr));\n        cur->nodeMax = XML_NODESET_DEFAULT;\n    } else if (cur->nodeNr == cur->nodeMax) {\n        xmlNodePtr *temp;\n        cur->nodeMax *= 2;\n  temp = (xmlNodePtr *) xmlRealloc(cur->nodeTab, cur->nodeMax *\n              sizeof(xmlNodePtr));\n  if (temp == NULL) {\n      xmlXPathErrMemory(NULL, \"growing nodeset\\n\");\n      return;\n  }\n  cur->nodeTab = temp;\n    }\n    if (val->type == XML_NAMESPACE_DECL) {\n  xmlNsPtr ns = (xmlNsPtr) val;\n  cur->nodeTab[cur->nodeNr++] =\n      xmlXPathNodeSetDupNs((xmlNodePtr) ns->next, ns);\n    } else\n  cur->nodeTab[cur->nodeNr++] = val;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":97735
  },
  {
    "code":"void ReadableStreamBytesConsumer::OnRead(DOMUint8Array* buffer) {\n  DCHECK(is_reading_);\n  DCHECK(buffer);\n  DCHECK(!pending_buffer_);\n  DCHECK(!pending_offset_);\n  is_reading_ = false;\n  if (state_ == PublicState::kClosed)\n    return;\n  DCHECK_EQ(state_, PublicState::kReadableOrWaiting);\n  pending_buffer_ = buffer;\n  if (client_)\n    client_->OnStateChange();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":168512
  },
  {
    "code":"static int config__check(struct mosquitto__config *config)\n{\n#ifdef WITH_BRIDGE\n  int i, j;\n  struct mosquitto__bridge *bridge1, *bridge2;\n  char hostname[256];\n  int len;\n  for(i=0; i<config->bridge_count; i++){\n    bridge1 = &config->bridges[i];\n    if(!bridge1->remote_clientid){\n      if(!gethostname(hostname, 256)){\n        len = strlen(hostname) + strlen(bridge1->name) + 2;\n        bridge1->remote_clientid = mosquitto__malloc(len);\n        if(!bridge1->remote_clientid){\n          return MOSQ_ERR_NOMEM;\n        }\n        snprintf(bridge1->remote_clientid, len, \"%s.%s\", hostname, bridge1->name);\n      }else{\n        return 1;\n      }\n    }\n    if(!bridge1->local_clientid){\n      len = strlen(bridge1->remote_clientid) + strlen(\"local.\") + 2;\n      bridge1->local_clientid = mosquitto__malloc(len);\n      if(!bridge1->local_clientid){\n        log__printf(NULL, MOSQ_LOG_ERR, \"Error: Out of memory.\");\n        return MOSQ_ERR_NOMEM;\n      }\n      snprintf(bridge1->local_clientid, len, \"local.%s\", bridge1->remote_clientid);\n    }\n  }\n  for(i=0; i<config->bridge_count; i++){\n    bridge1 = &config->bridges[i];\n    for(j=i+1; j<config->bridge_count; j++){\n      bridge2 = &config->bridges[j];\n      if(!strcmp(bridge1->local_clientid, bridge2->local_clientid)){\n        log__printf(NULL, MOSQ_LOG_ERR, \"Error: Bridge local_clientid \"\n            \"'%s' is not unique. Try changing or setting the \"\n            \"local_clientid value for one of the bridges.\",\n            bridge1->local_clientid);\n        return MOSQ_ERR_INVAL;\n      }\n    }\n  }\n#endif\n  return MOSQ_ERR_SUCCESS;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":75600
  },
  {
    "code":"static u64 emulator_get_smbase(struct x86_emulate_ctxt *ctxt)\n{\n  struct kvm_vcpu *vcpu = emul_to_vcpu(ctxt);\n  return vcpu->arch.smbase;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":57674
  },
  {
    "code":"  virtual ~RendererMainThread() {\n    Stop();\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":122928
  },
  {
    "code":" void DevToolsAgentHostImpl::DetachSession(DevToolsSession* session) {}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":168910
  },
  {
    "code":"small_smb_init(int smb_command, int wct, struct cifs_tcon *tcon,\n    void **request_buf)\n{\n  int rc;\n  rc = cifs_reconnect_tcon(tcon, smb_command);\n  if (rc)\n    return rc;\n  *request_buf = cifs_small_buf_get();\n  if (*request_buf == NULL) {\n    return -ENOMEM;\n  }\n  header_assemble((struct smb_hdr *) *request_buf, smb_command,\n      tcon, wct);\n  if (tcon != NULL)\n    cifs_stats_inc(&tcon->num_smbs_sent);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":25022
  },
  {
    "code":"static void DestroyCLocale(void)\n{\n  if (c_locale != (locale_t) NULL)\n    freelocale(c_locale);\n  c_locale=(locale_t) NULL;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":90878
  },
  {
    "code":"order_hostkeyalgs(char *host, struct sockaddr *hostaddr, u_short port)\n{\n  char *oavail, *avail, *first, *last, *alg, *hostname, *ret;\n  size_t maxlen;\n  struct hostkeys *hostkeys;\n  int ktype;\n  u_int i;\n  get_hostfile_hostname_ipaddr(host, hostaddr, port, &hostname, NULL);\n  hostkeys = init_hostkeys();\n  for (i = 0; i < options.num_user_hostfiles; i++)\n    load_hostkeys(hostkeys, hostname, options.user_hostfiles[i]);\n  for (i = 0; i < options.num_system_hostfiles; i++)\n    load_hostkeys(hostkeys, hostname, options.system_hostfiles[i]);\n  oavail = avail = xstrdup(KEX_DEFAULT_PK_ALG);\n  maxlen = strlen(avail) + 1;\n  first = xmalloc(maxlen);\n  last = xmalloc(maxlen);\n  *first = *last = '\\0';\n#define ALG_APPEND(to, from) \\\n  do { \\\n    if (*to != '\\0') \\\n      strlcat(to, \",\", maxlen); \\\n    strlcat(to, from, maxlen); \\\n  } while (0)\n  while ((alg = strsep(&avail, \",\")) && *alg != '\\0') {\n    if ((ktype = sshkey_type_from_name(alg)) == KEY_UNSPEC)\n      fatal(\"%s: unknown alg %s\", __func__, alg);\n    if (lookup_key_in_hostkeys_by_type(hostkeys,\n        sshkey_type_plain(ktype), NULL))\n      ALG_APPEND(first, alg);\n    else\n      ALG_APPEND(last, alg);\n  }\n#undef ALG_APPEND\n  xasprintf(&ret, \"%s%s%s\", first,\n      (*first == '\\0' || *last == '\\0') ? \"\" : \",\", last);\n  if (*first != '\\0')\n    debug3(\"%s: prefer hostkeyalgs: %s\", __func__, first);\n  free(first);\n  free(last);\n  free(hostname);\n  free(oavail);\n  free_hostkeys(hostkeys);\n  return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":72255
  },
  {
    "code":"static int xen_netbk_get_extras(struct xenvif *vif,\n        struct xen_netif_extra_info *extras,\n        int work_to_do)\n{\n  struct xen_netif_extra_info extra;\n  RING_IDX cons = vif->tx.req_cons;\n   do {\n     if (unlikely(work_to_do-- <= 0)) {\n      netdev_dbg(vif->dev, \"Missing extra info\\n\");\n       return -EBADR;\n     }\n    memcpy(&extra, RING_GET_REQUEST(&vif->tx, cons),\n           sizeof(extra));\n     if (unlikely(!extra.type ||\n            extra.type >= XEN_NETIF_EXTRA_TYPE_MAX)) {\n       vif->tx.req_cons = ++cons;\n      netdev_dbg(vif->dev,\n            \"Invalid extra type: %d\\n\", extra.type);\n       return -EINVAL;\n     }\n    memcpy(&extras[extra.type - 1], &extra, sizeof(extra));\n    vif->tx.req_cons = ++cons;\n  } while (extra.flags & XEN_NETIF_EXTRA_FLAG_MORE);\n  return work_to_do;\n}\n",
    "vul":1,
    "flaw_line_no":[
      9,
      17
    ],
    "bigvul_id":179346
  },
  {
    "code":"void Document::CheckCompleted() {\n  if (CheckCompletedInternal())\n    frame_->Loader().DidFinishNavigation();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":140975
  },
  {
    "code":"static int mysqlnd_stream_array_to_fd_set(MYSQLND ** conn_array, fd_set * fds, php_socket_t * max_fd TSRMLS_DC)\n{\n  php_socket_t this_fd;\n  php_stream *stream = NULL;\n  int cnt = 0;\n  MYSQLND **p = conn_array;\n  while (*p) {\n    stream = (*p)->data->net->stream;\n    if (stream != NULL && SUCCESS == php_stream_cast(stream, PHP_STREAM_AS_FD_FOR_SELECT | PHP_STREAM_CAST_INTERNAL,\n                    (void*)&this_fd, 1) && this_fd >= 0) {\n      PHP_SAFE_FD_SET(this_fd, fds);\n      if (this_fd > *max_fd) {\n        *max_fd = this_fd;\n      }\n      cnt++;\n    }\n    p++;\n  }\n  return cnt ? 1 : 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":14287
  },
  {
    "code":"void SoftwareFrameManager::DiscardCurrentFrame() {\n  if (!HasCurrentFrame())\n    return;\n  current_frame_ = NULL;\n  RendererFrameManager::GetInstance()->RemoveFrame(this);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":129963
  },
  {
    "code":"bool DevToolsClient::isUnderTest() {\n  return RenderThreadImpl::current()->layout_test_mode();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":152925
  },
  {
    "code":"void LayoutSVGContainer::updateCachedBoundaries()\n{\n    SVGLayoutSupport::computeContainerBoundingBoxes(this, m_objectBoundingBox, m_objectBoundingBoxValid, m_strokeBoundingBox, m_paintInvalidationBoundingBox);\n    SVGLayoutSupport::intersectPaintInvalidationRectWithResources(this, m_paintInvalidationBoundingBox);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":129582
  },
  {
    "code":"void ExtensionService::UnloadExtension(\n    const std::string& extension_id,\n    extension_misc::UnloadedExtensionReason reason) {\n  scoped_refptr<const Extension> extension(\n      GetExtensionByIdInternal(extension_id, true, true, false));\n  if (!extension) {\n    profile_->UnregisterExtensionWithRequestContexts(extension_id, reason);\n    return;\n  }\n  unloaded_extension_paths_[extension->id()] = extension->path();\n  disabled_extension_paths_.erase(extension->id());\n  extension_runtime_data_.erase(extension_id);\n  ExtensionList::iterator iter = std::find(disabled_extensions_.begin(),\n                                           disabled_extensions_.end(),\n                                           extension.get());\n  if (iter != disabled_extensions_.end()) {\n    UnloadedExtensionInfo details(extension, reason);\n    details.already_disabled = true;\n    disabled_extensions_.erase(iter);\n    NotificationService::current()->Notify(\n        chrome::NOTIFICATION_EXTENSION_UNLOADED,\n        Source<Profile>(profile_),\n        Details<UnloadedExtensionInfo>(&details));\n    profile_->UnregisterExtensionWithRequestContexts(extension_id, reason);\n    return;\n  }\n  iter = std::find(extensions_.begin(), extensions_.end(), extension.get());\n  extensions_.erase(iter);\n  NotifyExtensionUnloaded(extension.get(), reason);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":103533
  },
  {
    "code":"HTMLFormElement* FormAssociatedElement::findAssociatedForm(const HTMLElement* element, HTMLFormElement* currentAssociatedForm)\n{\n    const AtomicString& formId(element->fastGetAttribute(formAttr));\n    if (!formId.isNull() && element->inDocument()) {\n        HTMLFormElement* newForm = 0;\n        Element* newFormCandidate = element->treeScope().getElementById(formId);\n        if (newFormCandidate && newFormCandidate->hasTagName(formTag))\n            newForm = toHTMLFormElement(newFormCandidate);\n        return newForm;\n    }\n    if (!currentAssociatedForm)\n        return element->findFormAncestor();\n    return currentAssociatedForm;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":133885
  },
  {
    "code":"static int addbyter(int output, FILE *data)\n{\n  struct nsprintf *infop=(struct nsprintf *)data;\n  unsigned char outc = (unsigned char)output;\n  if(infop->length < infop->max) {\n    infop->buffer[0] = outc; \n    infop->buffer++; \n    infop->length++; \n    return outc;     \n  }\n  return -1;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":86508
  },
  {
    "code":"static void __net_exit unix_net_exit(struct net *net)\n{\n  unix_sysctl_unregister(net);\n  remove_proc_entry(\"unix\", net->proc_net);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":40739
  },
  {
    "code":"void GIFImageReader::addFrameIfNecessary()\n{\n    if (m_frames.isEmpty() || m_frames.last()->isComplete())\n        m_frames.append(adoptPtr(new GIFFrameContext(m_frames.size())));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":140277
  },
  {
    "code":"  void ReceiveDataLow(int size) {\n    EXPECT_TRUE(active_loader());\n    std::unique_ptr<char[]> data(new char[size]);\n    memset(data.get(), 0xA5, size);  \n    data_provider()->DidReceiveData(data.get(), size);\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":157076
  },
  {
    "code":"static CURLcode cmp_peer_pubkey(struct ssl_connect_data *connssl,\n                                const char *pinnedpubkey)\n{\n  CURLcode result = CURLE_SSL_PINNEDPUBKEYNOTMATCH;\n  struct Curl_easy *data = connssl->data;\n  CERTCertificate *cert;\n  if(!pinnedpubkey)\n    return CURLE_OK;\n  cert = SSL_PeerCertificate(connssl->handle);\n  if(cert) {\n    SECKEYPublicKey *pubkey = CERT_ExtractPublicKey(cert);\n    if(pubkey) {\n      SECItem *cert_der = PK11_DEREncodePublicKey(pubkey);\n      if(cert_der) {\n        result = Curl_pin_peer_pubkey(data, pinnedpubkey, cert_der->data,\n                                      cert_der->len);\n        SECITEM_FreeItem(cert_der, PR_TRUE);\n      }\n      SECKEY_DestroyPublicKey(pubkey);\n    }\n    CERT_DestroyCertificate(cert);\n  }\n  switch(result) {\n  case CURLE_OK:\n    infof(data, \"pinned public key verified successfully!\\n\");\n    break;\n  case CURLE_SSL_PINNEDPUBKEYNOTMATCH:\n    failf(data, \"failed to verify pinned public key\");\n    break;\n  default:\n    break;\n  }\n  return result;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":50085
  },
  {
    "code":"ofproto_port_get_bfd_status(struct ofproto *ofproto, ofp_port_t ofp_port,\n                            struct smap *status)\n{\n    struct ofport *ofport = ofproto_get_port(ofproto, ofp_port);\n    return (ofport && ofproto->ofproto_class->get_bfd_status\n            ? ofproto->ofproto_class->get_bfd_status(ofport, status)\n            : EOPNOTSUPP);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":77351
  },
  {
    "code":"static void srpt_mad_send_handler(struct ib_mad_agent *mad_agent,\n          struct ib_mad_send_wc *mad_wc)\n{\n  ib_destroy_ah(mad_wc->send_buf->ah);\n  ib_free_send_mad(mad_wc->send_buf);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":50674
  },
  {
    "code":" virtual status_t listModules(struct sound_trigger_module_descriptor *modules,\n uint32_t *numModules)\n {\n if (numModules == NULL || (*numModules != 0 && modules == NULL)) {\n return BAD_VALUE;\n }\n Parcel data, reply;\n        data.writeInterfaceToken(ISoundTriggerHwService::getInterfaceDescriptor());\n unsigned int numModulesReq = (modules == NULL) ? 0 : *numModules;\n        data.writeInt32(numModulesReq);\n status_t status = remote()->transact(LIST_MODULES, data, &reply);\n if (status == NO_ERROR) {\n            status = (status_t)reply.readInt32();\n *numModules = (unsigned int)reply.readInt32();\n }\n        ALOGV(\"listModules() status %d got *numModules %d\", status, *numModules);\n if (status == NO_ERROR) {\n if (numModulesReq > *numModules) {\n                numModulesReq = *numModules;\n }\n if (numModulesReq > 0) {\n                reply.read(modules, numModulesReq * sizeof(struct sound_trigger_module_descriptor));\n }\n }\n return status;\n }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":175850
  },
  {
    "code":"JSTestActiveDOMObject::JSTestActiveDOMObject(Structure* structure, JSDOMGlobalObject* globalObject, PassRefPtr<TestActiveDOMObject> impl)\n    : JSDOMWrapper(structure, globalObject)\n    , m_impl(impl.leakRef())\n{\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":105928
  },
  {
    "code":"void RenderViewImpl::exitFullscreen() {\n  exitFullScreen();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":116689
  },
  {
    "code":"autofill::RegionDataLoader* PaymentRequestState::GetRegionDataLoader() {\n  return payment_request_delegate_->GetRegionDataLoader();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":163972
  },
  {
    "code":"static int __init crypto_cmac_module_init(void)\n{\n  return crypto_register_template(&crypto_cmac_tmpl);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":45623
  },
  {
    "code":"void V8TestObject::WindowAttributeAttributeSetterCallback(\n    const v8::FunctionCallbackInfo<v8::Value>& info) {\n  RUNTIME_CALL_TIMER_SCOPE_DISABLED_BY_DEFAULT(info.GetIsolate(), \"Blink_TestObject_windowAttribute_Setter\");\n  v8::Local<v8::Value> v8_value = info[0];\n  test_object_v8_internal::WindowAttributeAttributeSetter(v8_value, info);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":148200
  },
  {
    "code":"  cf2_glyphpath_pushPrevElem( CF2_GlyphPath  glyphpath,\n                              CF2_HintMap    hintmap,\n                              FT_Vector*     nextP0,\n                              FT_Vector      nextP1,\n                              FT_Bool        close )\n  {\n    CF2_CallbackParamsRec  params;\n    FT_Vector*  prevP0;\n    FT_Vector*  prevP1;\n    FT_Vector  intersection    = { 0, 0 };\n    FT_Bool    useIntersection = FALSE;\n    FT_ASSERT( glyphpath->prevElemOp == CF2_PathOpLineTo ||\n               glyphpath->prevElemOp == CF2_PathOpCubeTo );\n    if ( glyphpath->prevElemOp == CF2_PathOpLineTo )\n    {\n      prevP0 = &glyphpath->prevElemP0;\n      prevP1 = &glyphpath->prevElemP1;\n    }\n    else\n    {\n      prevP0 = &glyphpath->prevElemP2;\n      prevP1 = &glyphpath->prevElemP3;\n    }\n    if ( prevP1->x != nextP0->x || prevP1->y != nextP0->y )\n    {\n      useIntersection = cf2_glyphpath_computeIntersection( glyphpath,\n                                                           prevP0,\n                                                           prevP1,\n                                                           nextP0,\n                                                           &nextP1,\n                                                           &intersection );\n      if ( useIntersection )\n      {\n        *prevP1 = intersection;\n      }\n    }\n    params.pt0 = glyphpath->currentDS;\n    switch( glyphpath->prevElemOp )\n    {\n    case CF2_PathOpLineTo:\n      params.op = CF2_PathOpLineTo;\n      if ( close )\n      {\n        cf2_glyphpath_hintPoint( glyphpath,\n                                 &glyphpath->firstHintMap,\n                                 &params.pt1,\n                                 glyphpath->prevElemP1.x,\n                                 glyphpath->prevElemP1.y );\n      }\n      else\n      {\n        cf2_glyphpath_hintPoint( glyphpath,\n                                 hintmap,\n                                 &params.pt1,\n                                 glyphpath->prevElemP1.x,\n                                 glyphpath->prevElemP1.y );\n      }\n      if ( params.pt0.x != params.pt1.x || params.pt0.y != params.pt1.y )\n      {\n        glyphpath->callbacks->lineTo( glyphpath->callbacks, &params );\n        glyphpath->currentDS = params.pt1;\n      }\n      break;\n    case CF2_PathOpCubeTo:\n      params.op = CF2_PathOpCubeTo;\n      cf2_glyphpath_hintPoint( glyphpath,\n                               hintmap,\n                               &params.pt1,\n                               glyphpath->prevElemP1.x,\n                               glyphpath->prevElemP1.y );\n      cf2_glyphpath_hintPoint( glyphpath,\n                               hintmap,\n                               &params.pt2,\n                               glyphpath->prevElemP2.x,\n                               glyphpath->prevElemP2.y );\n      cf2_glyphpath_hintPoint( glyphpath,\n                               hintmap,\n                               &params.pt3,\n                               glyphpath->prevElemP3.x,\n                               glyphpath->prevElemP3.y );\n      glyphpath->callbacks->cubeTo( glyphpath->callbacks, &params );\n      glyphpath->currentDS = params.pt3;\n      break;\n    }\n    if ( !useIntersection || close )\n    {\n      if ( close )\n      {\n        cf2_glyphpath_hintPoint( glyphpath,\n                                 &glyphpath->firstHintMap,\n                                 &params.pt1,\n                                 nextP0->x,\n                                 nextP0->y );\n      }\n      else\n      {\n        cf2_glyphpath_hintPoint( glyphpath,\n                                 hintmap,\n                                 &params.pt1,\n                                 nextP0->x,\n                                 nextP0->y );\n      }\n      if ( params.pt1.x != glyphpath->currentDS.x ||\n           params.pt1.y != glyphpath->currentDS.y )\n      {\n        params.op  = CF2_PathOpLineTo;\n        params.pt0 = glyphpath->currentDS;\n        glyphpath->callbacks->lineTo( glyphpath->callbacks, &params );\n        glyphpath->currentDS = params.pt1;\n      }\n    }\n    if ( useIntersection )\n    {\n      *nextP0 = intersection;\n    }\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":7144
  },
  {
    "code":"static int exif_process_undefined(char **result, char *value, size_t byte_count TSRMLS_DC) {\n  if (byte_count) {\n    (*result) = estrndup(value, byte_count); \n    return byte_count+1;\n  }\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":10954
  },
  {
    "code":"RenderViewImpl* RenderViewImpl::Create(\n    int32 opener_id,\n    const RendererPreferences& renderer_prefs,\n    const WebPreferences& webkit_prefs,\n    SharedRenderViewCounter* counter,\n    int32 routing_id,\n    int32 surface_id,\n    int64 session_storage_namespace_id,\n    const string16& frame_name,\n    bool is_renderer_created,\n    bool swapped_out,\n    int32 next_page_id,\n    const WebKit::WebScreenInfo& screen_info,\n    AccessibilityMode accessibility_mode) {\n  DCHECK(routing_id != MSG_ROUTING_NONE);\n  RenderViewImplParams params(\n      opener_id,\n      renderer_prefs,\n      webkit_prefs,\n      counter,\n      routing_id,\n      surface_id,\n      session_storage_namespace_id,\n      frame_name,\n      is_renderer_created,\n      swapped_out,\n      next_page_id,\n      screen_info,\n      accessibility_mode);\n  RenderViewImpl* render_view = NULL;\n  if (g_create_render_view_impl)\n    render_view = g_create_render_view_impl(&params);\n  else\n    render_view = new RenderViewImpl(&params);\n  render_view->Initialize(&params);\n  return render_view;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":123840
  },
  {
    "code":"int nntp_active_fetch(struct NntpServer *nserv, bool new)\n{\n  struct NntpData nntp_data;\n  char msg[STRING];\n  char buf[LONG_STRING];\n  unsigned int i;\n  int rc;\n  snprintf(msg, sizeof(msg), _(\"Loading list of groups from server %s...\"),\n           nserv->conn->account.host);\n  mutt_message(msg);\n  if (nntp_date(nserv, &nserv->newgroups_time) < 0)\n    return -1;\n  nntp_data.nserv = nserv;\n  nntp_data.group = NULL;\n  i = nserv->groups_num;\n  mutt_str_strfcpy(buf, \"LIST\\r\\n\", sizeof(buf));\n  rc = nntp_fetch_lines(&nntp_data, buf, sizeof(buf), msg, nntp_add_group, nserv);\n  if (rc)\n  {\n    if (rc > 0)\n    {\n      mutt_error(\"LIST: %s\", buf);\n    }\n    return -1;\n  }\n  if (new)\n  {\n    for (; i < nserv->groups_num; i++)\n    {\n      struct NntpData *data = nserv->groups_list[i];\n      data->new = true;\n    }\n  }\n  for (i = 0; i < nserv->groups_num; i++)\n  {\n    struct NntpData *data = nserv->groups_list[i];\n    if (data && data->deleted && !data->newsrc_ent)\n    {\n      nntp_delete_group_cache(data);\n      mutt_hash_delete(nserv->groups_hash, data->group, NULL);\n      nserv->groups_list[i] = NULL;\n    }\n  }\n  if (NntpLoadDescription)\n    rc = get_description(&nntp_data, \"*\", _(\"Loading descriptions...\"));\n  nntp_active_save_cache(nserv);\n  if (rc < 0)\n    return -1;\n  mutt_clear_error();\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":79493
  },
  {
    "code":"static void checkMutexEnter(sqlite3_mutex *p){\n  CheckMutex *pCheck = (CheckMutex*)p;\n  if( pCheck->iType==SQLITE_MUTEX_WARNONCONTENTION ){\n    if( SQLITE_OK==pGlobalMutexMethods->xMutexTry(pCheck->mutex) ){\n      return;\n    }\n    sqlite3_log(SQLITE_MISUSE,\n        \"illegal multi-threaded access to database connection\"\n    );\n  }\n  pGlobalMutexMethods->xMutexEnter(pCheck->mutex);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":164518
  },
  {
    "code":"WebRect WebLocalFrameImpl::VisibleContentRect() const {\n  if (LocalFrameView* view = GetFrameView())\n    return view->VisibleContentRect();\n  return WebRect();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":147107
  },
  {
    "code":"void WebPluginImpl::updateGeometry(\n    const WebRect& window_rect, const WebRect& clip_rect,\n    const WebVector<WebRect>& cutout_rects, bool is_visible) {\n  WebPluginGeometry new_geometry;\n  new_geometry.window = window_;\n  new_geometry.window_rect = window_rect;\n  new_geometry.clip_rect = clip_rect;\n  new_geometry.visible = is_visible;\n  new_geometry.rects_valid = true;\n  for (size_t i = 0; i < cutout_rects.size(); ++i)\n    new_geometry.cutout_rects.push_back(cutout_rects[i]);\n  if (window_ &&\n      page_delegate_ &&\n      (first_geometry_update_ || !new_geometry.Equals(geometry_))) {\n    page_delegate_->DidMovePlugin(new_geometry);\n  }\n  if (first_geometry_update_ ||\n      new_geometry.window_rect != geometry_.window_rect ||\n      new_geometry.clip_rect != geometry_.clip_rect) {\n    delegate_->UpdateGeometry(new_geometry.window_rect, new_geometry.clip_rect);\n  }\n  if (first_geometry_update_) {\n    if (!load_manually_ && plugin_url_.is_valid()) {\n      MessageLoop::current()->PostDelayedTask(\n          FROM_HERE, method_factory_.NewRunnableMethod(\n              &WebPluginImpl::OnDownloadPluginSrcUrl), 0);\n    }\n  }\n  first_geometry_update_ = false;\n  geometry_ = new_geometry;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":100029
  },
  {
    "code":"static int uas_try_complete(struct scsi_cmnd *cmnd, const char *caller)\n{\n  struct uas_cmd_info *cmdinfo = (void *)&cmnd->SCp;\n  struct uas_dev_info *devinfo = (void *)cmnd->device->hostdata;\n  lockdep_assert_held(&devinfo->lock);\n  if (cmdinfo->state & (COMMAND_INFLIGHT |\n            DATA_IN_URB_INFLIGHT |\n            DATA_OUT_URB_INFLIGHT |\n            COMMAND_ABORTED))\n    return -EBUSY;\n  devinfo->cmnd[cmdinfo->uas_tag - 1] = NULL;\n  uas_free_unsubmitted_urbs(cmnd);\n  cmnd->scsi_done(cmnd);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":59918
  },
  {
    "code":"ClientHintsPreferences FrameFetchContext::GetClientHintsPreferences() const {\n  if (IsDetached())\n    return frozen_state_->client_hints_preferences;\n  if (!document_)\n    return ClientHintsPreferences();\n  return document_->GetClientHintsPreferences();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":151418
  },
  {
    "code":"views::View* CardUnmaskPromptViews::GetContentsView() {\n  InitIfNecessary();\n  return this;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":118357
  },
  {
    "code":"bool Layer::IsPropertyChangeAllowed() const {\n  if (!layer_tree_host_)\n    return true;\n  if (!layer_tree_host_->settings().strict_layer_property_change_checking)\n    return true;\n  return !layer_tree_host_->in_paint_layer_contents();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":120117
  },
  {
    "code":"void DocumentWriter::end()\n{\n    m_frame->loader()->didEndDocument();\n    endIfNotLoadingMainResource();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":103411
  },
  {
    "code":"    ~BluetoothSocketListenUsingRfcommFunction() {}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":167135
  },
  {
    "code":"static bool mmu_page_zap_pte(struct kvm *kvm, struct kvm_mmu_page *sp,\n           u64 *spte)\n{\n  u64 pte;\n  struct kvm_mmu_page *child;\n  pte = *spte;\n  if (is_shadow_present_pte(pte)) {\n    if (is_last_spte(pte, sp->role.level)) {\n      drop_spte(kvm, spte);\n      if (is_large_pte(pte))\n        --kvm->stat.lpages;\n    } else {\n      child = page_header(pte & PT64_BASE_ADDR_MASK);\n      drop_parent_pte(child, spte);\n    }\n    return true;\n  }\n  if (is_mmio_spte(pte))\n    mmu_spte_clear_no_track(spte);\n  return false;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":37530
  },
  {
    "code":"static int pegasus_probe(struct usb_interface *intf,\n       const struct usb_device_id *id)\n{\n  struct usb_device *dev = interface_to_usbdev(intf);\n  struct net_device *net;\n  pegasus_t *pegasus;\n  int dev_index = id - pegasus_ids;\n  int res = -ENOMEM;\n  if (pegasus_blacklisted(dev))\n    return -ENODEV;\n  if (pegasus_count == 0) {\n    pegasus_workqueue = alloc_workqueue(\"pegasus\", WQ_MEM_RECLAIM,\n                0);\n    if (!pegasus_workqueue)\n      return -ENOMEM;\n  }\n  pegasus_count++;\n  net = alloc_etherdev(sizeof(struct pegasus));\n  if (!net)\n    goto out;\n  pegasus = netdev_priv(net);\n  pegasus->dev_index = dev_index;\n  res = alloc_urbs(pegasus);\n  if (res < 0) {\n    dev_err(&intf->dev, \"can't allocate %s\\n\", \"urbs\");\n    goto out1;\n  }\n  tasklet_init(&pegasus->rx_tl, rx_fixup, (unsigned long) pegasus);\n  INIT_DELAYED_WORK(&pegasus->carrier_check, check_carrier);\n  pegasus->intf = intf;\n  pegasus->usb = dev;\n  pegasus->net = net;\n  net->watchdog_timeo = PEGASUS_TX_TIMEOUT;\n  net->netdev_ops = &pegasus_netdev_ops;\n  net->ethtool_ops = &ops;\n  pegasus->mii.dev = net;\n  pegasus->mii.mdio_read = mdio_read;\n  pegasus->mii.mdio_write = mdio_write;\n  pegasus->mii.phy_id_mask = 0x1f;\n  pegasus->mii.reg_num_mask = 0x1f;\n  pegasus->msg_enable = netif_msg_init(msg_level, NETIF_MSG_DRV\n        | NETIF_MSG_PROBE | NETIF_MSG_LINK);\n  pegasus->features = usb_dev_id[dev_index].private;\n  get_interrupt_interval(pegasus);\n  if (reset_mac(pegasus)) {\n    dev_err(&intf->dev, \"can't reset MAC\\n\");\n    res = -EIO;\n    goto out2;\n  }\n  set_ethernet_addr(pegasus);\n  if (pegasus->features & PEGASUS_II) {\n    dev_info(&intf->dev, \"setup Pegasus II specific registers\\n\");\n    setup_pegasus_II(pegasus);\n  }\n  pegasus->phy = mii_phy_probe(pegasus);\n  if (pegasus->phy == 0xff) {\n    dev_warn(&intf->dev, \"can't locate MII phy, using default\\n\");\n    pegasus->phy = 1;\n  }\n  pegasus->mii.phy_id = pegasus->phy;\n  usb_set_intfdata(intf, pegasus);\n  SET_NETDEV_DEV(net, &intf->dev);\n  pegasus_reset_wol(net);\n  res = register_netdev(net);\n  if (res)\n    goto out3;\n  queue_delayed_work(pegasus_workqueue, &pegasus->carrier_check,\n         CARRIER_CHECK_DELAY);\n  dev_info(&intf->dev, \"%s, %s, %pM\\n\", net->name,\n     usb_dev_id[dev_index].name, net->dev_addr);\n  return 0;\nout3:\n  usb_set_intfdata(intf, NULL);\nout2:\n  free_all_urbs(pegasus);\nout1:\n  free_netdev(net);\nout:\n  pegasus_dec_workqueue();\n  return res;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":66549
  },
  {
    "code":"void PermissionsData::SetPolicyHostRestrictions(\n    const URLPatternSet& policy_blocked_hosts,\n    const URLPatternSet& policy_allowed_hosts) const {\n  AutoLockOnValidThread lock(runtime_lock_, thread_checker_.get());\n  policy_blocked_hosts_unsafe_ = policy_blocked_hosts.Clone();\n  policy_allowed_hosts_unsafe_ = policy_allowed_hosts.Clone();\n  uses_default_policy_host_restrictions = false;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":166495
  },
  {
    "code":"void TestingAutomationProvider::RestoreAllNTPMostVisitedThumbnails(\n    Browser* browser,\n    DictionaryValue* args,\n    IPC::Message* reply_message) {\n  AutomationJSONReply reply(this, reply_message);\n  history::TopSites* top_sites = browser->profile()->GetTopSites();\n  if (!top_sites) {\n    reply.SendError(\"TopSites service is not initialized.\");\n    return;\n  }\n  top_sites->ClearBlacklistedURLs();\n  reply.SendSuccess(NULL);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":115013
  },
  {
    "code":"static struct node *lookup_child_by_name_locked(struct node *node, const char *name)\n{\n for (node = node->child; node; node = node->next) {\n if (!strcmp(name, node->name) && !node->deleted) {\n return node;\n }\n }\n return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":173758
  },
  {
    "code":"static const char *WindowsErrorStr(DWORD dwMessageId)\n{\n  static LPSTR msg = NULL;\n  if (msg)\n    LocalFree(msg);\n  if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM, 0, dwMessageId, 0, (LPSTR)&msg, 0, 0))\n    return msg;\n  static const char fmt[] = \"Error #%ld\";\n  signed long ldMsgId = dwMessageId;\n  int sz = snprintf((char*)&sz, 0, fmt, ldMsgId) + 1;\n  msg = (LPTSTR)LocalAlloc(LMEM_FIXED, sz);\n  sprintf((char*)msg, fmt, ldMsgId);\n  return msg;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":94543
  },
  {
    "code":"void CLASS linear_table (unsigned len)\n{\n  int i;\n  if (len > 0x1000) len = 0x1000;\n  read_shorts (curve, len);\n  for (i=len; i < 0x1000; i++)\n    curve[i] = curve[i-1];\n  maximum = curve[0xfff];\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":43309
  },
  {
    "code":"dict_param_write(iparam_list * plist, const ref * pkey, const ref * pvalue)\n{\n    int code =\n        dict_put(&((dict_param_list *) plist)->dict, pkey, pvalue, NULL);\n    return min(code, 0);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":3259
  },
  {
    "code":"static int r_bin_dwarf_init_debug_abbrev(RBinDwarfDebugAbbrev *da) {\n  if (!da) {\n    return -EINVAL;\n  }\n  da->decls = calloc (sizeof (RBinDwarfAbbrevDecl), DEBUG_ABBREV_CAP);\n  if (!da->decls) {\n    return -ENOMEM;\n  }\n  da->capacity = DEBUG_ABBREV_CAP;\n  da->length = 0;\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":59703
  },
  {
    "code":"MODRET auth_pre_retr(cmd_rec *cmd) {\n  const char *path;\n  pr_fs_t *curr_fs = NULL;\n  struct stat st;\n  if (session.anon_config == NULL) {\n    return PR_DECLINED(cmd);\n  }\n  if (auth_anon_allow_robots == TRUE) {\n    return PR_DECLINED(cmd);\n  }\n  auth_anon_allow_robots_enabled = FALSE;\n  path = dir_canonical_path(cmd->tmp_pool, cmd->arg);\n  if (strcasecmp(path, \"\/robots.txt\") != 0) {\n    return PR_DECLINED(cmd);\n  }\n  if (session.restart_pos > 0) {\n    pr_log_debug(DEBUG10, \"'AnonAllowRobots off' in effect, but cannot \"\n      \"support resumed download (REST %\" PR_LU \" previously sent by client)\",\n      (pr_off_t) session.restart_pos);\n    return PR_DECLINED(cmd);\n  }\n  pr_fs_clear_cache2(path);\n  if (pr_fsio_lstat(path, &st) == 0) {\n    pr_log_debug(DEBUG10, \"'AnonAllowRobots off' in effect, but have \"\n      \"real 'robots.txt' file on disk; using that\");\n    return PR_DECLINED(cmd);\n  }\n  curr_fs = pr_get_fs(path, NULL);\n  if (curr_fs != NULL) {\n    pr_fs_t *robots_fs;\n    robots_fs = pr_register_fs(cmd->pool, \"robots\", path);\n    if (robots_fs == NULL) {\n      pr_log_debug(DEBUG8, \"'AnonAllowRobots off' in effect, but failed to \"\n        \"register FS: %s\", strerror(errno));\n      return PR_DECLINED(cmd);\n    }\n    robots_fs->stat = robots_fsio_stat;\n    robots_fs->fstat = robots_fsio_fstat;\n    robots_fs->lstat = robots_fsio_lstat;\n    robots_fs->unlink = robots_fsio_unlink;\n    robots_fs->open = robots_fsio_open;\n    robots_fs->close = robots_fsio_close;\n    robots_fs->read = robots_fsio_read;\n    robots_fs->write = robots_fsio_write;\n    robots_fs->access = robots_fsio_access;\n    robots_fs->faccess = robots_fsio_faccess;\n    robots_fs->rename = curr_fs->rename;\n    robots_fs->lseek = curr_fs->lseek;\n    robots_fs->link = curr_fs->link;\n    robots_fs->readlink = curr_fs->readlink;\n    robots_fs->symlink = curr_fs->symlink;\n    robots_fs->ftruncate = curr_fs->ftruncate;\n    robots_fs->truncate = curr_fs->truncate;\n    robots_fs->chmod = curr_fs->chmod;\n    robots_fs->fchmod = curr_fs->fchmod;\n    robots_fs->chown = curr_fs->chown;\n    robots_fs->fchown = curr_fs->fchown;\n    robots_fs->lchown = curr_fs->lchown;\n    robots_fs->utimes = curr_fs->utimes;\n    robots_fs->futimes = curr_fs->futimes;\n    robots_fs->fsync = curr_fs->fsync;\n    pr_fs_clear_cache2(path);\n    auth_anon_allow_robots_enabled = TRUE;\n  }\n  return PR_DECLINED(cmd);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":67577
  },
  {
    "code":"DocumentWriter::DocumentWriter(Frame* frame)\n    : m_frame(frame)\n    , m_hasReceivedSomeData(false)\n    , m_encodingWasChosenByUser(false)\n{\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":103402
  },
  {
    "code":"xsltRegisterExtModuleTopLevel(const xmlChar * name, const xmlChar * URI,\n                              xsltTopLevelFunction function)\n{\n    if ((name == NULL) || (URI == NULL) || (function == NULL))\n        return (-1);\n    if (xsltTopLevelsHash == NULL)\n        xsltTopLevelsHash = xmlHashCreate(10);\n    if (xsltTopLevelsHash == NULL)\n        return (-1);\n    xmlMutexLock(xsltExtMutex);\n    xmlHashUpdateEntry2(xsltTopLevelsHash, name, URI,\n                        XML_CAST_FPTR(function), NULL);\n    xmlMutexUnlock(xsltExtMutex);\n    return (0);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":169881
  },
  {
    "code":"transform_rowsize(png_const_structp pp, png_byte colour_type,\n   png_byte bit_depth)\n{\n return (TRANSFORM_WIDTH * bit_size(pp, colour_type, bit_depth)) \/ 8;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":173257
  },
  {
    "code":"Win32ErrorHandler(const char* module, const char* fmt, va_list ap)\n{\n#ifndef TIF_PLATFORM_CONSOLE\n  LPTSTR szTitle;\n  LPTSTR szTmp;\n  LPCTSTR szTitleText = \"%s Error\";\n  LPCTSTR szDefaultModule = \"LIBTIFF\";\n  LPCTSTR szTmpModule = (module == NULL) ? szDefaultModule : module;\n        SIZE_T nBufSize = (strlen(szTmpModule) +\n                        strlen(szTitleText) + strlen(fmt) + 256)*sizeof(char);\n  if ((szTitle = (LPTSTR)LocalAlloc(LMEM_FIXED, nBufSize)) == NULL)\n    return;\n  sprintf(szTitle, szTitleText, szTmpModule);\n  szTmp = szTitle + (strlen(szTitle)+2)*sizeof(char);\n  vsnprintf(szTmp, nBufSize-(strlen(szTitle)+2)*sizeof(char), fmt, ap);\n  MessageBoxA(GetFocus(), szTmp, szTitle, MB_OK | MB_ICONEXCLAMATION);\n  LocalFree(szTitle);\n  return;\n#else\n  if (module != NULL)\n    fprintf(stderr, \"%s: \", module);\n  vfprintf(stderr, fmt, ap);\n  fprintf(stderr, \".\\n\");\n#endif        \n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":86804
  },
  {
    "code":"void ResourceFetcher::ClearPreloads(ClearPreloadsPolicy policy) {\n  LogPreloadStats(policy);\n  Vector<PreloadKey> keys_to_be_removed;\n  for (const auto& pair : preloads_) {\n    Resource* resource = pair.value;\n    if (policy == kClearAllPreloads || !resource->IsLinkPreload()) {\n      GetMemoryCache()->Remove(resource);\n      keys_to_be_removed.push_back(pair.key);\n    }\n  }\n  preloads_.RemoveAll(keys_to_be_removed);\n  matched_preloads_.clear();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":151548
  },
  {
    "code":" ExtensionsGuestViewMessageFilter::~ExtensionsGuestViewMessageFilter() {\n   DCHECK_CURRENTLY_ON(BrowserThread::IO);\n  (*GetProcessIdToFilterMap())[render_process_id_] = nullptr;\n  base::PostTaskWithTraits(\n      FROM_HERE, BrowserThread::UI,\n      base::BindOnce(RemoveProcessIdFromGlobalMap, render_process_id_));\n }\n",
    "vul":1,
    "flaw_line_no":[
      3,
      4,
      5,
      6
    ],
    "bigvul_id":187031
  },
  {
    "code":"xfs_da_grow_inode(\n  struct xfs_da_args  *args,\n  xfs_dablk_t    *new_blkno)\n{\n  xfs_fileoff_t    bno;\n  int      count;\n  int      error;\n  trace_xfs_da_grow_inode(args);\n  if (args->whichfork == XFS_DATA_FORK) {\n    bno = args->dp->i_mount->m_dirleafblk;\n    count = args->dp->i_mount->m_dirblkfsbs;\n  } else {\n    bno = 0;\n    count = 1;\n  }\n  error = xfs_da_grow_inode_int(args, &bno, count);\n  if (!error)\n    *new_blkno = (xfs_dablk_t)bno;\n  return error;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":35956
  },
  {
    "code":"UseNewLEDField(enum led_field field, LedInfo *old, LedInfo *new,\n               bool report, enum led_field *collide)\n{\n    if (!(old->defined & field))\n        return true;\n    if (new->defined & field) {\n        if (report)\n            *collide |= field;\n        if (new->merge != MERGE_AUGMENT)\n            return true;\n    }\n    return false;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":78939
  },
  {
    "code":"int bio_iov_iter_get_pages(struct bio *bio, struct iov_iter *iter)\n{\n  unsigned short nr_pages = bio->bi_max_vecs - bio->bi_vcnt;\n  struct bio_vec *bv = bio->bi_io_vec + bio->bi_vcnt;\n  struct page **pages = (struct page **)bv;\n  size_t offset, diff;\n  ssize_t size;\n  size = iov_iter_get_pages(iter, pages, LONG_MAX, nr_pages, &offset);\n  if (unlikely(size <= 0))\n    return size ? size : -EFAULT;\n  nr_pages = (size + offset + PAGE_SIZE - 1) \/ PAGE_SIZE;\n  bio->bi_iter.bi_size += size;\n  bio->bi_vcnt += nr_pages;\n  diff = (nr_pages * PAGE_SIZE - offset) - size;\n  while (nr_pages--) {\n    bv[nr_pages].bv_page = pages[nr_pages];\n    bv[nr_pages].bv_len = PAGE_SIZE;\n    bv[nr_pages].bv_offset = 0;\n  }\n  bv[0].bv_offset += offset;\n  bv[0].bv_len -= offset;\n  if (diff)\n    bv[bio->bi_vcnt - 1].bv_len -= diff;\n  iov_iter_advance(iter, size);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":62834
  },
  {
    "code":"static ssize_t show_tabletDiagnosticMessage(struct device *dev, struct device_attribute *attr, char *buf)\n{\n  struct aiptek *aiptek = dev_get_drvdata(dev);\n  char *retMsg;\n  switch (aiptek->diagnostic) {\n  case AIPTEK_DIAGNOSTIC_NA:\n    retMsg = \"no errors\\n\";\n    break;\n  case AIPTEK_DIAGNOSTIC_SENDING_RELATIVE_IN_ABSOLUTE:\n    retMsg = \"Error: receiving relative reports\\n\";\n    break;\n  case AIPTEK_DIAGNOSTIC_SENDING_ABSOLUTE_IN_RELATIVE:\n    retMsg = \"Error: receiving absolute reports\\n\";\n    break;\n  case AIPTEK_DIAGNOSTIC_TOOL_DISALLOWED:\n    if (aiptek->curSetting.pointerMode ==\n        AIPTEK_POINTER_ONLY_MOUSE_MODE) {\n      retMsg = \"Error: receiving stylus reports\\n\";\n    } else {\n      retMsg = \"Error: receiving mouse reports\\n\";\n    }\n    break;\n  default:\n    return 0;\n  }\n  return snprintf(buf, PAGE_SIZE, retMsg);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":57631
  },
  {
    "code":"void PrintWebViewHelper::Print(WebKit::WebFrame* frame,\n                               const WebKit::WebNode& node) {\n  if (print_web_view_)\n    return;\n  scoped_ptr<PrepareFrameAndViewForPrint> prepare;\n  if (!InitPrintSettingsAndPrepareFrame(frame, node, &prepare)) {\n    DidFinishPrinting(FAIL_PRINT);\n    return;  \n  }\n  int expected_page_count = 0;\n  bool use_browser_overlays = true;\n  expected_page_count = prepare->GetExpectedPageCount();\n  if (expected_page_count)\n    use_browser_overlays = prepare->ShouldUseBrowserOverlays();\n  prepare.reset();\n  if (!expected_page_count) {\n    DidFinishPrinting(OK);  \n    return;\n  }\n  if (!GetPrintSettingsFromUser(frame, node, expected_page_count,\n                                use_browser_overlays)) {\n    DidFinishPrinting(OK);  \n    return;\n  }\n  if (!RenderPagesForPrint(frame, node, NULL)) {\n    LOG(ERROR) << \"RenderPagesForPrint failed\";\n    DidFinishPrinting(FAIL_PRINT);\n  }\n  ResetScriptedPrintCount();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":101523
  },
  {
    "code":"gio_poll_dispatch_mod(enum qb_loop_priority p, int32_t fd, int32_t evts,\n                  void *data, qb_ipcs_dispatch_fn_t fn)\n{\n    return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":33905
  },
  {
    "code":"void RenderView::queryAutofillSuggestions(const WebNode& node,\n                                          const WebString& name,\n                                          const WebString& value) {\n  autofill_helper_.QueryAutocompleteSuggestions(node, name, value);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":98118
  },
  {
    "code":"VOID VolumeThreadProc (PVOID Context)\n{\n  PTHREAD_BLOCK pThreadBlock = (PTHREAD_BLOCK) Context;\n  PDEVICE_OBJECT DeviceObject = pThreadBlock->DeviceObject;\n  PEXTENSION Extension = (PEXTENSION) DeviceObject->DeviceExtension;\n  BOOL bDevice;\n  KeSetPriorityThread (KeGetCurrentThread (), LOW_REALTIME_PRIORITY);\n  Dump (\"Mount THREAD OPENING VOLUME BEGIN\\n\");\n  if ( !IsDeviceName (pThreadBlock->mount->wszVolume))\n  {\n    RtlStringCbCopyW (pThreadBlock->wszMountVolume, sizeof(pThreadBlock->wszMountVolume),WIDE (\"\\\\??\\\\\"));\n    RtlStringCbCatW (pThreadBlock->wszMountVolume, sizeof(pThreadBlock->wszMountVolume),pThreadBlock->mount->wszVolume);\n    bDevice = FALSE;\n  }\n  else\n  {\n    pThreadBlock->wszMountVolume[0] = 0;\n    RtlStringCbCatW (pThreadBlock->wszMountVolume, sizeof(pThreadBlock->wszMountVolume),pThreadBlock->mount->wszVolume);\n    bDevice = TRUE;\n  }\n  Dump (\"Mount THREAD request for File %ls DriveNumber %d Device = %d\\n\",\n        pThreadBlock->wszMountVolume, pThreadBlock->mount->nDosDriveNo, bDevice);\n  pThreadBlock->ntCreateStatus = TCOpenVolume (DeviceObject,\n    Extension,\n    pThreadBlock->mount,\n    pThreadBlock->wszMountVolume,\n    bDevice);\n  if (!NT_SUCCESS (pThreadBlock->ntCreateStatus) || pThreadBlock->mount->nReturnCode != 0)\n  {\n    KeSetEvent (&Extension->keCreateEvent, 0, FALSE);\n    PsTerminateSystemThread (STATUS_SUCCESS);\n  }\n  Extension->Queue.IsFilterDevice = FALSE;\n  Extension->Queue.DeviceObject = DeviceObject;\n  Extension->Queue.CryptoInfo = Extension->cryptoInfo;\n  Extension->Queue.HostFileHandle = Extension->hDeviceFile;\n  Extension->Queue.VirtualDeviceLength = Extension->DiskLength;\n  Extension->Queue.MaxReadAheadOffset.QuadPart = Extension->HostLength;\n  if (Extension->SecurityClientContextValid)\n    Extension->Queue.SecurityClientContext = &Extension->SecurityClientContext;\n  else\n    Extension->Queue.SecurityClientContext = NULL;\n  pThreadBlock->ntCreateStatus = EncryptedIoQueueStart (&Extension->Queue);\n  if (!NT_SUCCESS (pThreadBlock->ntCreateStatus))\n  {\n    TCCloseVolume (DeviceObject, Extension);\n    pThreadBlock->mount->nReturnCode = ERR_OS_ERROR;\n    KeSetEvent (&Extension->keCreateEvent, 0, FALSE);\n    PsTerminateSystemThread (STATUS_SUCCESS);\n  }\n  KeSetEvent (&Extension->keCreateEvent, 0, FALSE);\n  pThreadBlock = NULL;\n  for (;;)\n  {\n    KeWaitForSingleObject ((PVOID) & Extension->RequestSemaphore, Executive, KernelMode, FALSE, NULL);\n    for (;;)\n    {\n      PIO_STACK_LOCATION irpSp;\n      PLIST_ENTRY request;\n      PIRP irp;\n      request = ExInterlockedRemoveHeadList (&Extension->ListEntry, &Extension->ListSpinLock);\n      if (request == NULL)\n        break;\n      irp = CONTAINING_RECORD (request, IRP, Tail.Overlay.ListEntry);\n      irpSp = IoGetCurrentIrpStackLocation (irp);\n      ASSERT (irpSp->MajorFunction == IRP_MJ_DEVICE_CONTROL);\n      ProcessVolumeDeviceControlIrp (DeviceObject, Extension, irp);\n      IoReleaseRemoveLock (&Extension->Queue.RemoveLock, irp);\n    }\n    if (Extension->bThreadShouldQuit)\n    {\n      Dump (\"Closing volume\\n\");\n      EncryptedIoQueueStop (&Extension->Queue);\n      TCCloseVolume (DeviceObject, Extension);\n      PsTerminateSystemThread (STATUS_SUCCESS);\n    }\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":87228
  },
  {
    "code":"static void bte_av_callback(tBTA_AV_EVT event, tBTA_AV* p_data) {\n  btif_transfer_context(btif_av_handle_event, event, (char*)p_data,\n sizeof(tBTA_AV), btif_av_event_deep_copy);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":176384
  },
  {
    "code":"bool GLES2DecoderImpl::BoundFramebufferHasStencilAttachment() {\n  FramebufferManager::FramebufferInfo* framebuffer =\n      GetFramebufferInfoForTarget(GL_DRAW_FRAMEBUFFER_EXT);\n  if (framebuffer) {\n    return framebuffer->HasStencilAttachment();\n  }\n  if (offscreen_target_frame_buffer_.get()) {\n    return offscreen_target_stencil_format_ != 0 ||\n           offscreen_target_depth_format_ == GL_DEPTH24_STENCIL8;\n  }\n  return back_buffer_has_stencil_;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":110431
  },
  {
    "code":"void ResetScreenHandler::Hide() {\n  DBusThreadManager::Get()->GetUpdateEngineClient()->RemoveObserver(this);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":119710
  },
  {
    "code":"static int jpc_calcssmant(jpc_fix_t stepsize)\n{\n  int n;\n  int e;\n  int m;\n  n = jpc_firstone(stepsize);\n  e = n - JPC_FIX_FRACBITS;\n  if (n >= 11) {\n    m = (stepsize >> (n - 11)) & 0x7ff;\n  } else {\n    m = (stepsize & ((1 << n) - 1)) << (11 - n);\n  }\n  return m;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":72915
  },
  {
    "code":"cancel_file_info_for_file (NautilusDirectory *directory,\n                           NautilusFile      *file)\n{\n    if (directory->details->get_info_file == file)\n    {\n        file_info_cancel (directory);\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":60860
  },
  {
    "code":"int FLTLayerApplyPlainFilterToLayer(FilterEncodingNode *psNode, mapObj *map,\n                                    int iLayerIndex)\n{\n  char *pszExpression  =NULL;\n  int status =MS_FALSE;\n  layerObj* lp = GET_LAYER(map, iLayerIndex);\n  pszExpression = FLTGetCommonExpression(psNode,  lp);\n  if (pszExpression) {\n    const char* pszUseDefaultExtent;\n    FilterEncodingNode* psTopBBOX;\n    rectObj rect = map->extent;\n    pszUseDefaultExtent = msOWSLookupMetadata(&(lp->metadata), \"F\",\n                                              \"use_default_extent_for_getfeature\");\n    if( pszUseDefaultExtent && !CSLTestBoolean(pszUseDefaultExtent) &&\n        lp->connectiontype == MS_OGR )\n    {\n        const rectObj rectInvalid = MS_INIT_INVALID_RECT;\n        rect = rectInvalid;\n    }\n    psTopBBOX = FLTGetTopBBOX(psNode);\n    if( psTopBBOX )\n    {\n      int can_remove_expression = MS_TRUE;\n      const char* pszEPSG = FLTGetBBOX(psNode, &rect);\n      if(pszEPSG && map->projection.numargs > 0) {\n        projectionObj sProjTmp;\n        msInitProjection(&sProjTmp);\n        if (msLoadProjectionString(&sProjTmp, pszEPSG) == 0) {\n          rectObj oldRect = rect;\n          msProjectRect(&sProjTmp, &map->projection, &rect);\n          if( rect.minx != oldRect.minx ||\n              rect.miny != oldRect.miny ||\n              rect.maxx != oldRect.maxx ||\n              rect.maxy != oldRect.maxy )\n          {\n            can_remove_expression = MS_FALSE;\n          }\n        }\n        msFreeProjection(&sProjTmp);\n      }\n      if( psTopBBOX == psNode && can_remove_expression )\n      {\n        msFree(pszExpression);\n        pszExpression = NULL;\n      }\n    }\n    if(map->debug == MS_DEBUGLEVEL_VVV)\n    {\n      if( pszExpression )\n        msDebug(\"FLTLayerApplyPlainFilterToLayer(): %s, rect=%.15g,%.15g,%.15g,%.15g\\n\", pszExpression, rect.minx, rect.miny, rect.maxx, rect.maxy);\n      else\n        msDebug(\"FLTLayerApplyPlainFilterToLayer(): rect=%.15g,%.15g,%.15g,%.15g\\n\", rect.minx, rect.miny, rect.maxx, rect.maxy);\n    }\n    status = FLTApplyFilterToLayerCommonExpressionWithRect(map, iLayerIndex,\n                                                           pszExpression, rect);\n    msFree(pszExpression);\n  }\n  return status;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":69013
  },
  {
    "code":"void MarkingVisitor::RegisterBackingStoreCallback(void* backing_store,\n                                                  MovingObjectCallback callback,\n                                                  void* callback_data) {\n  if (marking_mode_ != kGlobalMarkingWithCompaction)\n    return;\n  Heap().RegisterMovingObjectCallback(\n      reinterpret_cast<MovableReference>(backing_store), callback,\n      callback_data);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":166864
  },
  {
    "code":"void TracingControllerImpl::ConnectToServiceIfNeeded() {\n  if (!coordinator_) {\n    ServiceManagerConnection::GetForProcess()->GetConnector()->BindInterface(\n        tracing::mojom::kServiceName, &coordinator_);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":141549
  },
  {
    "code":"midi_synth_send_sysex(int dev, unsigned char *bytes, int len)\n{\n  int             orig_dev = synth_devs[dev]->midi_dev;\n  int             i;\n  for (i = 0; i < len; i++)\n    {\n      switch (bytes[i])\n        {\n        case 0xf0:  \n          if (!prefix_cmd(orig_dev, 0xf0))\n            return 0;\n          sysex_state[dev] = 1;\n          break;\n        case 0xf7:  \n          if (!sysex_state[dev])  \n            return 0;\n          sysex_state[dev] = 0;\n          break;\n        default:\n          if (!sysex_state[dev])\n            return 0;\n          if (bytes[i] & 0x80)  \n            {\n              bytes[i] = 0xf7;  \n              sysex_state[dev] = 0;\n            }\n        }\n      if (!midi_devs[orig_dev]->outputc(orig_dev, bytes[i]))\n        {\n          int             timeout = 0;\n          bytes[i] = 0xf7;\n          sysex_state[dev] = 0;\n          while (!midi_devs[orig_dev]->outputc(orig_dev, bytes[i]) &&\n           timeout < 1000)\n            timeout++;\n        }\n      if (!sysex_state[dev])\n        return 0;\n    }\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":27590
  },
  {
    "code":"void __ext4_std_error(struct super_block *sb, const char *function,\n          unsigned int line, int errno)\n{\n  char nbuf[16];\n  const char *errstr;\n  if (errno == -EROFS && journal_current_handle() == NULL &&\n      (sb->s_flags & MS_RDONLY))\n    return;\n  errstr = ext4_decode_error(sb, errno, nbuf);\n  printk(KERN_CRIT \"EXT4-fs error (device %s) in %s:%d: %s\\n\",\n         sb->s_id, function, line, errstr);\n  save_error_info(sb, function, line);\n  ext4_handle_error(sb);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":20427
  },
  {
    "code":" void PlatformSensorProviderAndroid::CreateSensorInternal(\n     mojom::SensorType type,\n    mojo::ScopedSharedBufferMapping mapping,\n     const CreateSensorCallback& callback) {\n   JNIEnv* env = AttachCurrentThread();\n   switch (type) {\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_EULER_ANGLES:\n      CreateAbsoluteOrientationEulerAnglesSensor(env, std::move(mapping),\n                                                 callback);\n       break;\n     case mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION:\n      CreateAbsoluteOrientationQuaternionSensor(env, std::move(mapping),\n                                                callback);\n       break;\n     case mojom::SensorType::RELATIVE_ORIENTATION_EULER_ANGLES:\n      CreateRelativeOrientationEulerAnglesSensor(env, std::move(mapping),\n                                                 callback);\n       break;\n     default: {\n       ScopedJavaLocalRef<jobject> sensor =\n          Java_PlatformSensorProvider_createSensor(env, j_object_,\n                                                   static_cast<jint>(type));\n      if (!sensor.obj()) {\n        callback.Run(nullptr);\n        return;\n       }\n       auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(\n          type, std::move(mapping), this, sensor);\n       callback.Run(concrete_sensor);\n       break;\n     }\n  }\n}\n",
    "vul":1,
    "flaw_line_no":[
      3,
      8,
      9,
      12,
      13,
      16,
      17,
      27,
      28,
      29
    ],
    "bigvul_id":186814
  },
  {
    "code":"nlmclnt_call(struct rpc_cred *cred, struct nlm_rqst *req, u32 proc)\n{\n  struct nlm_host  *host = req->a_host;\n  struct rpc_clnt  *clnt;\n  struct nlm_args  *argp = &req->a_args;\n  struct nlm_res  *resp = &req->a_res;\n  struct rpc_message msg = {\n    .rpc_argp  = argp,\n    .rpc_resp  = resp,\n    .rpc_cred  = cred,\n  };\n  int    status;\n  dprintk(\"lockd: call procedure %d on %s\\n\",\n      (int)proc, host->h_name);\n  do {\n    if (host->h_reclaiming && !argp->reclaim)\n      goto in_grace_period;\n    if ((clnt = nlm_bind_host(host)) == NULL)\n      return -ENOLCK;\n    msg.rpc_proc = &clnt->cl_procinfo[proc];\n    if ((status = rpc_call_sync(clnt, &msg, 0)) < 0) {\n      dprintk(\"lockd: rpc_call returned error %d\\n\", -status);\n      switch (status) {\n      case -EPROTONOSUPPORT:\n        status = -EINVAL;\n        break;\n      case -ECONNREFUSED:\n      case -ETIMEDOUT:\n      case -ENOTCONN:\n        nlm_rebind_host(host);\n        status = -EAGAIN;\n        break;\n      case -ERESTARTSYS:\n        return signalled () ? -EINTR : status;\n      default:\n        break;\n      }\n      break;\n    } else\n    if (resp->status == nlm_lck_denied_grace_period) {\n      dprintk(\"lockd: server in grace period\\n\");\n      if (argp->reclaim) {\n        printk(KERN_WARNING\n             \"lockd: spurious grace period reject?!\\n\");\n        return -ENOLCK;\n      }\n    } else {\n      if (!argp->reclaim) {\n        wake_up_all(&host->h_gracewait);\n      }\n      dprintk(\"lockd: server returns status %d\\n\", resp->status);\n      return 0;  \n    }\nin_grace_period:\n    status = nlm_wait_on_grace(&host->h_gracewait);\n  } while (status == 0);\n  return status;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":34862
  },
  {
    "code":"void GpuProcessHost::LoadedShader(int32_t client_id,\n                                  const std::string& key,\n                                  const std::string& data) {\n  std::string prefix = GetShaderPrefixKey();\n  bool prefix_ok = !key.compare(0, prefix.length(), prefix);\n  UMA_HISTOGRAM_BOOLEAN(\"GPU.ShaderLoadPrefixOK\", prefix_ok);\n  if (prefix_ok) {\n    std::string key_no_prefix = key.substr(prefix.length() + 1);\n    gpu_service_ptr_->LoadedShader(client_id, key_no_prefix, data);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":145166
  },
  {
    "code":"int wc_ecc_export_x963(ecc_key* key, byte* out, word32* outLen)\n{\n   int    ret = MP_OKAY;\n   word32 numlen;\n#ifdef WOLFSSL_SMALL_STACK\n   byte*  buf;\n#else\n   byte   buf[ECC_BUFSIZE];\n#endif\n   word32 pubxlen, pubylen;\n   if (key != NULL && out == NULL && outLen != NULL) {\n      numlen = key->dp->size;\n      *outLen = 1 + 2*numlen;\n      return LENGTH_ONLY_E;\n   }\n   if (key == NULL || out == NULL || outLen == NULL)\n      return ECC_BAD_ARG_E;\n   if (key->type == ECC_PRIVATEKEY_ONLY)\n       return ECC_PRIVATEONLY_E;\n   if (wc_ecc_is_valid_idx(key->idx) == 0) {\n      return ECC_BAD_ARG_E;\n   }\n   numlen = key->dp->size;\n   if (*outLen < (1 + 2*numlen)) {\n      *outLen = 1 + 2*numlen;\n      return BUFFER_E;\n   }\n   pubxlen = mp_unsigned_bin_size(key->pubkey.x);\n   pubylen = mp_unsigned_bin_size(key->pubkey.y);\n   if ((pubxlen > numlen) || (pubylen > numlen)) {\n      WOLFSSL_MSG(\"Public key x\/y invalid!\");\n      return BUFFER_E;\n   }\n   out[0] = ECC_POINT_UNCOMP;\n#ifdef WOLFSSL_SMALL_STACK\n   buf = (byte*)XMALLOC(ECC_BUFSIZE, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n   if (buf == NULL)\n      return MEMORY_E;\n#endif\n   XMEMSET(buf, 0, ECC_BUFSIZE);\n   ret = mp_to_unsigned_bin(key->pubkey.x, buf + (numlen - pubxlen));\n   if (ret != MP_OKAY)\n      goto done;\n   XMEMCPY(out+1, buf, numlen);\n   XMEMSET(buf, 0, ECC_BUFSIZE);\n   ret = mp_to_unsigned_bin(key->pubkey.y, buf + (numlen - pubylen));\n   if (ret != MP_OKAY)\n      goto done;\n   XMEMCPY(out+1+numlen, buf, numlen);\n   *outLen = 1 + 2*numlen;\ndone:\n#ifdef WOLFSSL_SMALL_STACK\n   XFREE(buf, NULL, DYNAMIC_TYPE_ECC_BUFFER);\n#endif\n   return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":81876
  },
  {
    "code":"static u16 rtnl_calcit(struct sk_buff *skb, struct nlmsghdr *nlh)\n{\n  struct net *net = sock_net(skb->sk);\n  struct net_device *dev;\n  struct nlattr *tb[IFLA_MAX+1];\n  u32 ext_filter_mask = 0;\n  u16 min_ifinfo_dump_size = 0;\n  if (nlmsg_parse(nlh, sizeof(struct rtgenmsg), tb, IFLA_MAX,\n      ifla_policy) >= 0) {\n    if (tb[IFLA_EXT_MASK])\n      ext_filter_mask = nla_get_u32(tb[IFLA_EXT_MASK]);\n  }\n  if (!ext_filter_mask)\n    return NLMSG_GOODSIZE;\n  list_for_each_entry(dev, &net->dev_base_head, dev_list) {\n    min_ifinfo_dump_size = max_t(u16, min_ifinfo_dump_size,\n               if_nlmsg_size(dev,\n                       ext_filter_mask));\n  }\n  return min_ifinfo_dump_size;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":31031
  },
  {
    "code":"void OmniboxViewWin::RevertAll() {\n  ScopedFreeze freeze(this, GetTextObjectModel());\n  ClosePopup();\n  model_->Revert();\n  saved_selection_for_focus_change_.cpMin = -1;\n  TextChanged();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":115276
  },
  {
    "code":"void TabletEventConverterEvdev::ConvertKeyEvent(const input_event& input) {\n  if (input.code >= BTN_TOOL_PEN && input.code <= BTN_TOOL_LENS) {\n    if (input.value == 1)\n      stylus_ = input.code;\n    else if (input.value == 0)\n      stylus_ = 0;\n    else\n      LOG(WARNING) << \"Unexpected value: \" << input.value\n                   << \" for code: \" << input.code;\n  }\n  if (input.code >= BTN_TOUCH && input.code <= BTN_STYLUS2) {\n    DispatchMouseButton(input);\n    return;\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":134795
  },
  {
    "code":"bool HTMLInputElement::rendererIsNeeded(const NodeRenderingContext& context)\n{\n    return m_inputType->rendererIsNeeded() && HTMLTextFormControlElement::rendererIsNeeded(context);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":121228
  },
  {
    "code":"  ~Logger() {}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":139905
  },
  {
    "code":"MediaControlPlayButtonElement::getOverflowStringName() {\n  if (mediaElement().paused())\n    return WebLocalizedString::OverflowMenuPlay;\n  return WebLocalizedString::OverflowMenuPause;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":137858
  },
  {
    "code":"u64 ring_buffer_time_stamp(struct ring_buffer *buffer, int cpu)\n{\n  u64 time;\n  preempt_disable_notrace();\n  time = rb_time_stamp(buffer);\n  preempt_enable_no_resched_notrace();\n  return time;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":72635
  },
  {
    "code":"  P2PQuicStreamImpl* stream() const { return stream_; }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":145446
  },
  {
    "code":"SetupWildMatch(FontTablePtr table, FontNamePtr pat,\n         int *leftp, int *rightp, int *privatep)\n{\n    int         nDashes;\n    char        c;\n    char       *t;\n    char       *firstWild;\n    char       *firstDigit;\n    int         first;\n    int         center,\n                left,\n                right;\n    int         result;\n    char  *name;\n    name = pat->name;\n    nDashes = pat->ndashes;\n    firstWild = 0;\n    firstDigit = 0;\n    t = name;\n    while ((c = *t++)) {\n  if (isWild(c)) {\n      if (!firstWild)\n    firstWild = t - 1;\n  }\n  if (isDigit(c)) {\n      if (!firstDigit)\n    firstDigit = t - 1;\n  }\n    }\n    left = 0;\n    right = table->used;\n    if (firstWild)\n  *privatep = nDashes;\n    else\n  *privatep = -1;\n    if (!table->sorted) {\n  *leftp = left;\n  *rightp = right;\n  return -1;\n    } else if (firstWild) {\n  if (firstDigit && firstDigit < firstWild)\n      first = firstDigit - name;\n  else\n      first = firstWild - name;\n  while (left < right) {\n      center = (left + right) \/ 2;\n      result = strncmp(name, table->entries[center].name.name, first);\n      if (result == 0)\n    break;\n      if (result < 0)\n    right = center;\n      else\n    left = center + 1;\n  }\n  *leftp = left;\n  *rightp = right;\n  return -1;\n    } else {\n  while (left < right) {\n      center = (left + right) \/ 2;\n      result = strcmpn(name, table->entries[center].name.name);\n      if (result == 0)\n    return center;\n      if (result < 0)\n    right = center;\n      else\n    left = center + 1;\n  }\n  *leftp = 1;\n  *rightp = 0;\n  return -1;\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":2872
  },
  {
    "code":"void PageSerializer::retrieveResourcesForProperties(const StylePropertySet* styleDeclaration, Document* document)\n{\n    if (!styleDeclaration)\n        return;\n    unsigned propertyCount = styleDeclaration->propertyCount();\n    for (unsigned i = 0; i < propertyCount; ++i) {\n        RefPtr<CSSValue> cssValue = styleDeclaration->propertyAt(i).value();\n        retrieveResourcesForCSSValue(cssValue.get(), document);\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":127274
  },
  {
    "code":"void Splash::setTransfer(Guchar *red, Guchar *green, Guchar *blue,\n       Guchar *gray) {\n  state->setTransfer(red, green, blue, gray);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":4148
  },
  {
    "code":"int usb_device_supports_lpm(struct usb_device *udev)\n{\n  if (udev->quirks & USB_QUIRK_NO_LPM)\n    return 0;\n  if (udev->speed == USB_SPEED_HIGH || udev->speed == USB_SPEED_FULL) {\n    if (udev->bos->ext_cap &&\n      (USB_LPM_SUPPORT &\n       le32_to_cpu(udev->bos->ext_cap->bmAttributes)))\n      return 1;\n    return 0;\n  }\n  if (!udev->bos->ss_cap) {\n    dev_info(&udev->dev, \"No LPM exit latency info found, disabling LPM.\\n\");\n    return 0;\n  }\n  if (udev->bos->ss_cap->bU1devExitLat == 0 &&\n      udev->bos->ss_cap->bU2DevExitLat == 0) {\n    if (udev->parent)\n      dev_info(&udev->dev, \"LPM exit latency is zeroed, disabling LPM.\\n\");\n    else\n      dev_info(&udev->dev, \"We don't know the algorithms for LPM for this host, disabling LPM.\\n\");\n    return 0;\n  }\n  if (!udev->parent || udev->parent->lpm_capable)\n    return 1;\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":56793
  },
  {
    "code":"PassRefPtr<Range> TextIterator::rangeFromLocationAndLength(ContainerNode* scope, int rangeLocation, int rangeLength, bool forSelectionPreservation)\n{\n    RefPtr<Range> resultRange = scope->document()->createRange();\n    int docTextPosition = 0;\n    int rangeEnd = rangeLocation + rangeLength;\n    bool startRangeFound = false;\n    RefPtr<Range> textRunRange;\n    TextIterator it(rangeOfContents(scope).get(), forSelectionPreservation ? TextIteratorEmitsCharactersBetweenAllVisiblePositions : TextIteratorDefaultBehavior);\n    if (rangeLocation == 0 && rangeLength == 0 && it.atEnd()) {\n        textRunRange = it.range();\n        resultRange->setStart(textRunRange->startContainer(), 0, ASSERT_NO_EXCEPTION);\n        resultRange->setEnd(textRunRange->startContainer(), 0, ASSERT_NO_EXCEPTION);\n        return resultRange.release();\n    }\n    for (; !it.atEnd(); it.advance()) {\n        int len = it.length();\n        textRunRange = it.range();\n        bool foundStart = rangeLocation >= docTextPosition && rangeLocation <= docTextPosition + len;\n        bool foundEnd = rangeEnd >= docTextPosition && rangeEnd <= docTextPosition + len;\n        if (foundEnd) {\n            if (len == 1 && it.characterAt(0) == '\\n') {\n                scope->document()->updateLayoutIgnorePendingStylesheets();\n                it.advance();\n                if (!it.atEnd()) {\n                    RefPtr<Range> range = it.range();\n                    textRunRange->setEnd(range->startContainer(), range->startOffset(), ASSERT_NO_EXCEPTION);\n                } else {\n                    Position runStart = textRunRange->startPosition();\n                    Position runEnd = VisiblePosition(runStart).next().deepEquivalent();\n                    if (runEnd.isNotNull())\n                        textRunRange->setEnd(runEnd.containerNode(), runEnd.computeOffsetInContainerNode(), ASSERT_NO_EXCEPTION);\n                }\n            }\n        }\n        if (foundStart) {\n            startRangeFound = true;\n            int exception = 0;\n            if (textRunRange->startContainer()->isTextNode()) {\n                int offset = rangeLocation - docTextPosition;\n                resultRange->setStart(textRunRange->startContainer(), offset + textRunRange->startOffset(), exception);\n            } else {\n                if (rangeLocation == docTextPosition)\n                    resultRange->setStart(textRunRange->startContainer(), textRunRange->startOffset(), exception);\n                else\n                    resultRange->setStart(textRunRange->endContainer(), textRunRange->endOffset(), exception);\n            }\n        }\n        if (foundEnd) {\n            int exception = 0;\n            if (textRunRange->startContainer()->isTextNode()) {\n                int offset = rangeEnd - docTextPosition;\n                resultRange->setEnd(textRunRange->startContainer(), offset + textRunRange->startOffset(), exception);\n            } else {\n                if (rangeEnd == docTextPosition)\n                    resultRange->setEnd(textRunRange->startContainer(), textRunRange->startOffset(), exception);\n                else\n                    resultRange->setEnd(textRunRange->endContainer(), textRunRange->endOffset(), exception);\n            }\n            docTextPosition += len;\n            break;\n        }\n        docTextPosition += len;\n    }\n    if (!startRangeFound)\n        return 0;\n    if (rangeLength != 0 && rangeEnd > docTextPosition) { \n        int exception = 0;\n        resultRange->setEnd(textRunRange->endContainer(), textRunRange->endOffset(), exception);\n    }\n    return resultRange.release();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":121635
  },
  {
    "code":"static void unuse_table(struct ctl_table_header *p)\n{\n  if (!--p->used)\n    if (unlikely(p->unregistering))\n      complete(p->unregistering);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":24464
  },
  {
    "code":"  content::DownloadTestObserver* CreateInProgressWaiter(\n      Browser* browser, int num_downloads) {\n    DownloadManager* download_manager = DownloadManagerForBrowser(browser);\n    return new content::DownloadTestObserverInProgress(\n        download_manager, num_downloads);\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":164817
  },
  {
    "code":"void BrowserActionsContainer::BubbleLostFocus(BrowserBubble* bubble,\n                                              gfx::NativeView focused_view) {\n  if (!popup_)\n    return;\n#if defined(OS_WIN)\n  gfx::NativeView popup_native_view = popup_->native_view();\n  gfx::NativeView parent = focused_view;\n  while (parent = ::GetParent(parent)) {\n    if (parent == popup_native_view)\n      return;\n  }\n#endif\n  MessageLoop::current()->PostTask(FROM_HERE,\n      task_factory_.NewRunnableMethod(&BrowserActionsContainer::HidePopup));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":100105
  },
  {
    "code":"static void print_hex(const u8 * buf, size_t buflen, size_t depth)\n{\n  size_t lines_len = buflen * 5 + 128;\n  char *lines = malloc(lines_len);\n  char *line = lines;\n  if (buf == NULL || buflen == 0 || lines == NULL) {\n    free(lines);\n    return;\n  }\n  sc_hex_dump(buf, buflen, lines, lines_len);\n  while (*line != '\\0') {\n    char *line_end = strchr(line, '\\n');\n    ptrdiff_t width = line_end - line;\n    if (!line_end || width <= 1) {\n      break;\n    }\n    if (buflen > 8) {\n      putchar('\\n');\n      print_indent(depth);\n    } else {\n      printf(\": \");\n    }\n    printf(\"%.*s\", (int) width, line);\n    line = line_end + 1;\n  }\n  free(lines);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":78118
  },
  {
    "code":"void FetchContext::SetFirstPartyCookieAndRequestorOrigin(ResourceRequest&) {}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":151544
  },
  {
    "code":"  Ins_WCVTF( TT_ExecContext  exc,\n             FT_Long*        args )\n  {\n    FT_ULong  I = (FT_ULong)args[0];\n    if ( BOUNDSL( I, exc->cvtSize ) )\n    {\n      if ( exc->pedantic_hinting )\n        ARRAY_BOUND_ERROR;\n    }\n    else\n      exc->cvt[I] = FT_MulFix( args[1], exc->tt_metrics.scale );\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":10692
  },
  {
    "code":"static int timer_coldplug(Unit *u) {\n        Timer *t = TIMER(u);\n        assert(t);\n        assert(t->state == TIMER_DEAD);\n        if (t->deserialized_state != t->state) {\n                if (t->deserialized_state == TIMER_WAITING)\n                        timer_enter_waiting(t, false);\n                else\n                        timer_set_state(t, t->deserialized_state);\n        }\n        return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":96120
  },
  {
    "code":"static int mxf_get_sorted_table_segments(MXFContext *mxf, int *nb_sorted_segments, MXFIndexTableSegment ***sorted_segments)\n{\n    int i, j, nb_segments = 0;\n    MXFIndexTableSegment **unsorted_segments;\n    int last_body_sid = -1, last_index_sid = -1, last_index_start = -1;\n    for (i = 0; i < mxf->metadata_sets_count; i++)\n        if (mxf->metadata_sets[i]->type == IndexTableSegment)\n            nb_segments++;\n    if (!nb_segments)\n        return AVERROR_INVALIDDATA;\n    if (!(unsorted_segments = av_calloc(nb_segments, sizeof(*unsorted_segments))) ||\n        !(*sorted_segments  = av_calloc(nb_segments, sizeof(**sorted_segments)))) {\n        av_freep(sorted_segments);\n        av_free(unsorted_segments);\n        return AVERROR(ENOMEM);\n    }\n    for (i = j = 0; i < mxf->metadata_sets_count; i++)\n        if (mxf->metadata_sets[i]->type == IndexTableSegment)\n            unsorted_segments[j++] = (MXFIndexTableSegment*)mxf->metadata_sets[i];\n    *nb_sorted_segments = 0;\n    for (i = 0; i < nb_segments; i++) {\n        int best = -1, best_body_sid = -1, best_index_sid = -1, best_index_start = -1;\n        uint64_t best_index_duration = 0;\n        for (j = 0; j < nb_segments; j++) {\n            MXFIndexTableSegment *s = unsorted_segments[j];\n            if ((i == 0 ||\n                 s->body_sid >  last_body_sid ||\n                 s->body_sid == last_body_sid && s->index_sid >  last_index_sid ||\n                 s->body_sid == last_body_sid && s->index_sid == last_index_sid && s->index_start_position > last_index_start) &&\n                (best == -1 ||\n                 s->body_sid <  best_body_sid ||\n                 s->body_sid == best_body_sid && s->index_sid <  best_index_sid ||\n                 s->body_sid == best_body_sid && s->index_sid == best_index_sid && s->index_start_position <  best_index_start ||\n                 s->body_sid == best_body_sid && s->index_sid == best_index_sid && s->index_start_position == best_index_start && s->index_duration > best_index_duration)) {\n                best             = j;\n                best_body_sid    = s->body_sid;\n                best_index_sid   = s->index_sid;\n                best_index_start = s->index_start_position;\n                best_index_duration = s->index_duration;\n            }\n        }\n        if (best == -1)\n            break;\n        (*sorted_segments)[(*nb_sorted_segments)++] = unsorted_segments[best];\n        last_body_sid    = best_body_sid;\n        last_index_sid   = best_index_sid;\n        last_index_start = best_index_start;\n    }\n    av_free(unsorted_segments);\n    return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":74834
  },
  {
    "code":"static int dn_device_event(struct notifier_block *this, unsigned long event,\n         void *ptr)\n{\n  struct net_device *dev = netdev_notifier_info_to_dev(ptr);\n  if (!net_eq(dev_net(dev), &init_net))\n    return NOTIFY_DONE;\n  switch (event) {\n  case NETDEV_UP:\n    dn_dev_up(dev);\n    break;\n  case NETDEV_DOWN:\n    dn_dev_down(dev);\n    break;\n  default:\n    break;\n  }\n  return NOTIFY_DONE;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":41483
  },
  {
    "code":"static void n_tty_flush_buffer(struct tty_struct *tty)\n{\n  down_write(&tty->termios_rwsem);\n  reset_buffer_flags(tty->disc_data);\n  n_tty_kick_worker(tty);\n  if (tty->link)\n    n_tty_packet_mode_flush(tty);\n  up_write(&tty->termios_rwsem);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":76488
  },
  {
    "code":"void clear_ftrace_function(void)\n{\n  ftrace_trace_function = ftrace_stub;\n  ftrace_pid_function = ftrace_stub;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":30118
  },
  {
    "code":"static void load_creator(FILE *fp, pdf_t *pdf)\n{\n    int    i, buf_idx;\n    char   c, *buf, obj_id_buf[32] = {0};\n    long   start;\n    size_t sz;\n    start = ftell(fp);\n    for (i=0; i<pdf->n_xrefs; ++i)\n    {\n        if (!pdf->xrefs[i].version)\n          continue;\n        fseek(fp, pdf->xrefs[i].start, SEEK_SET);\n        while (SAFE_F(fp, (fgetc(fp) != 't')))\n            ; \n        c = '\\0';\n        while (SAFE_F(fp, ((c = fgetc(fp)) != '>')))\n          if (SAFE_F(fp, ((c == '\/') &&\n                          (fgetc(fp) == 'I') && ((fgetc(fp) == 'n')))))\n            break;\n        END_OF_TRAILER(c, start, fp);\n        while (SAFE_F(fp, (!isspace(c = fgetc(fp)) && (c != '>'))))\n            ; \n        END_OF_TRAILER(c, start, fp);\n        while (SAFE_F(fp, (isspace(c = fgetc(fp)) && (c != '>'))))\n            ; \n        END_OF_TRAILER(c, start, fp);\n        buf_idx = 0;\n        obj_id_buf[buf_idx++] = c;\n        while ((buf_idx < (sizeof(obj_id_buf) - 1)) &&\n               SAFE_F(fp, (!isspace(c = fgetc(fp)) && (c != '>'))))\n          obj_id_buf[buf_idx++] = c;\n        END_OF_TRAILER(c, start, fp);\n        buf = get_object(fp, atoll(obj_id_buf), &pdf->xrefs[i], &sz, NULL);\n        if (!buf && pdf->xrefs[i].is_linear && (i+1 < pdf->n_xrefs))\n          buf = get_object(fp, atoll(obj_id_buf), &pdf->xrefs[i+1], &sz, NULL);\n        load_creator_from_buf(fp, &pdf->xrefs[i], buf);\n        free(buf);\n    }\n    fseek(fp, start, SEEK_SET);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":88590
  },
  {
    "code":"tracing_mark_raw_write(struct file *filp, const char __user *ubuf,\n          size_t cnt, loff_t *fpos)\n{\n  struct trace_array *tr = filp->private_data;\n  struct ring_buffer_event *event;\n  struct ring_buffer *buffer;\n  struct raw_data_entry *entry;\n  const char faulted[] = \"<faulted>\";\n  unsigned long irq_flags;\n  ssize_t written;\n  int size;\n  int len;\n#define FAULT_SIZE_ID (FAULTED_SIZE + sizeof(int))\n  if (tracing_disabled)\n    return -EINVAL;\n  if (!(tr->trace_flags & TRACE_ITER_MARKERS))\n    return -EINVAL;\n  if (cnt < sizeof(unsigned int) || cnt > RAW_DATA_MAX_SIZE)\n    return -EINVAL;\n  if (cnt > TRACE_BUF_SIZE)\n    cnt = TRACE_BUF_SIZE;\n  BUILD_BUG_ON(TRACE_BUF_SIZE >= PAGE_SIZE);\n  local_save_flags(irq_flags);\n  size = sizeof(*entry) + cnt;\n  if (cnt < FAULT_SIZE_ID)\n    size += FAULT_SIZE_ID - cnt;\n  buffer = tr->trace_buffer.buffer;\n  event = __trace_buffer_lock_reserve(buffer, TRACE_RAW_DATA, size,\n              irq_flags, preempt_count());\n  if (!event)\n    return -EBADF;\n  entry = ring_buffer_event_data(event);\n  len = __copy_from_user_inatomic(&entry->id, ubuf, cnt);\n  if (len) {\n    entry->id = -1;\n    memcpy(&entry->buf, faulted, FAULTED_SIZE);\n    written = -EFAULT;\n  } else\n    written = cnt;\n  __buffer_unlock_commit(buffer, event);\n  if (written > 0)\n    *fpos += written;\n  return written;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":81480
  },
  {
    "code":"BackFramebuffer::~BackFramebuffer() {\n  DCHECK_EQ(id_, 0u);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":129532
  },
  {
    "code":"static void ass_shaper_skip_characters(TextInfo *text_info)\n{\n    int i;\n    GlyphInfo *glyphs = text_info->glyphs;\n    for (i = 0; i < text_info->length; i++) {\n        if ((glyphs[i].symbol <= 0x202e && glyphs[i].symbol >= 0x202a)\n                || (glyphs[i].symbol <= 0x200f && glyphs[i].symbol >= 0x200b)\n                || (glyphs[i].symbol <= 0x2063 && glyphs[i].symbol >= 0x2060)\n                || glyphs[i].symbol == 0xfeff\n                || glyphs[i].symbol == 0x00ad\n                || glyphs[i].symbol == 0x034f) {\n            glyphs[i].symbol = 0;\n            glyphs[i].skip++;\n        }\n    }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":73286
  },
  {
    "code":"static void nfs4_free_deleg(struct nfs4_stid *stid)\n{\n  kmem_cache_free(deleg_slab, stid);\n  atomic_long_dec(&num_delegations);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":65517
  },
  {
    "code":"UrlData::UrlData(const GURL& url, CORSMode cors_mode, UrlIndex* url_index)\n    : url_(url),\n      have_data_origin_(false),\n      cors_mode_(cors_mode),\n      url_index_(url_index),\n       length_(kPositionNotSpecified),\n       range_supported_(false),\n       cacheable_(false),\n      has_opaque_data_(false),\n       last_used_(),\n       multibuffer_(this, url_index_->block_shift_) {}\n",
    "vul":1,
    "flaw_line_no":[
      9
    ],
    "bigvul_id":186605
  },
  {
    "code":"IPC::PlatformFileForTransit CreateFileForProcess(base::FilePath file_path) {\n  DCHECK_CURRENTLY_ON(BrowserThread::FILE);\n  base::File dump_file(file_path,\n                       base::File::FLAG_OPEN_ALWAYS | base::File::FLAG_APPEND);\n  if (!dump_file.IsValid()) {\n    VLOG(1) << \"Could not open AEC dump file, error=\"\n            << dump_file.error_details();\n    return IPC::InvalidPlatformFileForTransit();\n  }\n  return IPC::TakePlatformFileForTransit(std::move(dump_file));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":139129
  },
  {
    "code":"bool SessionService::IsOnlyOneTabLeft() {\n  if (!profile()) {\n    return false;\n  }\n  int window_count = 0;\n  for (BrowserList::const_iterator i = BrowserList::begin();\n       i != BrowserList::end(); ++i) {\n    const SessionID::id_type window_id = (*i)->session_id().id();\n    if (should_track_changes_for_browser_type((*i)->type()) &&\n        (*i)->profile() == profile() &&\n        window_closing_ids_.find(window_id) == window_closing_ids_.end()) {\n      if (++window_count > 1)\n        return false;\n      if ((*i)->tab_count() > 0)\n        return false;\n    }\n  }\n  return true;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":117073
  },
  {
    "code":"  void RegisterTestScheme(const std::string& scheme) {\n    test_browser_client_.AddScheme(scheme);\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":108816
  },
  {
    "code":"void RenderViewTest::LoadHTMLWithUrlOverride(const char* html,\n                                             const char* url_override) {\n  GetMainFrame()->LoadHTMLString(std::string(html),\n                                 blink::WebURL(GURL(url_override)));\n  FrameLoadWaiter(view_->GetMainRenderFrame()).Wait();\n  view_->GetWebView()->UpdateAllLifecyclePhases();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":137397
  },
  {
    "code":"string16 DatabaseUtil::GetOriginIdentifier(const GURL& url) {\n  string16 spec = UTF8ToUTF16(url.spec());\n  return WebKit::WebSecurityOrigin::createFromString(spec).databaseIdentifier();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":125263
  },
  {
    "code":"static unsigned long mmap_legacy_base(void)\n{\n  if (mmap_is_ia32())\n    return TASK_UNMAPPED_BASE;\n  else\n    return TASK_UNMAPPED_BASE + mmap_rnd();\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":44274
  },
  {
    "code":"static int unsupported_abort_transfers(int sub_api, struct usbi_transfer *itransfer) {\n  PRINT_UNSUPPORTED_API(abort_transfers);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":168556
  },
  {
    "code":"lt_int_dyld_match_loaded_lib_by_install_name(const char *name)\n{\n  int i=_dyld_image_count();\n  int j;\n  const struct mach_header *mh=NULL;\n  const char *id=NULL;\n  for (j = 0; j < i; j++)\n  {\n    id=lt_int_dyld_lib_install_name(_dyld_get_image_header(j));\n    if ((id) && (!strcmp(id,name)))\n    {\n      mh=_dyld_get_image_header(j);\n      break;\n    }\n  }\n  return mh;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":701
  },
  {
    "code":"static int cliConnect(int force) {\n    if (context == NULL || force) {\n        if (context != NULL) {\n            redisFree(context);\n        }\n        if (config.hostsocket == NULL) {\n            context = redisConnect(config.hostip,config.hostport);\n        } else {\n            context = redisConnectUnix(config.hostsocket);\n        }\n        if (context->err) {\n            fprintf(stderr,\"Could not connect to Redis at \");\n            if (config.hostsocket == NULL)\n                fprintf(stderr,\"%s:%d: %s\\n\",config.hostip,config.hostport,context->errstr);\n            else\n                fprintf(stderr,\"%s: %s\\n\",config.hostsocket,context->errstr);\n            redisFree(context);\n            context = NULL;\n            return REDIS_ERR;\n        }\n        anetKeepAlive(NULL, context->fd, REDIS_CLI_KEEPALIVE_INTERVAL);\n        if (cliAuth() != REDIS_OK)\n            return REDIS_ERR;\n        if (cliSelect() != REDIS_OK)\n            return REDIS_ERR;\n    }\n    return REDIS_OK;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":81936
  },
  {
    "code":"gfx::Point RenderWidgetHostViewGtk::GetWidgetCenter() {\n  if (widget_center_valid_)\n    return widget_center_;\n  GdkWindow* window = gtk_widget_get_window(view_.get());\n  gint window_x = 0;\n  gint window_y = 0;\n  gdk_window_get_origin(window, &window_x, &window_y);\n  gint window_w = gdk_window_get_width(window);\n  gint window_h = gdk_window_get_height(window);\n  widget_center_.SetPoint(window_x + window_w \/ 2,\n                          window_y + window_h \/ 2);\n  widget_center_valid_ = true;\n  return widget_center_;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":123301
  },
  {
    "code":"static size_t QuantizeErrorFlatten(const CubeInfo *cube_info,\n  const NodeInfo *node_info,const ssize_t offset,\n  MagickRealType *quantize_error)\n{\n  register ssize_t\n    i;\n  size_t\n    n,\n    number_children;\n  if (offset >= (ssize_t) cube_info->nodes)\n    return(0);\n  quantize_error[offset]=node_info->quantize_error;\n  n=1;\n  number_children=cube_info->associate_alpha == MagickFalse ? 8UL : 16UL;\n  for (i=0; i < (ssize_t) number_children ; i++)\n    if (node_info->child[i] != (NodeInfo *) NULL)\n      n+=QuantizeErrorFlatten(cube_info,node_info->child[i],offset+n,\n        quantize_error);\n  return(n);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":62721
  },
  {
    "code":"void GLES2DecoderImpl::DoGetBufferParameteri64v(GLenum target,\n                                                GLenum pname,\n                                                GLint64* params,\n                                                GLsizei params_size) {\n  buffer_manager()->ValidateAndDoGetBufferParameteri64v(\n      &state_, target, pname, params);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":158685
  },
  {
    "code":"bool OmniboxEditModel::UpdatePermanentText() {\n  SearchProvider* search_provider =\n      autocomplete_controller()->search_provider();\n  if (search_provider && delegate_->CurrentPageExists())\n    search_provider->set_current_page_url(delegate_->GetURL());\n  base::string16 new_permanent_text = controller_->GetToolbarModel()->GetText();\n  base::string16 gray_text = view_->GetGrayTextAutocompletion();\n  const bool visibly_changed_permanent_text =\n      (permanent_text_ != new_permanent_text) &&\n      (!has_focus() ||\n       (!user_input_in_progress_ &&\n        !(popup_model() && popup_model()->IsOpen()) &&\n        controller_->GetToolbarModel()->url_replacement_enabled())) &&\n      (gray_text.empty() ||\n       new_permanent_text != user_text_ + gray_text);\n  permanent_text_ = new_permanent_text;\n  return visibly_changed_permanent_text;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":119364
  },
  {
    "code":"pdf14_copy_planes(gx_device * dev, const byte * data, int data_x, int raster,\n                  gx_bitmap_id id, int x, int y, int w, int h, int plane_height)\n{\n    pdf14_device *pdev = (pdf14_device *)dev;\n#if RAW_DUMP\n    pdf14_ctx *ctx = pdev->ctx;\n#endif\n    pdf14_buf *buf = pdev->ctx->stack;\n    uchar num_planes = dev->color_info.num_components;\n    byte *dptr = (byte *)data + data_x;\n    int yinc, xinc;\n    uchar pi;\n    gx_drawing_color dcolor;\n    int code = 0;\n    fit_fill_xywh(dev, x, y, w, h);\n    if (w <= 0 || h <= 0)\n        return 0;\n    dcolor.type = gx_dc_type_devn;\n    for (yinc = 0; yinc < h; yinc++) {\n        for (xinc = 0; xinc < w; xinc++) {\n            for (pi = 0; pi < num_planes; pi++) {\n                dcolor.colors.devn.values[pi] = *(dptr + plane_height * raster * pi) << 8;\n            }\n            if (buf->knockout)\n                code =\n                    pdf14_mark_fill_rectangle_ko_simple(dev, x + xinc,\n                                                        y + yinc, 1, 1, 0,\n                                                        &dcolor, true);\n            else\n                code =\n                    pdf14_mark_fill_rectangle(dev, x + xinc, y + yinc, 1, 1, 0,\n                                               &dcolor, true);\n            if (code < 0)\n                return code;\n            dptr++;\n        }\n        dptr = (byte *)data + raster * yinc + data_x;\n    }\n    return code;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":13300
  },
  {
    "code":"static uint64_t ns_to_ticks(uint64_t value)\n{\n    return (muldiv64(value, FS_PER_NS, HPET_CLK_PERIOD));\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":15756
  },
  {
    "code":"void PasswordAutofillAgent::OnWillSubmitForm(const WebFormElement& form) {\n  std::unique_ptr<RendererSavePasswordProgressLogger> logger;\n  if (logging_state_active_) {\n    logger.reset(new RendererSavePasswordProgressLogger(\n        GetPasswordManagerDriver().get()));\n    logger->LogMessage(Logger::STRING_WILL_SUBMIT_FORM_METHOD);\n    LogHTMLForm(logger.get(), Logger::STRING_HTML_FORM_FOR_SUBMIT, form);\n  }\n  std::unique_ptr<PasswordForm> submitted_form =\n      GetPasswordFormFromWebForm(form);\n  if (submitted_form) {\n    if (logger) {\n      logger->LogPasswordForm(Logger::STRING_CREATED_PASSWORD_FORM,\n                              *submitted_form);\n    }\n    submitted_form->submission_event =\n        SubmissionIndicatorEvent::HTML_FORM_SUBMISSION;\n    submitted_form->form_data.submission_event =\n        SubmissionIndicatorEvent::HTML_FORM_SUBMISSION;\n    if (FrameCanAccessPasswordManager()) {\n      GetPasswordManagerDriver()->PasswordFormSubmitted(*submitted_form);\n    } else {\n      if (logger)\n        logger->LogMessage(Logger::STRING_SECURITY_ORIGIN_FAILURE);\n    }\n    browser_has_form_to_process_ = false;\n  } else if (logger) {\n    logger->LogMessage(Logger::STRING_FORM_IS_NOT_PASSWORD);\n  }\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":150325
  },
  {
    "code":"static int kvm_vcpu_ioctl_interrupt(struct kvm_vcpu *vcpu,\n            struct kvm_interrupt *irq)\n{\n  if (irq->irq < 0 || irq->irq >= 256)\n    return -EINVAL;\n  if (irqchip_in_kernel(vcpu->kvm))\n    return -ENXIO;\n  kvm_queue_interrupt(vcpu, irq->irq, false);\n  kvm_make_request(KVM_REQ_EVENT, vcpu);\n  return 0;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":20829
  },
  {
    "code":"  AutoLockOnValidThread(base::Lock& lock, base::ThreadChecker* thread_checker)\n      : auto_lock_(lock) {\n    DCHECK(!thread_checker || thread_checker->CalledOnValidThread());\n  }\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":164400
  },
  {
    "code":"R_API int r_bin_load(RBin *bin, const char *file, ut64 baseaddr, ut64 loadaddr, int xtr_idx, int fd, int rawstr) {\n  if (!bin) {\n    return false;\n  }\n  RIOBind *iob = &(bin->iob);\n  if (!iob) {\n    return false;\n  }\n  if (!iob->io) {\n    iob->io = r_io_new ();  \n    if (!iob->io) {\n      return false;\n    }\n    bin->io_owned = true;\n    r_io_bind (iob->io, &bin->iob);    \n    iob = &bin->iob;\n  }\n  if (!iob->desc_get (iob->io, fd)) {\n    fd = iob->fd_open (iob->io, file, R_IO_READ, 0644);\n  }\n  bin->rawstr = rawstr;\n  if (fd < 0) {\n    r_io_free (iob->io);\n    memset (&bin->iob, 0, sizeof (bin->iob));\n    bin->io_owned = false;\n    return false;\n  }\n  return r_bin_load_io (bin, fd, baseaddr, loadaddr, xtr_idx);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":60181
  },
  {
    "code":"int am_urldecode(char *data)\n{\n    char *ip;\n    char *op;\n    int c1, c2;\n    if (data == NULL) {\n        return HTTP_BAD_REQUEST;\n    }\n    ip = data;\n    op = data;\n    while (*ip) {\n        switch (*ip) {\n        case '+':\n            *op = ' ';\n            ip++;\n            op++;\n            break;\n        case '%':\n            c1 = am_unhex_digit(ip[1]);\n            if (c1 < 0) {\n                return HTTP_BAD_REQUEST;\n            }\n            c2 = am_unhex_digit(ip[2]);\n            if (c2 < 0) {\n                return HTTP_BAD_REQUEST;\n            }\n            *op = (c1 << 4) | c2;\n            if (*op == '\\0') {\n                return HTTP_BAD_REQUEST;\n            }\n            ip += 3;\n            op++;\n            break;\n        default:\n            *op = *ip;\n            ip++;\n            op++;\n        }\n    }\n    *op = '\\0';\n    return OK;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":91729
  },
  {
    "code":"static int udf_symlink(struct inode *dir, struct dentry *dentry,\n           const char *symname)\n{\n  struct inode *inode;\n  struct pathComponent *pc;\n  const char *compstart;\n  struct udf_fileident_bh fibh;\n  struct extent_position epos = {};\n  int eoffset, elen = 0;\n  struct fileIdentDesc *fi;\n  struct fileIdentDesc cfi;\n  uint8_t *ea;\n  int err;\n  int block;\n  unsigned char *name = NULL;\n  int namelen;\n  struct udf_inode_info *iinfo;\n  struct super_block *sb = dir->i_sb;\n  inode = udf_new_inode(dir, S_IFLNK | S_IRWXUGO, &err);\n  if (!inode)\n    goto out;\n  iinfo = UDF_I(inode);\n  down_write(&iinfo->i_data_sem);\n  name = kmalloc(UDF_NAME_LEN, GFP_NOFS);\n  if (!name) {\n    err = -ENOMEM;\n    goto out_no_entry;\n  }\n  inode->i_data.a_ops = &udf_symlink_aops;\n  inode->i_op = &udf_symlink_inode_operations;\n  if (iinfo->i_alloc_type != ICBTAG_FLAG_AD_IN_ICB) {\n    struct kernel_lb_addr eloc;\n    uint32_t bsize;\n    block = udf_new_block(sb, inode,\n        iinfo->i_location.partitionReferenceNum,\n        iinfo->i_location.logicalBlockNum, &err);\n    if (!block)\n      goto out_no_entry;\n    epos.block = iinfo->i_location;\n    epos.offset = udf_file_entry_alloc_offset(inode);\n    epos.bh = NULL;\n    eloc.logicalBlockNum = block;\n    eloc.partitionReferenceNum =\n        iinfo->i_location.partitionReferenceNum;\n    bsize = sb->s_blocksize;\n    iinfo->i_lenExtents = bsize;\n    udf_add_aext(inode, &epos, &eloc, bsize, 0);\n    brelse(epos.bh);\n    block = udf_get_pblock(sb, block,\n        iinfo->i_location.partitionReferenceNum,\n        0);\n    epos.bh = udf_tgetblk(sb, block);\n    lock_buffer(epos.bh);\n    memset(epos.bh->b_data, 0x00, bsize);\n    set_buffer_uptodate(epos.bh);\n    unlock_buffer(epos.bh);\n    mark_buffer_dirty_inode(epos.bh, inode);\n    ea = epos.bh->b_data + udf_ext0_offset(inode);\n  } else\n    ea = iinfo->i_ext.i_data + iinfo->i_lenEAttr;\n  eoffset = sb->s_blocksize - udf_ext0_offset(inode);\n  pc = (struct pathComponent *)ea;\n  if (*symname == '\/') {\n    do {\n      symname++;\n    } while (*symname == '\/');\n    pc->componentType = 1;\n    pc->lengthComponentIdent = 0;\n    pc->componentFileVersionNum = 0;\n    elen += sizeof(struct pathComponent);\n  }\n  err = -ENAMETOOLONG;\n  while (*symname) {\n    if (elen + sizeof(struct pathComponent) > eoffset)\n      goto out_no_entry;\n    pc = (struct pathComponent *)(ea + elen);\n    compstart = symname;\n    do {\n      symname++;\n    } while (*symname && *symname != '\/');\n    pc->componentType = 5;\n    pc->lengthComponentIdent = 0;\n    pc->componentFileVersionNum = 0;\n    if (compstart[0] == '.') {\n      if ((symname - compstart) == 1)\n        pc->componentType = 4;\n      else if ((symname - compstart) == 2 &&\n          compstart[1] == '.')\n        pc->componentType = 3;\n    }\n    if (pc->componentType == 5) {\n      namelen = udf_put_filename(sb, compstart, name,\n               symname - compstart);\n      if (!namelen)\n        goto out_no_entry;\n      if (elen + sizeof(struct pathComponent) + namelen >\n          eoffset)\n        goto out_no_entry;\n      else\n        pc->lengthComponentIdent = namelen;\n      memcpy(pc->componentIdent, name, namelen);\n    }\n    elen += sizeof(struct pathComponent) + pc->lengthComponentIdent;\n    if (*symname) {\n      do {\n        symname++;\n      } while (*symname == '\/');\n    }\n  }\n  brelse(epos.bh);\n  inode->i_size = elen;\n  if (iinfo->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n    iinfo->i_lenAlloc = inode->i_size;\n  else\n    udf_truncate_tail_extent(inode);\n  mark_inode_dirty(inode);\n  fi = udf_add_entry(dir, dentry, &fibh, &cfi, &err);\n  if (!fi)\n    goto out_no_entry;\n  cfi.icb.extLength = cpu_to_le32(sb->s_blocksize);\n  cfi.icb.extLocation = cpu_to_lelb(iinfo->i_location);\n  if (UDF_SB(inode->i_sb)->s_lvid_bh) {\n    *(__le32 *)((struct allocDescImpUse *)cfi.icb.impUse)->impUse =\n      cpu_to_le32(lvid_get_unique_id(sb));\n  }\n  udf_write_fi(dir, &cfi, fi, &fibh, NULL, NULL);\n  if (UDF_I(dir)->i_alloc_type == ICBTAG_FLAG_AD_IN_ICB)\n    mark_inode_dirty(dir);\n  up_write(&iinfo->i_data_sem);\n  if (fibh.sbh != fibh.ebh)\n    brelse(fibh.ebh);\n  brelse(fibh.sbh);\n  d_instantiate(dentry, inode);\n  err = 0;\nout:\n  kfree(name);\n  return err;\nout_no_entry:\n  up_write(&iinfo->i_data_sem);\n  inode_dec_link_count(inode);\n  iput(inode);\n  goto out;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":34090
  },
  {
    "code":"void GLES2DecoderImpl::DoTexParameteriv(\n  GLenum target, GLenum pname, const GLint* params) {\n  TextureManager::TextureInfo* info = GetTextureInfoForTarget(target);\n  if (!info) {\n    SetGLError(GL_INVALID_VALUE, \"glTexParameteriv: unknown texture\");\n    return;\n  }\n  if (!texture_manager()->SetParameter(feature_info_, info, pname, *params)) {\n    SetGLError(GL_INVALID_ENUM, \"glTexParameteriv: param GL_INVALID_ENUM\");\n    return;\n  }\n  glTexParameteriv(target, pname, params);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":104049
  },
  {
    "code":"int CLASS minolta_z2()\n{\n  int i, nz;\n  char tail[424];\n  fseek (ifp, -sizeof tail, SEEK_END);\n  fread (tail, 1, sizeof tail, ifp);\n  for (nz=i=0; i < (int) sizeof tail; i++)\n    if (tail[i]) nz++;\n  return nz > 20;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":43323
  },
  {
    "code":"static int ext3_fill_super (struct super_block *sb, void *data, int silent)\n{\n  struct buffer_head * bh;\n  struct ext3_super_block *es = NULL;\n  struct ext3_sb_info *sbi;\n  ext3_fsblk_t block;\n  ext3_fsblk_t sb_block = get_sb_block(&data, sb);\n  ext3_fsblk_t logic_sb_block;\n  unsigned long offset = 0;\n  unsigned int journal_inum = 0;\n  unsigned long journal_devnum = 0;\n  unsigned long def_mount_opts;\n  struct inode *root;\n  int blocksize;\n  int hblock;\n  int db_count;\n  int i;\n  int needs_recovery;\n  int ret = -EINVAL;\n  __le32 features;\n  int err;\n  sbi = kzalloc(sizeof(*sbi), GFP_KERNEL);\n  if (!sbi)\n    return -ENOMEM;\n  sbi->s_blockgroup_lock =\n    kzalloc(sizeof(struct blockgroup_lock), GFP_KERNEL);\n  if (!sbi->s_blockgroup_lock) {\n    kfree(sbi);\n    return -ENOMEM;\n  }\n  sb->s_fs_info = sbi;\n  sbi->s_sb_block = sb_block;\n  blocksize = sb_min_blocksize(sb, EXT3_MIN_BLOCK_SIZE);\n  if (!blocksize) {\n    ext3_msg(sb, KERN_ERR, \"error: unable to set blocksize\");\n    goto out_fail;\n  }\n  if (blocksize != EXT3_MIN_BLOCK_SIZE) {\n    logic_sb_block = (sb_block * EXT3_MIN_BLOCK_SIZE) \/ blocksize;\n    offset = (sb_block * EXT3_MIN_BLOCK_SIZE) % blocksize;\n  } else {\n    logic_sb_block = sb_block;\n  }\n  if (!(bh = sb_bread(sb, logic_sb_block))) {\n    ext3_msg(sb, KERN_ERR, \"error: unable to read superblock\");\n    goto out_fail;\n  }\n  es = (struct ext3_super_block *) (bh->b_data + offset);\n  sbi->s_es = es;\n  sb->s_magic = le16_to_cpu(es->s_magic);\n  if (sb->s_magic != EXT3_SUPER_MAGIC)\n    goto cantfind_ext3;\n  def_mount_opts = le32_to_cpu(es->s_default_mount_opts);\n  if (def_mount_opts & EXT3_DEFM_DEBUG)\n    set_opt(sbi->s_mount_opt, DEBUG);\n  if (def_mount_opts & EXT3_DEFM_BSDGROUPS)\n    set_opt(sbi->s_mount_opt, GRPID);\n  if (def_mount_opts & EXT3_DEFM_UID16)\n    set_opt(sbi->s_mount_opt, NO_UID32);\n#ifdef CONFIG_EXT3_FS_XATTR\n  if (def_mount_opts & EXT3_DEFM_XATTR_USER)\n    set_opt(sbi->s_mount_opt, XATTR_USER);\n#endif\n#ifdef CONFIG_EXT3_FS_POSIX_ACL\n  if (def_mount_opts & EXT3_DEFM_ACL)\n    set_opt(sbi->s_mount_opt, POSIX_ACL);\n#endif\n  if ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_DATA)\n    set_opt(sbi->s_mount_opt, JOURNAL_DATA);\n  else if ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_ORDERED)\n    set_opt(sbi->s_mount_opt, ORDERED_DATA);\n  else if ((def_mount_opts & EXT3_DEFM_JMODE) == EXT3_DEFM_JMODE_WBACK)\n    set_opt(sbi->s_mount_opt, WRITEBACK_DATA);\n  if (le16_to_cpu(sbi->s_es->s_errors) == EXT3_ERRORS_PANIC)\n    set_opt(sbi->s_mount_opt, ERRORS_PANIC);\n  else if (le16_to_cpu(sbi->s_es->s_errors) == EXT3_ERRORS_CONTINUE)\n    set_opt(sbi->s_mount_opt, ERRORS_CONT);\n  else\n    set_opt(sbi->s_mount_opt, ERRORS_RO);\n  sbi->s_resuid = make_kuid(&init_user_ns, le16_to_cpu(es->s_def_resuid));\n  sbi->s_resgid = make_kgid(&init_user_ns, le16_to_cpu(es->s_def_resgid));\n  set_opt(sbi->s_mount_opt, BARRIER);\n  set_opt(sbi->s_mount_opt, RESERVATION);\n  if (!parse_options ((char *) data, sb, &journal_inum, &journal_devnum,\n          NULL, 0))\n    goto failed_mount;\n  sb->s_flags = (sb->s_flags & ~MS_POSIXACL) |\n    (test_opt(sb, POSIX_ACL) ? MS_POSIXACL : 0);\n  if (le32_to_cpu(es->s_rev_level) == EXT3_GOOD_OLD_REV &&\n      (EXT3_HAS_COMPAT_FEATURE(sb, ~0U) ||\n       EXT3_HAS_RO_COMPAT_FEATURE(sb, ~0U) ||\n       EXT3_HAS_INCOMPAT_FEATURE(sb, ~0U)))\n    ext3_msg(sb, KERN_WARNING,\n      \"warning: feature flags set on rev 0 fs, \"\n      \"running e2fsck is recommended\");\n  features = EXT3_HAS_INCOMPAT_FEATURE(sb, ~EXT3_FEATURE_INCOMPAT_SUPP);\n  if (features) {\n    ext3_msg(sb, KERN_ERR,\n      \"error: couldn't mount because of unsupported \"\n      \"optional features (%x)\", le32_to_cpu(features));\n    goto failed_mount;\n  }\n  features = EXT3_HAS_RO_COMPAT_FEATURE(sb, ~EXT3_FEATURE_RO_COMPAT_SUPP);\n  if (!(sb->s_flags & MS_RDONLY) && features) {\n    ext3_msg(sb, KERN_ERR,\n      \"error: couldn't mount RDWR because of unsupported \"\n      \"optional features (%x)\", le32_to_cpu(features));\n    goto failed_mount;\n  }\n  blocksize = BLOCK_SIZE << le32_to_cpu(es->s_log_block_size);\n  if (blocksize < EXT3_MIN_BLOCK_SIZE ||\n      blocksize > EXT3_MAX_BLOCK_SIZE) {\n    ext3_msg(sb, KERN_ERR,\n      \"error: couldn't mount because of unsupported \"\n      \"filesystem blocksize %d\", blocksize);\n    goto failed_mount;\n  }\n  hblock = bdev_logical_block_size(sb->s_bdev);\n  if (sb->s_blocksize != blocksize) {\n    if (blocksize < hblock) {\n      ext3_msg(sb, KERN_ERR,\n        \"error: fsblocksize %d too small for \"\n        \"hardware sectorsize %d\", blocksize, hblock);\n      goto failed_mount;\n    }\n    brelse (bh);\n    if (!sb_set_blocksize(sb, blocksize)) {\n      ext3_msg(sb, KERN_ERR,\n        \"error: bad blocksize %d\", blocksize);\n      goto out_fail;\n    }\n    logic_sb_block = (sb_block * EXT3_MIN_BLOCK_SIZE) \/ blocksize;\n    offset = (sb_block * EXT3_MIN_BLOCK_SIZE) % blocksize;\n    bh = sb_bread(sb, logic_sb_block);\n    if (!bh) {\n      ext3_msg(sb, KERN_ERR,\n             \"error: can't read superblock on 2nd try\");\n      goto failed_mount;\n    }\n    es = (struct ext3_super_block *)(bh->b_data + offset);\n    sbi->s_es = es;\n    if (es->s_magic != cpu_to_le16(EXT3_SUPER_MAGIC)) {\n      ext3_msg(sb, KERN_ERR,\n        \"error: magic mismatch\");\n      goto failed_mount;\n    }\n  }\n  sb->s_maxbytes = ext3_max_size(sb->s_blocksize_bits);\n  if (le32_to_cpu(es->s_rev_level) == EXT3_GOOD_OLD_REV) {\n    sbi->s_inode_size = EXT3_GOOD_OLD_INODE_SIZE;\n    sbi->s_first_ino = EXT3_GOOD_OLD_FIRST_INO;\n  } else {\n    sbi->s_inode_size = le16_to_cpu(es->s_inode_size);\n    sbi->s_first_ino = le32_to_cpu(es->s_first_ino);\n    if ((sbi->s_inode_size < EXT3_GOOD_OLD_INODE_SIZE) ||\n        (!is_power_of_2(sbi->s_inode_size)) ||\n        (sbi->s_inode_size > blocksize)) {\n      ext3_msg(sb, KERN_ERR,\n        \"error: unsupported inode size: %d\",\n        sbi->s_inode_size);\n      goto failed_mount;\n    }\n  }\n  sbi->s_frag_size = EXT3_MIN_FRAG_SIZE <<\n           le32_to_cpu(es->s_log_frag_size);\n  if (blocksize != sbi->s_frag_size) {\n    ext3_msg(sb, KERN_ERR,\n           \"error: fragsize %lu != blocksize %u (unsupported)\",\n           sbi->s_frag_size, blocksize);\n    goto failed_mount;\n  }\n  sbi->s_frags_per_block = 1;\n  sbi->s_blocks_per_group = le32_to_cpu(es->s_blocks_per_group);\n  sbi->s_frags_per_group = le32_to_cpu(es->s_frags_per_group);\n  sbi->s_inodes_per_group = le32_to_cpu(es->s_inodes_per_group);\n  if (EXT3_INODE_SIZE(sb) == 0 || EXT3_INODES_PER_GROUP(sb) == 0)\n    goto cantfind_ext3;\n  sbi->s_inodes_per_block = blocksize \/ EXT3_INODE_SIZE(sb);\n  if (sbi->s_inodes_per_block == 0)\n    goto cantfind_ext3;\n  sbi->s_itb_per_group = sbi->s_inodes_per_group \/\n          sbi->s_inodes_per_block;\n  sbi->s_desc_per_block = blocksize \/ sizeof(struct ext3_group_desc);\n  sbi->s_sbh = bh;\n  sbi->s_mount_state = le16_to_cpu(es->s_state);\n  sbi->s_addr_per_block_bits = ilog2(EXT3_ADDR_PER_BLOCK(sb));\n  sbi->s_desc_per_block_bits = ilog2(EXT3_DESC_PER_BLOCK(sb));\n  for (i=0; i < 4; i++)\n    sbi->s_hash_seed[i] = le32_to_cpu(es->s_hash_seed[i]);\n  sbi->s_def_hash_version = es->s_def_hash_version;\n  i = le32_to_cpu(es->s_flags);\n  if (i & EXT2_FLAGS_UNSIGNED_HASH)\n    sbi->s_hash_unsigned = 3;\n  else if ((i & EXT2_FLAGS_SIGNED_HASH) == 0) {\n#ifdef __CHAR_UNSIGNED__\n    es->s_flags |= cpu_to_le32(EXT2_FLAGS_UNSIGNED_HASH);\n    sbi->s_hash_unsigned = 3;\n#else\n    es->s_flags |= cpu_to_le32(EXT2_FLAGS_SIGNED_HASH);\n#endif\n  }\n  if (sbi->s_blocks_per_group > blocksize * 8) {\n    ext3_msg(sb, KERN_ERR,\n      \"#blocks per group too big: %lu\",\n      sbi->s_blocks_per_group);\n    goto failed_mount;\n  }\n  if (sbi->s_frags_per_group > blocksize * 8) {\n    ext3_msg(sb, KERN_ERR,\n      \"error: #fragments per group too big: %lu\",\n      sbi->s_frags_per_group);\n    goto failed_mount;\n  }\n  if (sbi->s_inodes_per_group > blocksize * 8) {\n    ext3_msg(sb, KERN_ERR,\n      \"error: #inodes per group too big: %lu\",\n      sbi->s_inodes_per_group);\n    goto failed_mount;\n  }\n  err = generic_check_addressable(sb->s_blocksize_bits,\n          le32_to_cpu(es->s_blocks_count));\n  if (err) {\n    ext3_msg(sb, KERN_ERR,\n      \"error: filesystem is too large to mount safely\");\n    if (sizeof(sector_t) < 8)\n      ext3_msg(sb, KERN_ERR,\n        \"error: CONFIG_LBDAF not enabled\");\n    ret = err;\n    goto failed_mount;\n  }\n  if (EXT3_BLOCKS_PER_GROUP(sb) == 0)\n    goto cantfind_ext3;\n  sbi->s_groups_count = ((le32_to_cpu(es->s_blocks_count) -\n             le32_to_cpu(es->s_first_data_block) - 1)\n               \/ EXT3_BLOCKS_PER_GROUP(sb)) + 1;\n  db_count = DIV_ROUND_UP(sbi->s_groups_count, EXT3_DESC_PER_BLOCK(sb));\n  sbi->s_group_desc = kmalloc(db_count * sizeof (struct buffer_head *),\n            GFP_KERNEL);\n  if (sbi->s_group_desc == NULL) {\n    ext3_msg(sb, KERN_ERR,\n      \"error: not enough memory\");\n    ret = -ENOMEM;\n    goto failed_mount;\n  }\n  bgl_lock_init(sbi->s_blockgroup_lock);\n  for (i = 0; i < db_count; i++) {\n    block = descriptor_loc(sb, logic_sb_block, i);\n    sbi->s_group_desc[i] = sb_bread(sb, block);\n    if (!sbi->s_group_desc[i]) {\n      ext3_msg(sb, KERN_ERR,\n        \"error: can't read group descriptor %d\", i);\n      db_count = i;\n      goto failed_mount2;\n    }\n  }\n  if (!ext3_check_descriptors (sb)) {\n    ext3_msg(sb, KERN_ERR,\n      \"error: group descriptors corrupted\");\n    goto failed_mount2;\n  }\n  sbi->s_gdb_count = db_count;\n  get_random_bytes(&sbi->s_next_generation, sizeof(u32));\n  spin_lock_init(&sbi->s_next_gen_lock);\n  spin_lock_init(&sbi->s_rsv_window_lock);\n  sbi->s_rsv_window_root = RB_ROOT;\n  sbi->s_rsv_window_head.rsv_start = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n  sbi->s_rsv_window_head.rsv_end = EXT3_RESERVE_WINDOW_NOT_ALLOCATED;\n  sbi->s_rsv_window_head.rsv_alloc_hit = 0;\n  sbi->s_rsv_window_head.rsv_goal_size = 0;\n  ext3_rsv_window_add(sb, &sbi->s_rsv_window_head);\n  sb->s_op = &ext3_sops;\n  sb->s_export_op = &ext3_export_ops;\n  sb->s_xattr = ext3_xattr_handlers;\n#ifdef CONFIG_QUOTA\n  sb->s_qcop = &ext3_qctl_operations;\n  sb->dq_op = &ext3_quota_operations;\n#endif\n  memcpy(sb->s_uuid, es->s_uuid, sizeof(es->s_uuid));\n  INIT_LIST_HEAD(&sbi->s_orphan); \n  mutex_init(&sbi->s_orphan_lock);\n  mutex_init(&sbi->s_resize_lock);\n  sb->s_root = NULL;\n  needs_recovery = (es->s_last_orphan != 0 ||\n        EXT3_HAS_INCOMPAT_FEATURE(sb,\n            EXT3_FEATURE_INCOMPAT_RECOVER));\n  if (!test_opt(sb, NOLOAD) &&\n      EXT3_HAS_COMPAT_FEATURE(sb, EXT3_FEATURE_COMPAT_HAS_JOURNAL)) {\n    if (ext3_load_journal(sb, es, journal_devnum))\n      goto failed_mount2;\n  } else if (journal_inum) {\n    if (ext3_create_journal(sb, es, journal_inum))\n      goto failed_mount2;\n  } else {\n    if (!silent)\n      ext3_msg(sb, KERN_ERR,\n        \"error: no journal found. \"\n        \"mounting ext3 over ext2?\");\n    goto failed_mount2;\n  }\n  err = percpu_counter_init(&sbi->s_freeblocks_counter,\n      ext3_count_free_blocks(sb));\n  if (!err) {\n    err = percpu_counter_init(&sbi->s_freeinodes_counter,\n        ext3_count_free_inodes(sb));\n  }\n  if (!err) {\n    err = percpu_counter_init(&sbi->s_dirs_counter,\n        ext3_count_dirs(sb));\n  }\n  if (err) {\n    ext3_msg(sb, KERN_ERR, \"error: insufficient memory\");\n    ret = err;\n    goto failed_mount3;\n  }\n  switch (test_opt(sb, DATA_FLAGS)) {\n  case 0:\n    if (journal_check_available_features\n        (sbi->s_journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE))\n      set_opt(sbi->s_mount_opt, DEFAULT_DATA_MODE);\n    else\n      set_opt(sbi->s_mount_opt, JOURNAL_DATA);\n    break;\n  case EXT3_MOUNT_ORDERED_DATA:\n  case EXT3_MOUNT_WRITEBACK_DATA:\n    if (!journal_check_available_features\n        (sbi->s_journal, 0, 0, JFS_FEATURE_INCOMPAT_REVOKE)) {\n      ext3_msg(sb, KERN_ERR,\n        \"error: journal does not support \"\n        \"requested data journaling mode\");\n      goto failed_mount3;\n    }\n  default:\n    break;\n  }\n  root = ext3_iget(sb, EXT3_ROOT_INO);\n  if (IS_ERR(root)) {\n    ext3_msg(sb, KERN_ERR, \"error: get root inode failed\");\n    ret = PTR_ERR(root);\n    goto failed_mount3;\n  }\n  if (!S_ISDIR(root->i_mode) || !root->i_blocks || !root->i_size) {\n    iput(root);\n    ext3_msg(sb, KERN_ERR, \"error: corrupt root inode, run e2fsck\");\n    goto failed_mount3;\n  }\n  sb->s_root = d_make_root(root);\n  if (!sb->s_root) {\n    ext3_msg(sb, KERN_ERR, \"error: get root dentry failed\");\n    ret = -ENOMEM;\n    goto failed_mount3;\n  }\n  if (ext3_setup_super(sb, es, sb->s_flags & MS_RDONLY))\n    sb->s_flags |= MS_RDONLY;\n  EXT3_SB(sb)->s_mount_state |= EXT3_ORPHAN_FS;\n  ext3_orphan_cleanup(sb, es);\n  EXT3_SB(sb)->s_mount_state &= ~EXT3_ORPHAN_FS;\n  if (needs_recovery) {\n    ext3_mark_recovery_complete(sb, es);\n    ext3_msg(sb, KERN_INFO, \"recovery complete\");\n  }\n  ext3_msg(sb, KERN_INFO, \"mounted filesystem with %s data mode\",\n    test_opt(sb,DATA_FLAGS) == EXT3_MOUNT_JOURNAL_DATA ? \"journal\":\n    test_opt(sb,DATA_FLAGS) == EXT3_MOUNT_ORDERED_DATA ? \"ordered\":\n    \"writeback\");\n  sb->s_flags |= MS_SNAP_STABLE;\n  return 0;\ncantfind_ext3:\n  if (!silent)\n    ext3_msg(sb, KERN_INFO,\n      \"error: can't find ext3 filesystem on dev %s.\",\n           sb->s_id);\n  goto failed_mount;\nfailed_mount3:\n  percpu_counter_destroy(&sbi->s_freeblocks_counter);\n  percpu_counter_destroy(&sbi->s_freeinodes_counter);\n  percpu_counter_destroy(&sbi->s_dirs_counter);\n  journal_destroy(sbi->s_journal);\nfailed_mount2:\n  for (i = 0; i < db_count; i++)\n    brelse(sbi->s_group_desc[i]);\n  kfree(sbi->s_group_desc);\nfailed_mount:\n#ifdef CONFIG_QUOTA\n  for (i = 0; i < MAXQUOTAS; i++)\n    kfree(sbi->s_qf_names[i]);\n#endif\n  ext3_blkdev_remove(sbi);\n  brelse(bh);\nout_fail:\n  sb->s_fs_info = NULL;\n  kfree(sbi->s_blockgroup_lock);\n  kfree(sbi);\n  return ret;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":32923
  },
  {
    "code":"void SynchronousCompositorImpl::DidChangeRootLayerScrollOffset(\n    const gfx::ScrollOffset& root_offset) {\n  DCHECK(CalledOnValidThread());\n  if (!synchronous_input_handler_proxy_)\n    return;\n  synchronous_input_handler_proxy_->SynchronouslySetRootScrollOffset(\n      root_offset);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":128075
  },
  {
    "code":"icmp_type_code_match(u_int8_t test_type, u_int8_t min_code, u_int8_t max_code,\n         u_int8_t type, u_int8_t code,\n         bool invert)\n{\n  return ((test_type == 0xFF) ||\n    (type == test_type && code >= min_code && code <= max_code))\n    ^ invert;\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":52303
  },
  {
    "code":"static void vnc_qmp_event(VncState *vs, QAPIEvent event)\n{\n    VncServerInfo *si;\n    if (!vs->info) {\n        return;\n    }\n    g_assert(vs->info->base);\n    si = vnc_server_info_get();\n    if (!si) {\n        return;\n    }\n    switch (event) {\n    case QAPI_EVENT_VNC_CONNECTED:\n        qapi_event_send_vnc_connected(si, vs->info->base, &error_abort);\n        break;\n    case QAPI_EVENT_VNC_INITIALIZED:\n        qapi_event_send_vnc_initialized(si, vs->info, &error_abort);\n        break;\n    case QAPI_EVENT_VNC_DISCONNECTED:\n        qapi_event_send_vnc_disconnected(si, vs->info, &error_abort);\n        break;\n    default:\n        break;\n    }\n    qapi_free_VncServerInfo(si);\n}\n",
    "vul":0,
    "flaw_line_no":[

    ],
    "bigvul_id":8034
  }
]